{"meta":{"title":"MotainZhang","subtitle":null,"description":null,"author":"MotainZhang","url":"https://motainzhang.com"},"pages":[{"title":"404","date":"2018-10-24T15:51:33.000Z","updated":"2019-10-18T03:34:00.262Z","comments":true,"path":"404/index.html","permalink":"https://motainzhang.com/404/index.html","excerpt":"","text":"&lt;!DOCTYPE html&gt; 404 L2Dwidget.init({\"pluginRootPath\":\"live2dw/\",\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"tagMode\":false,\"debug\":false,\"model\":{\"jsonPath\":\"/live2dw/assets/haruto.model.json\"},\"display\":{\"position\":\"right\",\"width\":100,\"height\":200},\"mobile\":{\"show\":true},\"react\":{\"opacityDefault\":1,\"opacityOnHover\":0.2},\"log\":false});"},{"title":"about","date":"2018-10-24T16:32:46.000Z","updated":"2019-10-18T03:34:00.262Z","comments":true,"path":"about/index.html","permalink":"https://motainzhang.com/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-04-21T22:37:58.000Z","updated":"2019-10-18T03:34:00.262Z","comments":true,"path":"categories/index.html","permalink":"https://motainzhang.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-04-21T22:37:34.000Z","updated":"2019-10-18T03:34:00.262Z","comments":true,"path":"tags/index.html","permalink":"https://motainzhang.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"pom.xml配置详解","slug":"pom.xml配置详解","date":"2019-10-18T03:34:00.262Z","updated":"2019-10-18T03:34:00.262Z","comments":true,"path":"2019/10/18/pom.xml配置详解/","link":"","permalink":"https://motainzhang.com/2019/10/18/pom.xml配置详解/","excerpt":"","text":"pom.xml的作用描述项目。 groupId、artifactId和version构成项目的唯一标识（坐标），不能重复。&lt;properties&gt;属性元素自定义一些常量，比如版本号，字符编码，可以让之后一些依赖的版本直接从这里引用，便于后期修改及管理。 &lt;dependencies&gt;放置依赖，从远程仓库下载依赖的Jar包 依赖需要填写坐标：groupId、artifactId和version scope:依赖作用的范围： compile(默认) 编译时需要，打包时也将该依赖打包 provided 编译时需要，打包时不用 父pom中可以通过&lt;dependencyManagement&gt;放置&lt;dependencies&gt;,用于继承。 如果访问Maven官方的中心仓库很慢（下载依赖耗时，浪费时间），可以更改为使用阿里云提供的镜像仓库： 方式一： 修改%M2_HOME%/conf/settings.xml文件 在&lt;mirrors&gt;元素中添加一个&lt;mirror&gt;配置如下:123456&lt;mirror&gt; &lt;id&gt;aliyun&lt;/id&gt; &lt;mirrorOf&gt;centeral&lt;/mirrorOf&gt; &lt;name&gt;aliyun mirror&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;&lt;/mirror&gt; 在&lt;profiles&gt;中添加一个&lt;profile&gt;配置如下：1234567891011121314151617181920&lt;profile&gt; &lt;id&gt;aliyun&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;/activation&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;aliyun&lt;/id&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;pluginRepositories&gt; &lt;pluginRepository&gt; &lt;id&gt;aliyun&lt;/id&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt;&lt;/profile&gt; 方式二： 修改本地仓库所在目录下的setting.xml文件内容如上。本地仓库一般位于当前用户/.m2目录下。 &lt;build&gt;构建配置 &lt;plugins&gt;插件，比如compiler 父pom中可以通过&lt;pluginManagement&gt;放置&lt;plugins&gt;,用于继承。 &lt;parent&gt;多项目继承参考：Maven pom.xml配置详解","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"https://motainzhang.com/categories/Java-Web/"},{"name":"Maven","slug":"Java-Web/Maven","permalink":"https://motainzhang.com/categories/Java-Web/Maven/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"https://motainzhang.com/tags/Maven/"},{"name":"依赖管理","slug":"依赖管理","permalink":"https://motainzhang.com/tags/依赖管理/"},{"name":"pom.xml","slug":"pom-xml","permalink":"https://motainzhang.com/tags/pom-xml/"}]},{"title":"vue权限路由总结","slug":"vue权限路由总结","date":"2019-10-18T03:34:00.262Z","updated":"2019-10-18T03:34:00.262Z","comments":true,"path":"2019/10/18/vue权限路由总结/","link":"","permalink":"https://motainzhang.com/2019/10/18/vue权限路由总结/","excerpt":"","text":"vue权限路由总结实现前端定义好路由，并且在路由上标记相应的权限信息 const routerMap = [ { path: &apos;/permission&apos;, component: Layout, redirect: &apos;/permission/index&apos;, alwaysShow: true, // will always show the root menu meta: { title: &apos;permission&apos;, icon: &apos;lock&apos;, roles: [&apos;admin&apos;, &apos;editor&apos;] // you can set roles in root nav }, children: [{ path: &apos;page&apos;, component: () =&gt; import(&apos;@/views/permission/page&apos;), name: &apos;pagePermission&apos;, meta: { title: &apos;pagePermission&apos;, roles: [&apos;admin&apos;] // or you can only set roles in sub nav } }, { path: &apos;directive&apos;, component: () =&gt; import(&apos;@/views/permission/directive&apos;), name: &apos;directivePermission&apos;, meta: { title: &apos;directivePermission&apos; // if do not set roles, means: this page does not require permission } }] }] 复制代码 全局路由守卫每次都判断用户是否已经登录，没有登录则跳到登录页。已经登录(已经取得后台返回的用户的权限信息(角色之类的))，则判断当前要跳转的路由，用户是否有权限访问(根据路由名称到全部路由里找到对应的路由，判断用户是否具备路由上标注的权限信息(比如上面的roles: [&#39;admin&#39;, &#39;editor&#39;]))。没有权限则跳到事先定义好的界面(403,404之类的)。 这种方式，菜单可以直接用路由生成(用户没有权限的菜单也会显示，点击跳转的时候才做权限判断)，也可以在用户登录后根据用户权限把路由过滤一遍生成菜单(菜单需要保存在vuex里)。 目前iview-admin还是用的这种方式 缺点 加载所有的路由，如果路由很多，而用户并不是所有的路由都有权限访问，对性能会有影响。 全局路由守卫里，每次路由跳转都要做权限判断。 菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译 菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识 登录页与主应用分离针对前一种实现方式的缺点，可以将登录页与主应用放到不同的页面(不在同一个vue应用实例里)。 实现登录成功后，进行页面跳转(真正的页面跳转，不是路由跳转)，并将用户权限传递到主应用所在页面，主应用初始化之前，根据用户权限筛选路由，筛选后的路由作为vue的实例化参数，而不是像前一种方式所有的路由都传递进去，也不需要在全局路由守卫里做权限判断了。 缺点 需要做页面跳转，不是纯粹的单页应用 菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译 菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识 使用addRoutes动态挂载路由addRoutes允许在应用初始化之后，动态的挂载路由。有了这个新姿势，就不用像前一种方式那样要在应用初始化之要对路由进行筛选。 实现应用初始化的时候先挂载不需要权限控制的路由，比如登录页，404等错误页。 有个问题，addRoutes应该何时调用，在哪里调用 登录后，获取用户的权限信息，然后筛选有权限访问的路由，再调用addRoutes添加路由。这个方法是可行的。但是不可能每次进入应用都需要登录，用户刷新浏览器又要登陆一次。 所以addRoutes还是要在全局路由守卫里进行调用 import router from &apos;./router&apos; import store from &apos;./store&apos; import { Message } from &apos;element-ui&apos; import NProgress from &apos;nprogress&apos; // progress bar import &apos;nprogress/nprogress.css&apos;// progress bar style import { getToken } from &apos;@/utils/auth&apos; // getToken from cookie NProgress.configure({ showSpinner: false })// NProgress Configuration // permission judge function function hasPermission(roles, permissionRoles) { if (roles.indexOf(&apos;admin&apos;) &gt;= 0) return true // admin permission passed directly if (!permissionRoles) return true return roles.some(role =&gt; permissionRoles.indexOf(role) &gt;= 0) } const whiteList = [&apos;/login&apos;, &apos;/authredirect&apos;]// no redirect whitelist router.beforeEach((to, from, next) =&gt; { NProgress.start() // start progress bar if (getToken()) { // determine if there has token /* has token*/ if (to.path === &apos;/login&apos;) { next({ path: &apos;/&apos; }) NProgress.done() // if current page is dashboard will not trigger afterEach hook, so manually handle it } else { if (store.getters.roles.length === 0) { // 判断当前用户是否已拉取完user_info信息 store.dispatch(&apos;GetUserInfo&apos;).then(res =&gt; { // 拉取user_info const roles = res.data.roles // note: roles must be a array! such as: [&apos;editor&apos;,&apos;develop&apos;] store.dispatch(&apos;GenerateRoutes&apos;, { roles }).then(() =&gt; { // 根据roles权限生成可访问的路由表 router.addRoutes(store.getters.addRouters) // 动态添加可访问路由表 next({ ...to, replace: true }) // hack方法 确保addRoutes已完成 ,set the replace: true so the navigation will not leave a history record }) }).catch((err) =&gt; { store.dispatch(&apos;FedLogOut&apos;).then(() =&gt; { Message.error(err || &apos;Verification failed, please login again&apos;) next({ path: &apos;/&apos; }) }) }) } else { // 没有动态改变权限的需求可直接next() 删除下方权限判断 ↓ if (hasPermission(store.getters.roles, to.meta.roles)) { next()// } else { next({ path: &apos;/401&apos;, replace: true, query: { noGoBack: true }}) } // 可删 ↑ } } } else { /* has no token*/ if (whiteList.indexOf(to.path) !== -1) { // 在免登录白名单，直接进入 next() } else { next(&apos;/login&apos;) // 否则全部重定向到登录页 NProgress.done() // if current page is login will not trigger afterEach hook, so manually handle it } } }) router.afterEach(() =&gt; { NProgress.done() // finish progress bar }) 复制代码 关键的代码如下 if (store.getters.roles.length === 0) { // 判断当前用户是否已拉取完user_info信息 store.dispatch(&apos;GetUserInfo&apos;).then(res =&gt; { // 拉取user_info const roles = res.data.roles // note: roles must be a array! such as: [&apos;editor&apos;,&apos;develop&apos;] store.dispatch(&apos;GenerateRoutes&apos;, { roles }).then(() =&gt; { // 根据roles权限生成可访问的路由表 router.addRoutes(store.getters.addRouters) // 动态添加可访问路由表 next({ ...to, replace: true }) // hack方法 确保addRoutes已完成 ,set the replace: true so the navigation will not leave a history record }) }).catch((err) =&gt; { store.dispatch(&apos;FedLogOut&apos;).then(() =&gt; { Message.error(err || &apos;Verification failed, please login again&apos;) next({ path: &apos;/&apos; }) }) }) 复制代码 上面的代码就是vue-element-admin的实现 缺点 全局路由守卫里，每次路由跳转都要做判断 菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译 菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识 菜单与路由分离，菜单由后端返回菜单的显示标题，图片等需要随时更改，要对菜单做管理功能。 后端直接根据用户权限返回可访问的菜单。 实现前端定义路由信息(标准的路由定义，不需要加其他标记字段)。 { name: &quot;login&quot;, path: &quot;/login&quot;, component: () =&gt; import(&quot;@/pages/Login.vue&quot;) } 复制代码 name字段都不为空，需要根据此字段与后端返回菜单做关联。 做菜单管理功能的时候，一定要有个字段与前端的路由的name字段对应上(也可以是其他字段，只要菜单能找到对应的路由或者路由能找到对应的菜单就行)，并且做唯一性校验。菜单上还需要定义权限字段，可以是一个或多个。其他信息，比如显示标题，图标，排序，锁定之类的，可以根据实际需求进行设计。 还是在全局路由守卫里做判断 function hasPermission(router, accessMenu) { if (whiteList.indexOf(router.path) !== -1) { return true; } let menu = Util.getMenuByName(router.name, accessMenu); if (menu.name) { return true; } return false; } Router.beforeEach(async (to, from, next) =&gt; { if (getToken()) { let userInfo = store.state.user.userInfo; if (!userInfo.name) { try { await store.dispatch(&quot;GetUserInfo&quot;) await store.dispatch(&apos;updateAccessMenu&apos;) if (to.path === &apos;/login&apos;) { next({ name: &apos;home_index&apos; }) } else { //Util.toDefaultPage([...routers], to.name, router, next); next({ ...to, replace: true })//菜单权限更新完成,重新进一次当前路由 } } catch (e) { if (whiteList.indexOf(to.path) !== -1) { // 在免登录白名单，直接进入 next() } else { next(&apos;/login&apos;) } } } else { if (to.path === &apos;/login&apos;) { next({ name: &apos;home_index&apos; }) } else { if (hasPermission(to, store.getters.accessMenu)) { Util.toDefaultPage(store.getters.accessMenu,to, routes, next); } else { next({ path: &apos;/403&apos;,replace:true }) } } } } else { if (whiteList.indexOf(to.path) !== -1) { // 在免登录白名单，直接进入 next() } else { next(&apos;/login&apos;) } } let menu = Util.getMenuByName(to.name, store.getters.accessMenu); Util.title(menu.title); }); Router.afterEach((to) =&gt; { window.scrollTo(0, 0); }); 复制代码 上面代码是vue-quasar-admin的实现。因为没有使用addRoutes,每次路由跳转的时候都要判断权限，这里的判断也很简单，因为菜单的name与路由的name是一一对应的,而后端返回的菜单就已经是经过权限过滤的，所以如果根据路由name找不到对应的菜单，就表示用户有没权限访问。 如果路由很多，可以在应用初始化的时候，只挂载不需要权限控制的路由。取得后端返回的菜单后，根据菜单与路由的对应关系，筛选出可访问的路由，通过addRoutes动态挂载。 缺点 菜单需要与路由做一一对应，前端添加了新功能，需要通过菜单管理功能添加新的菜单，如果菜单配置的不对会导致应用不能正常使用 全局路由守卫里，每次路由跳转都要做判断 菜单与路由完全由后端返回菜单由后端返回是可行的，但是路由由后端返回呢？看一下路由的定义 { name: &quot;login&quot;, path: &quot;/login&quot;, component: () =&gt; import(&quot;@/pages/Login.vue&quot;) } 复制代码 后端如果直接返回 { &quot;name&quot;: &quot;login&quot;, &quot;path&quot;: &quot;/login&quot;, &quot;component&quot;: &quot;() =&gt; import(&apos;@/pages/Login.vue&apos;)&quot; } 复制代码 这是什么鬼，明显不行。() =&gt; import(&#39;@/pages/Login.vue&#39;)这代码如果没出现在前端，webpack不会对Login.vue进行编译打包 实现前端统一定义路由组件，比如 const Home = () =&gt; import(&quot;../pages/Home.vue&quot;); const UserInfo = () =&gt; import(&quot;../pages/UserInfo.vue&quot;); export default { home: Home, userInfo: UserInfo }; 复制代码 将路由组件定义为这种key-value的结构。 后端返回格式 [ { name: &quot;home&quot;, path: &quot;/&quot;, component: &quot;home&quot; }, { name: &quot;home&quot;, path: &quot;/userinfo&quot;, component: &quot;userInfo&quot; } ] 复制代码 在将后端返回路由通过addRoutes动态挂载之间，需要将数据处理一下，将component字段换为真正的组件。 至于菜单与路由是否还要分离，怎么对应，可以根据实际需求进行处理。 如果有嵌套路由，后端功能设计的时候，要注意添加相应的字段。前端拿到数据也要做相应的处理。 缺点 全局路由守卫里，每次路由跳转都要做判断 前后端的配合要求更高 不使用全局路由守卫前面几种方式，除了登录页与主应用分离,每次路由跳转，都在全局路由守卫里做了判断。 实现应用初始化的时候只挂载不需要权限控制的路由 const constRouterMap = [ { name: &quot;login&quot;, path: &quot;/login&quot;, component: () =&gt; import(&quot;@/pages/Login.vue&quot;) }, { path: &quot;/404&quot;, component: () =&gt; import(&quot;@/pages/Page404.vue&quot;) }, { path: &quot;/init&quot;, component: () =&gt; import(&quot;@/pages/Init.vue&quot;) }, { path: &quot;*&quot;, redirect: &quot;/404&quot; } ]; export default constRouterMap; 复制代码 import Vue from &quot;vue&quot;; import Router from &quot;vue-router&quot;; import ConstantRouterMap from &quot;./routers&quot;; Vue.use(Router); export default new Router({ // mode: &apos;history&apos;, // require service support scrollBehavior: () =&gt; ({ y: 0 }), routes: ConstantRouterMap }); 复制代码 登录成功后跳到/路由 submitForm(formName) { let _this=this; this.$refs[formName].validate(valid =&gt; { if (valid) { _this.$store.dispatch(&quot;loginByUserName&quot;,{ name:_this.ruleForm2.name, pass:_this.ruleForm2.pass }).then(()=&gt;{ _this.$router.push({ path:&apos;/&apos; }) }) } else { return false; } }); } 复制代码 因为当前没有/路由，会跳到/404 &lt;template&gt; &lt;h1&gt;404&lt;/h1&gt; &lt;/template&gt; &lt;script&gt; export default { name:&apos;page404&apos;, mounted(){ if(!this.$store.state.isLogin){ this.$router.replace({ path: &apos;/login&apos; }); return; } if(!this.$store.state.initedApp){ this.$router.replace({ path: &apos;/init&apos; }); return } } } &lt;/script&gt; 复制代码 404组件里判断已经登录，接着判断应用是否已经初始化(用户权限信息，可访问菜单，路由等是否已经从后端取得)。没有初始化则跳转到/init路由 &lt;template&gt; &lt;div&gt;&lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { getAccessMenuList } from &quot;../mock/menus&quot;; import components from &quot;../router/routerComponents.js&quot;; export default { async mounted() { if (!this.$store.state.isLogin) { this.$router.push({ path: &quot;/login&quot; }); return; } if (!this.$store.state.initedApp) { const loading = this.$loading({ lock: true, text: &quot;初始化中&quot;, spinner: &quot;el-icon-loading&quot;, background: &quot;rgba(0, 0, 0, 0.7)&quot; }); let menus = await getAccessMenuList(); //模拟从后端获取 var routers = [...menus]; for (let router of routers) { let component = components[router.component]; router.component = component; } this.$router.addRoutes(routers); this.$store.dispatch(&quot;setAccessMenuList&quot;, menus).then(() =&gt; { loading.close(); this.$router.replace({ path: &quot;/&quot; }); }); return; } else { this.$router.replace({ path: &quot;/&quot; }); } } }; &lt;/script&gt; 复制代码 init组件里判断应用是否已经初始化(避免初始化后，直接从地址栏输入地址再次进入当前组件)。 如果已经初始化，跳转/路由(如果后端返回的路由里没有定义次路由，则会跳转404)。 没有初始化，则调用远程接口获取菜单和路由等，然后处理后端返回的路由，将component赋值为真正 的组件，接着调用addRoutes挂载新路由，最后跳转/路由即可。菜单的处理也是在此处，看实际 需求。 实现例子 缺点 在404页面做了判断，感觉比较怪异 多引入了一个init页面组件 总结比较推荐后面两种实现方式。","categories":[{"name":"前端","slug":"前端","permalink":"https://motainzhang.com/categories/前端/"}],"tags":[]},{"title":"洞察 video 超能力系列——玩转 mp4","slug":"西瓜播放器","date":"2019-10-18T03:34:00.262Z","updated":"2019-10-18T03:34:00.262Z","comments":true,"path":"2019/10/18/西瓜播放器/","link":"","permalink":"https://motainzhang.com/2019/10/18/西瓜播放器/","excerpt":"","text":"洞察 video 超能力系列——玩转 mp4用技术提升美好事物发生的概率 Technologically, for greater probability to be happy. 前言只要在 HTML5 中使用过视频播放的同学对 video 标签一定不会陌生，不过很多同学只使用了 video 的基础功能，实际上 video 拥有强大潜能的，只要姿势正确就能让其拥有超能力。不妨从下面几个场景来逐渐了解下video 未曾被发掘的神秘空间： 清晰度无缝切换 节省视频流量 清晰度无缝切换点播领域里 mp4 是最普遍、兼容性最好的视频容器，不过 mp4 也有它的局限性，比如常见的清晰度切换，我们是无法像youtube那样做到无缝切换的。我们可以看下普通的mp4播放的网络请求和youtube视频播放的网络请求的区别。 图1.1 普通mp4的下载请求过程 图1.2 Youtube视频下载请求过程 这两张图不难看出，在默认情况下 mp4 使用一次 http 请求所有的视频数据，Youtube 则分次请求。当然这个描述很不专业，但确实形象。造成这种差异的是 video 不支持流式的视频数据，Youtube 采用的是流式的视频容器 webm，而 mp4 是非流式的。那如何解释清楚流式的视频数据呢，从专业的角度三言两语很难说清楚，但用大白话翻译过来就是流式的视频数据支持分段独立播放，非流式的不可以。换句话说一个10M的视频文件，流式的视频可以把0~1M的数据请求回来单独播放，但是非流式的不可以。 上面我们描述了视频格式的不同，接下来我们要说的是第一张图中的视频加载是浏览器来控制的，通过给 video 的 src 属性配置视频地址，触发播放之后浏览器就会开始下载了，JS干涉不了。而 Youtube 的视频加载是通过JS来控制的，各位可以再次看下第二张图的网络请求类型：xhr，足以证明这一点。 上面两点搞清楚之后我们就该说下清晰度切换的事情了。这个需求大家都不陌生，但是直接使用 mp4 格式做无缝清晰度切换，难度还挺大的。先解释下“无缝清晰度切换”的概念：从播放一个分辨率的视频到另一个分辨率且保证画面、声音不停顿的平滑切换过程。了解了这个概念，大家应该知道了用 video 无缝切换 mp4 有多难。一方面，video 是不支持流式的视频格式的，一方面，video 的加载是不受JS控制的。通过切换 video 的 src 属性，必然会导致画面中断、重新请求视频数据等。有的同学想到说利用两个 video 再结合 z-index 来搞，但是当你生成另一个video去加载视频的时候，无法保证两个画面是严格一致的，即使将原来的画面暂停到一个时刻，用另一个视频通过 currentTime 属性与之同步，切换仍然看到画面闪烁，基本无法和 Youtube 无缝切换的体验匹敌。而且还会造成更多流量的浪费，背后的原因大家可以研究下 mp4 容器和 webm 容器的异同，也可以看下视频解码相关的文章。 还有一种方法就是将 mp4 格式统统转码到流式的视频格式比如 hls、webm 等。不过这种看上去可行的方式实际上会带来很大的成本开销，如将大量视频做转码会消耗高昂的机器资源、双倍存储的费用、CDN的双倍费用等等。其实我们也是在这种背景下研究出来新的技术问题解决清晰度无缝切换的。 首先，我们改变对 mp4 视频的播放流程，不再直接使用 video 的 src 来播放，因为我们没有任何可以操作的空间。video不仅支持 src 属性还支持 Blob 对象，我们就是利用后者。播放的流程如下： 图1.3 mp4 视频新播放流程 来请求 mp4 视频数据，这样可以结合视频 Range 服务，做到精确加载。 编写解析器将加载回来的部分 mp4 视频数据进行解复用 将解复用的视频数据转成 fmp4 格式并传递给 MediaSource 使用 video 进行解码完成播放 然后在做清晰度切换的时候流程如下： 图1.4 mp4视频清晰度切换原理示意图 播放视频A，过程同上 在某个时刻，用户切换到播放视频B，首先解析B的索引文件（moov），反向计算mp4的range区间 加载B的视频区间数据 解复用 把数据转换成fmp4格式并传递给MediaSource 删除A的部分Buffer 在下一个关键帧自动完成画质的切换 图1.5 mp4视频清晰度切换流程示意图 这个过程看上去比较繁琐，但是所有的操作都是在浏览器端完成，也就是说都是JS来实现的。这样之前说的所有成本问题都不存在，还能做到youtube相同体验的无缝切换。如果大家也想使用这个功能不需要自己再去实现一遍上述流程，可以使用如下代码： 如果对这段代码有什么疑惑，或者想深入了解下它背后是如何实现的，可以参考github.com/bytedance/x… 长按识别二维码 ⬇️ 节省视频流量使用 video 的同学基本上都是这样用的，如下： 利用src属性 2. 利用source标签 这样就可以播放视频了，不过前面我们讲过这样使用 video ，视频的加载是受浏览器控制的，可以看下浏览器在视频刚开始播放的时候下载了多少数据： 图2.1 video默认下载截图 我随便找了个视频，大家看下视频总长度是 02:08,在播放到 00:05 的时候，浏览器已经下载到 01:30 了，如果用户终止观看，下载的视频就这样被浪费掉了。当然，如果不断的 seek 也会造成较多的流量浪费。按照我们之前的统计在短视频领域，用户 seek 的频率在 80%，所以这部分流量是可以节省掉的。具体原理如下: 图2.2 播放器加载视频原理 设置每次加载的数据包大小 设置预加载时长 开启加载队列，完成第一次数据包下载，判断缓冲时间和预加载时长是否满足，不满足请求下一个数据包 具体实现代码如下： 这样就实现了视频在播放过程中永远只预加载10秒的数据，进而保证节省流量。 了解超能力西瓜播放器是如何炼成的： h5player.bytedance.com","categories":[{"name":"前端","slug":"前端","permalink":"https://motainzhang.com/categories/前端/"},{"name":"后端","slug":"前端/后端","permalink":"https://motainzhang.com/categories/前端/后端/"}],"tags":[]},{"title":"2018春招前端面试","slug":"春招面试nodejs","date":"2019-10-18T03:34:00.262Z","updated":"2019-10-18T03:34:00.262Z","comments":true,"path":"2019/10/18/春招面试nodejs/","link":"","permalink":"https://motainzhang.com/2019/10/18/春招面试nodejs/","excerpt":"","text":"2018春招前端面试: 闯关记(精排精校)前言 去年年末研发组解散失业, so选择回去学车了,也顺利拿到了驾照 最近回归大深圳….开始踏上漫漫的找工作之路; “拉勾上吊一百年不匹配!!!”,”BOSS直聘日夜没反应!!!” 题目范围涵盖我最近遇到的笔试题和面谈的(CSS/JS/HTTP/Node/Hybrid/Vue/NG/React) emm…..这里不列举哪些公司了, 若是你完整的阅读一遍,相信你有不少的收获,谢谢阅读 截止目前(2018/3/23)总共汇总了140个问题(我去面的创业,中大型皆有)… 期间死在各种一面/二面/三面/四面皆有之,也拿到部分和推掉部分offer,还有一些后续不清楚的 问题汇总,想到就写….Q: CSS 有哪些样式可以给子元素继承! 可继承的:font-size,font-weight,line-height,color,cursor等 不可继承的一般是会改变盒子模型的:display,margin、border、padding、height等 更加全面的可以到引擎找 Q: 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？ 行内: input,span,a,img以及display:inline的元素 块级: p,div,header,footer,aside,article,ul以及display:block这些 void: br,hr Q: CSS3实现一个扇形 思路跟画实体三角形一个道理,只不过多了一个圆角属性 &lt;!DOCTYPE html&gt; 扇形 .sector { width: 0; height: 0; border-width: 50px; border-style: solid; border-color: #f00 transparent transparent; border-radius: 50px; } L2Dwidget.init({\"pluginRootPath\":\"live2dw/\",\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"tagMode\":false,\"debug\":false,\"model\":{\"jsonPath\":\"/live2dw/assets/haruto.model.json\"},\"display\":{\"position\":\"right\",\"width\":100,\"height\":200},\"mobile\":{\"show\":true},\"react\":{\"opacityDefault\":1,\"opacityOnHover\":0.2},\"log\":false}); 复制代码 Q: box-sizing常用的属性有哪些? 分别有啥作用?box-sizing有两个值:content-box(W3C标准盒模型),border-box(怪异模型), 这个css 主要是改变盒子模型大小的计算形式 可能有人会问padding-box,这个之前只有 Firefox 标准实现了,目前50+的版本已经废除; 用一个栗子来距离,一个div的宽高分别100px,border为5px,padding为5px &lt;style&gt; .test { box-sizing: content-box; border: 5px solid #f00; padding:5px; width: 100px; height: 100px; } &lt;/style&gt; &lt;div class=&quot;test&quot;&gt;&lt;/div&gt; &lt;!-- content-box的计算公式会把宽高的定义指向 content,border和 padding 另外计算, 也就是说 content + padding + border = 120px(盒子实际大小) 而border-box的计算公式是总的大小涵盖这三者, content 会缩小,来让给另外两者 content(80px) + padding(5*2px) + border(5*2px) = 100px --&gt; 复制代码 Q: 清除浮动的方式有哪些?比较好的是哪一种?常用的一般为三种.clearfix, clear:both,overflow:hidden; 比较好是 .clearfix,伪元素万金油版本…后两者有局限性..等会再扯 .clearfix:after { visibility: hidden; display: block; font-size: 0; content: &quot; &quot;; clear: both; height: 0; } &lt;!-- 为毛没有 zoom ,_height 这些...IE6,7这类需要 csshack 不再我们考虑之内了 .clearfix 还有另外一种写法... --&gt; .clearfix:before, .clearfix:after { content:&quot;&quot;; display:table; } .clearfix:after{ clear:both; overflow:hidden; } .clearfix{ zoom:1; } &lt;!-- 用display:table 是为了避免外边距margin重叠导致的margin塌陷, 内部元素默认会成为 table-cell 单元格的形式 --&gt; 复制代码 clear:both:若是用在同一个容器内相邻元素上,那是贼好的…有时候在容器外就有些问题了, 比如相邻容器的包裹层元素塌陷 overflow:hidden:这种若是用在同个容器内,可以形成 BFC避免浮动造成的元素塌陷 Q: CSS 中transition和animate有何区别? animate 如何停留在最后一帧!这种问题见仁见智,我的回答大体是这样的..待我捋捋. transition一般用来做过渡的, 没时间轴的概念, 通过事件触发(一次),没中间状态(只有开始和结束) 而animate则是做动效,有时间轴的概念(帧可控),可以重复触发和有中间状态; 过渡的开销比动效小,前者一般用于交互居多,后者用于活动页居多; 至于如何让animate停留在最后一帧也好办,就它自身参数的一个值就可以了 animation-fill-mode: forwards; &lt;!--backwards则停留在首帧,both是轮流--&gt; 复制代码 让我们来举个栗子….自己新建一个 html 跑一下…. &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Box-sizing&lt;/title&gt; &lt;style&gt; .test { box-sizing: border-box; border: 5px solid #f00; padding: 5px; width: 100px; height: 100px; position:absolute; /* 简写的姿势排序 @keyframes name : 动画名 duration 持续时间 timing-function 动画频率 delay 延迟多久开始 iteration-count 循环次数 direction 动画方式,往返还是正向 fill-mode 一般用来处理停留在某一帧 play-state running 开始,paused 暂停 .... 更多的参数去查文档吧..我就不一一列举了 */ animation: moveChangeColor ease-in 2.5s 1 forwards running; } @keyframes moveChangeColor { from { top:0%; left:5%; background-color:#f00 } to{ top:0%; left:50%; background-color:#ced; } } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;test&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 复制代码 Q: 块级元素水平垂直居中的方法我们要考虑两种情况,定宽高和不定宽高的; 方案 N 多种,我记得我很早写过这类的笔记 传送门:网页元素居中攻略记 Q: 说说样式权重的优先级;!important &gt; 行内样式 > id > class > tag 样式权重可以叠加, 比如 id&gt;class Q: 对HTML语义化的理解简言之:就是不滥用标签(比如 DIV)/随意嵌套(比如 span&gt;div) , 类的命名要合理, 利于浏览器解析乃至引擎收录,也利于团队协作和维护 Q: JS有几种数据类型,其中基本数据类型有哪些!七种数据类型 Boolean Null Undefined Number String Symbol (ECMAScript 6 新定义) Object (ES6之前)其中5种为基本类型:string,number,boolean,null,undefined, ES6出来的Symbol也是原始数据类型 ，表示独一无二的值 Object 为引用类型(范围挺大),也包括数组、函数, Q: null和undefined的差异大体说一下,想要知其所以然请引擎搜索 相同点: 在 if判断语句中,值都默认为 false 大体上两者都是代表无,具体看差异 差异: null转为数字类型值为0,而undefined转为数字类型为 NaN(Not a Number) undefined是代表调用一个值而该值却没有赋值,这时候默认则为undefined null是一个很特殊的对象,最为常见的一个用法就是作为参数传入(说明该参数不是对象) 设置为null的变量或者对象会被内存收集器回收 Q: JS 的DOM 操作(Node节点获取及增删查改); 获取(太多了,有document.getElementById/ClassName/Name/TagName 等,或者 querySelector) // example // get Node var element = document.querySelector(&apos;#test&apos;); // 追加 element.appendChild(Node); // 删除 element.removeChild(Node); // 查找 element.nextSibling // 获取元素之后的兄弟节点 , 会拿到注释文本,空白符这些 element.nextElementSibling // 等同, 获取标签(不会拿到注释文本这些) element.previousSibling // 和上面同理,往前找兄弟节点 element.previousElementSibling // 改动,比如 属性这些 element.setAttribute(name, value); // 增加属性 element.removeAttribute(attrName); //删除属性 // 来一个简易的练习题,随便一个网页追加插入一块DOM(非覆盖:不能 innerHTML); /* &lt;div id=&quot;test&quot;&gt; &lt;span&gt;Hello, World&lt;/span&gt; &lt;/div&gt; */ // 以上面的例子为例 var test = document.createElement(&apos;div&apos;); // 创建一个块级元素 test.setAttribute(&quot;id&quot;,&quot;test&quot;); // 设置其id 属性 var span = document.createElement(&apos;span&apos;); // 创建一个 span span.innerText = &quot;Hello,world&quot;; // 插入 span 的文本内容 test.appendChild(span); // 组合节点 element.appendChild(test); //追加到某个节点区域 复制代码 Q: 给一个 DOM添加捕获和冒泡的两种写法的事件点击,谁先执行?分情况分析: 有拿到节点的,优先捕获,没有才往上冒泡寻找 若是通过node.addEventListener(&#39;event&#39;,callback,bubble or capture); 谁先调用谁先执行 stackoverflow 有相关的探讨: Event listeners registered for capturing phase not triggered before bubbling - why? Q: 谈谈你对ajax 的理解,以及用原生 JS 实现有哪些要点需要注意;ajax全称是异步 javascript 和 XML,用来和服务端进行数据交互的,让无刷新替换页面数据成了可能; 至于有哪些要要点,来一个简短的ajax请求 var xhr = new XMLHttpRequest(); // 声明一个请求对象 xhr.onreadystatechange = function(){ if(xhr.readyState === 4){ // readyState 4 代表已向服务器发送请求 if(xhr.status === OK){ // // status 200 代表服务器返回成功 console.log(xhr.responseText); // 这是返回的文本 } else{ console.log(&quot;Error: &quot;+ xhr.status); // 连接失败的时候抛出错误 } } } xhr.open(&apos;GET&apos;, &apos;xxxx&apos;); // 如何设置请求头? xhr.setRequestHeader(header, value); xhr.setRequestHeader(&apos;Content-Type&apos;, &apos;application/json&apos;); xhr.send(null); // get方法 send null(亦或者不传,则直接是传递 header) ,post 的 send 则是传递值 复制代码 更为详细的可以阅读此处; &lt;&gt; &lt;&gt; Q: JS 实现一个闭包函数,每次调用都自增1;这里主要考察了闭包,函数表达式以及 IIFE(立即执行表达式) var add = (function() { // 声明一变量,由于下面 return所以变量只会声明一次 var count = 0; return function() { return console.log(count++); }; })(); add(); // 0 add(); // 1 add(); // 2 复制代码 Q: [‘1’,’2’,’3’].map(parseInt) 输出什么,为什么?[&apos;1&apos;,&apos;2&apos;,&apos;3&apos;].map(parseInt); // [1,NaN,NaN] // 刨析 // map有三个参数:数组元素，元素索引，原数组本身 // parseInt有两个参数,元素本身以及进制 // 理清了这两个就好办了... // [&apos;1&apos;,&apos;2&apos;,&apos;3&apos;].map(parseInt); 等于如下 [&apos;1&apos;,&apos;2&apos;,&apos;3&apos;].map(function(item,index,array){ return parseInt(item,index); // 是不是一目了然 }); // parseInt(&quot;1&quot;,0); =&gt; 1 // parseInt(&quot;2&quot;,1); =&gt; NaN // parseInt(&quot;3&quot;,2); =&gt; NaN 复制代码 Q: 对数组 [‘2018-03-05’, ‘2013-06-12’,’2019-03-12’,’2018-03-05’,’2014-02-22’] 去重且排序我这里用的是结合 ES6的,代码量很短 //很好理解, Set 具有值唯一性(但不是所有值,等会我抛出我的另外一篇文章) // 结合...解构,可以把可迭代(比如 arguments/nodelist 等)的转为数组 // sort 里面传入 两个值比较,返回-1和1是因为1代表这个数大排后(相对),-1代表小(相对),0为相等 let arr = [...new Set([&apos;2018-03-05&apos;, &apos;2013-06-12&apos;,&apos;2019-03-12&apos;,&apos;2018-03-05&apos;,&apos;2014-02-22&apos;])].sort(function(a,b){ return a&lt;b ? -1:1; // 这里返回的是升序的,降序改下返回值就好了.所以是相对 }) // [&quot;2013-06-12&quot;, &quot;2014-02-22&quot;, &quot;2018-03-05&quot;, &quot;2019-03-12&quot;] 复制代码 对于数组去重的,有兴趣的可以看下我这篇水文: JS数组去重!!!一篇不怎么靠谱的”深度”水文 Q: 对数组[1,2,3,4,5,&#39;6&#39;,7,&#39;8&#39;,&#39;a&#39;,&#39;b&#39;,&#39;z&#39;]进行乱序// 我们依旧可以用上面的 sort 的原理实现乱序 let tempArr = [1,2,3,4,5,&apos;6&apos;,7,&apos;8&apos;,&apos;a&apos;,&apos;b&apos;,&apos;z&apos;].sort(function(){ return Math.random() &gt; 0.5 ? -1 : 1; }) // 因为里面有随机数,所以答案没有标准答案,我这边跑了一次是输出这个 //[&quot;6&quot;, &quot;z&quot;, 3, &quot;b&quot;, 5, 2, 7, &quot;8&quot;, &quot;a&quot;, 1, 4] 复制代码 上面和这道题逗涉及到数组顺序的问题,想了解下为什么 a-b,a&gt;b这类可以更改排序 可以看看知乎对于这块的探讨: 传送门:javascript排序return a-b? Q: 求[1, 10, 11, -1,&#39;-5&#39;,12, 13, 14, 15, 2, 3, 4, 7, 8, 9]内最大值与最小值之差// 来一个很粗糙的版本,只当传入是数组且可以隐性转为数字的 function MaxMinPlus(arr) { // 返回最大值与最小值之差 return Array.isArray(arr) ? Math.max.apply(Math, arr) - Math.min.apply(Math, arr) : console.log(&apos;传入的不是数组亦或者未能解决的错误&apos;) } // 结果是 20 // 若是要完善的话,要考虑传入的是非数组, //传入字符串的时候要判断,然后切割为数组.. // 都要考虑进去代码量不短 复制代码 Q: 请给Array实现一个方法,去重后返回重复的字符(新数组) var testArr = [1,6,8,3,7,9,2,7,2,4,4,3,3,1,5,3]; Array.prototype.extraChar = function(){ var cacheExtraChar = []; // 缓存重复出现的字符 var that = this; // 缓存 this; this.map(function(item,index){ // 怎么理解这段代码呢? // 就是向前往后查找一遍和从后往前查找一遍,不等就是没有重复 // 为什么还要判断一遍缓存,是过滤缓存数组内多次写入 (that.indexOf(item) !== that.lastIndexOf(item)) &amp;&amp; cacheExtraChar.indexOf(item) === -1 ? cacheExtraChar.push(item) : -1; }); return cacheExtraChar; } testArr.extraChar(); // [1, 3, 7, 2, 4] // 若是还需要排序就再排序下 [1,6,8,3,7,9,2,7,2,4,4,3,3,1,5,3] .extraChar() .sort(function(a,b){return a-b}) // [1, 2, 3, 4, 7] 复制代码 Q: 一个数组中 par中存放了多个人员的信息,每个人员的信息由 name 和 age 构成({name:&#39;张三&#39;,age:15}).请用 JS 实现年龄从小到大的排序;var par = [{age:5,name:&apos;张三&apos;},{age:3,name:&apos;李四&apos;},{age:15,name:&apos;王五&apos;},{age:1,name:&apos;随便&apos;}] var parSort = par.sort(function(a,b){ return a.age - b.age; }) 复制代码 Q: 判断一个回文字符串和同字母异序字符串 回文字符串就是正序倒序都是一样的; 同字母异序字符串则是字符串都一样,但是位置可能不一定一样,比如abcefd和dceabf=&gt;return true 后者的思路就是用排序把异序扭正.. 普通版 // 回文判断 , 比如用 abcba var isPalindromes = function(params){ params = params.toString().toLowerCase() return params === params.split(&apos;&apos;).reverse().join(&apos;&apos;); } // 同字母异序判定,比如`abcefd`和`dceabf` var isAnagram = function(str1, str2) { str1 = str1.toString().toLowerCase(); str2 = str2.toString().toLowerCase(); return str1.split(&apos;&apos;).sort().join(&apos;&apos;) === str2.split(&apos;&apos;).sort().join(&apos;&apos;) } 复制代码 进阶版:多一些特殊字符 若是我们要去除所有非字母数字的字符,则需要用到正则 // 进阶版: isPalindromes(&apos;abc_ &amp;b #@a&apos;) var isPalindromes = function(params){ // 传入参数先转为字符串且全部转为小写,最后去除多余字符比较 params = params.toString().toLowerCase().replace(/[\\W_\\s]/g,&apos;&apos;); console.log(params) return params === params.split(&apos;&apos;).reverse().join(&apos;&apos;); } // 进阶版同字母异序: isAnagram(&apos;ab *&amp;cef#d&apos;,&apos;!d@ce^abf&apos;) var isAnagram = function(str1, str2) { str1 = str1.toString().toLowerCase().replace(/[\\W_\\s]/g,&apos;&apos;); str2 = str2.toString().toLowerCase().replace(/[\\W_\\s]/g,&apos;&apos;); return str1.split(&apos;&apos;).sort().join(&apos;&apos;) === str2.split(&apos;&apos;).sort().join(&apos;&apos;) } 复制代码 Q: JS 实现String.trim()方法;// 原生是有 trim()方法的.我们要模拟一个; String.prototype.emuTrim = function(){ // 这条正则很好理解,就是把头部尾部多余的空格字符去除 return this.replace(/(^\\s*)|(\\s*$)/g,&apos;&apos;); } &apos; fsaf fsdaf f safl lllll &apos;.emuTrim(); //&quot;fsaf fsdaf f safl lllll&quot; 复制代码 Q: JS 实现函数运行一秒后打印输出0-9;给定如下代码for(var i=0;i&lt;10;i++){ // TODO } 复制代码 解法 // 这道题涉及到作用域 for(var i=0;i&lt;10;i++){ setTimeout((function(i){ return function(){ console.log(i); } })(i),1000); } 复制代码 若是用到 ES6…那简直不能再简便了 for(let i=0;i&lt;10;i++){ setTimeout(function(){ console.log(i); },1000); } 复制代码 Q: 实现对一个数组或者对象的浅拷贝和”深度”拷贝浅拷贝就是把属于源对象的值都复制一遍到新的对象,不会开辟两者独立的内存区域; 深度拷贝则是完完全全两个独立的内存区域,互不干扰 浅拷贝 // 这个 ES5的 function shallowClone(sourceObj) { // 先判断传入的是否为对象类型 if (!sourceObj || typeof sourceObj !== &apos;object&apos;) { console.log(&apos;您传入的不是对象!!&apos;) } // 判断传入的 Obj是类型,然后给予对应的赋值 var targetObj = sourceObj.constructor === Array ? [] : {}; // 遍历所有 key for (var keys in sourceObj) { // 判断所有属于自身原型链上的 key,而非继承(上游 )那些 if (sourceObj.hasOwnProperty(keys)) { // 一一复制过来 targetObj[keys] = sourceObj[keys]; } } return targetObj; } // ES6 可以用 Object.assign(targeObj, source1,source2,source3) 来实现对象浅拷贝 复制代码 深度拷贝 // 就是把需要赋值的类型转为基本类型(字符串这些)而非引用类型来实现 // JOSN对象中的stringify可以把一个js对象序列化为一个JSON字符串，parse可以把JSON字符串反序列化为一个js对象 var deepClone = function(sourceObj) { if (!sourceObj || typeof sourceObj !== &apos;object&apos;) { console.log(&apos;您传入的不是对象!!&apos;); return; } // 转-&gt;解析-&gt;返回一步到位 return window.JSON ? JSON.parse(JSON.stringify(sourceObj)) : console.log(&apos;您的浏览器不支持 JSON API&apos;); }; 复制代码 深拷贝的考虑点实际上要复杂的多,详情看看知乎怎么说 Q: this对象的理解简言之:谁调用指向谁,运行时的上下文确定,而非定义的时候就确定; 强行绑定 this的话,可以用 call,apply,bind,箭头函数….来修改this的指向 这类的文章太多,自行搜索吧…. Q: 看到你说到 bind,能用 JS简单的模拟个么? Function.prototype.emulateBind = function (context) { var self = this; return function () { return self.apply(context); } } 复制代码 这个实现很粗糙…更为详细全面,考虑周全的(比如参数的处理什么的)…自行谷歌. Q:JS 的作用域是什么?有什么特别之处么?作用域就是有它自身的上下文区域(比如函数内),内部会有变量声明提升,函数声明提升这些; 函数声明提升优于变量声明提升.. 作用域有全局作用域和块级作用域(局部,比如用 let 或者单纯花括号的); 作用域会影响this的指向 坐等补充,我回答的时候,面试大佬只是 嗯..恩…恩…也不知道具体如何 Q: 怎么解决跨域问题,有哪些方法…我一般用这三种,cors,nginx反向代理,jsonp jsonp : 单纯的 get 一些数据,局限性很大…就是利用script标签的src属性来实现跨域。 nginx 反向代理: 主要就是用了nginx.conf内的proxy_pass http://xxx.xxx.xxx,会把所有请求代理到那个域名,有利也有弊吧.. cors的话,可控性较强,需要前后端都设置,兼容性 IE10+ ,比如 Access-Control-Allow-Origin: http://foo.example // 子域乃至整个域名或所有域名是否允许访问 Access-Control-Allow-Methods: POST, GET, OPTIONS // 允许那些行为方法 Access-Control-Allow-Headers: X-PINGOTHER, Content-Type // 允许的头部字段 Access-Control-Max-Age: 86400 // 有效期 Q: 对于想携带一些鉴权信息跨域如何走起?比如cookie! 需要配置下 header Access-Control-Allow-Credentials:true ,具体用法看下面的nginxdemo 当然cros的配置不仅仅这些,还有其他一些,具体引擎吧…. 若是我们要用 nginx或者 express 配置cors应该怎么搞起? 来个简易版本的 nginx location / { 检查域名后缀add_header Access-Control-Allow-Origin xx.xx.com; add_header Access-Control-Allow-Methods GET,POST,OPTIONS; add_header Access-Control-Allow-Credentials true; add_header Access-Control-Allow-Headers DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type; add_header Access-Control-Max-Age 86400; } 复制代码 express, 当然这货也有一些别人封装好的 cors中间件,操作性更强… let express = require(‘express’);let app = express(); //设置所有请求的头部app.all(‘*’, (req, res, next) =&gt; { res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;xx.xx.com&quot;); res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&quot;); res.header(&quot;Access-Control-Allow-Credentials&quot;,&quot;true&quot;) res.header(&quot;Access-Control-Allow-Methods&quot;,&quot;PUT,POST,GET,DELETE,OPTIONS&quot;); next(); }); 复制代码 有些还会跟你死磕,,除了这些还有其他姿势么…我说了一个HTML5的postMessage…. ..因为真心没用过,只是以前查阅的时候了解了下..只能大体点下 这货用于iframe 传递消息居多, 大体有这么两步步 window打开一个实例,传递一个消息到一个x域名 x 域名下监听message事件,获取传递的消息 这货的兼容性没那么好,而且没考虑周全下容易遭受 CSRF 攻击 Q: 对于XSS 和 CSRF 如何防范这里就不说概念性的东西了 XSS的防范 我能想到的就是转义&lt;&gt;这些造成代码直接运行的的标签..轮询或者正则替换 而面试官说这种的效率最低下,我回来仔细找了找相关资料好像没有更优方案…有的留言… 若是有用到 cookie,设置为http-only,避免客户端的篡改 CSRF的防范一般这几种 验证码,用户体验虽然不好,,但是很多场合下可以防范大多数攻击 验证 HTTP Referer 字段,判断请求来源 token加密解密,这种是目前很常用的手段了… 任何防范都有代价的,比如验证码造成的体验不好,token滥用造成的性能问题,轮询替换造成的响应时间等 Q: 描述下cookie,sessionStorage,localStorage的差异.. cookie : 大小4KB 左右,跟随请求(请求头),会占用带宽资源,但是若是用来判断用户是否在线这些挺方便 sessionStorage和localStorage大同小异,大小看浏览器支持,一般为5MB,数据只保留在本地,不参与服务端交互. sessionStorage的生存周期只限于会话中,关闭了储存的数据就没了. localStorage则保留在本地,没有人为清除会一直保留 Q: javascript的原型链你怎么理解?原型链算是 JS 内一种独有的机制, 所有对象都有一个内置[[proto]]指向创建它的原型对象(prototype) 原型链的基本用来实现继承用的 Q: javascript里面的继承怎么实现，如何避免原型链上面的对象共享我在写的时候,用了两种,一个是 ES5和 ES6的方案 ES5:寄生组合式继承:通过借用构造函数来继承属性和原型链来实现子继承父。 function ParentClass(name) { this.name = name; } ParentClass.prototype.sayHello = function () { console.log(&quot;I&apos;m parent!&quot; + this.name); } function SubClass(name, age) { //若是要多个参数可以用apply 结合 ...解构 ParentClass.call(this, name); this.age = age; } SubClass.prototype = Object.create(ParentClass.prototype); SubClass.prototype.constructor = SubClass; SubClass.prototype.sayChildHello = function (name) { console.log(&quot;I&apos;m child &quot; + this.name) } let testA = new SubClass(&apos;CRPER&apos;) // Object.create()的polyfill /* function pureObject(o){ //定义了一个临时构造函数 function F() {} //将这个临时构造函数的原型指向了传入进来的对象。 F.prototype = obj; //返回这个构造函数的一个实例。该实例拥有obj的所有属性和方法。 //因为该实例的原型是obj对象。 return new F(); } */ 复制代码 ES6: 其实就是ES5的语法糖,不过可读性很强.. class ParentClass { constructor(name) { this.name = name; } sayHello() { console.log(&quot;I&apos;m parent!&quot; + this.name); } } class SubClass extends ParentClass { constructor(name) { super(name); } sayChildHello() { console.log(&quot;I&apos;m child &quot; + this.name) } // 重新声明父类同名方法会覆写,ES5的话就是直接操作自己的原型链上 sayHello(){ console.log(&quot;override parent method !,I&apos;m sayHello Method&quot;) } } let testA = new SubClass(&apos;CRPER&apos;) 复制代码 Q: ES6+你熟悉么,用过哪些特性? 箭头函数 类及引入导出和继承( class/import/export/extends) 字符串模板 Promise let,const async/await 默认参数/参数或变量解构装饰器 Array.inclueds/String.padStart|String.padEnd/Object.assign Q: let 和 const 有啥差异? let 会产生块级作用域,不会造成变量提升,无法重新声明(但可以重新赋值); const 是常量,若是基本数据类型,具有不变性(无法重新赋值改动) 引用值可以调整内部值(可能设计的时候没有考虑周全! Q: async和await的用途? 让 promise 的异步变成同步运行成了可能,await 可以等到 promise 执行完毕 Q: 箭头函数的this指向谁?肯定很多小伙伴会说指向局部方法内!!答案是错误的… 箭头函数所改变的并非把 this 局部化，而是完全不把 this 绑定到里面去; 就是 this 是取自外部的上下级作用域(但是又不是常规 function的语法糖).. 因为箭头函数里并不支持 var self = this 或者 .bind(this) 这样的写法。 Q: 问的时候你用过静态方法,静态属性,私有变量么?静态方法是ES6之后才有这么个玩意,有这么些特点 方法不能给 this引用,可以给类直接引用 静态不可以给实例调用,比如 let a = new ParentClass =&gt; a.sayHello() 会抛出异常 父类静态方法,子类非static方法没法覆盖父类 静态方法可以给子类继承 静态属性可以继承也可以被修改 看下面的代码.. class ParentClass { constructor(name) { this.name = name; } static sayHello() { console.log(&quot;I&apos;m parent!&quot; + this.name); } static testFunc(){ console.log(&apos;emm...Parent test static Func&apos;) } } class SubClass extends ParentClass { constructor(name) { super(name); } sayChildHello() { console.log(&quot;I&apos;m child &quot; + this.name) } static sayHello() { console.log(&quot;override parent method !,I&apos;m sayHello Method&quot;) } static testFunc2() { console.log(super.testFunc() + &apos;fsdafasdf&apos;); } } ParentClass.sayHello(); // success print let a = new ParentClass(&apos;test&apos;); a.sayHello() // throw error SubClass.sayHello(); // 同名 static 可以继承且覆盖 SubClass.testFunc2(); // 可以继承 let testA = new SubClass(&apos;CRPER&apos;); 复制代码 私有变量这个我没答出来,只是说了下没有private这个关键字和基本用下划线的人为区分 所以回来只是找了下相关的资料,发现有一个比较好的模拟方案,就是WeakMap; WeakMap可以避免内存泄露,当没有被值引用的时候会自动给内存寄存器回收了. const _ = new WeakMap(); // 实例化,value 必须为对象,有 delete,get,has,set四个方法,看名字都知道了 class TestWeakMap { constructor(id, barcode) { _.set(this, { id,barcode }); } testFunc() { let { id,barcode } = _.get(this); // 获取对应的值 return { id,barcode }; } } 复制代码 当然你也可以用Symbol来实现一个私有变量,这也是一个好法子 Q: 谈谈你对 Promise 的理解? 和 ajax 有关系么?Promise和ajax没有半毛钱直接关系.promise只是为了解决”回调地狱”而诞生的; 平时结合 ajax是为了更好的梳理和控制流程…这里我们简单梳理下.. Promise有三种状态,Pending/resolve()/reject(); 一些需要注意的小点,如下 在 Pending 转为另外两种之一的状态时候,状态不可在改变.. Promise的 then为异步.而(new Promise())构造函数内为同步 Promise的catch不能捕获任意情况的错误(比如 then 里面的setTimout内手动抛出一个Error) Promise的then返回Promise.reject()会中断链式调用 Promise的 resolve若是传入值而非函数,会发生值穿透的现象 Promise的catch还是then,return的都是一个新的 Promise(在 Promise 没有被中断的情况下) Promise 还有一些自带的方法,比如race,all,前者有任一一个解析完毕就返回,后者所有解析完毕返回… 实现一个延时的 promise 函数, 可以用async和await const delay = (time)=&gt; new Promise((resolve,reject)=&gt;{ setTimeout(resolve,time) }) // test let testRun = async function(){ console.log(1); await delay(2000); console.log(&apos;我两秒后才触发&apos;,3) } // 1 =&gt; Promise = &gt; 3 复制代码 这段代码的运行结果是什么? var test = new Promise((resolve,reject)=&gt;{ resolve(); }); test .then(data =&gt; { // promise start console.log(&apos;promise first then : &apos;, data); return Promise.resolve(1); // p1 }) .then(data =&gt; { // promise p1 console.log(&apos;get parent(p1) resolve data : &apos;, data); return Promise.reject(new Error(&apos;哎呀,中断了,你能奈我何!&apos;)); // p2 }) .then(data =&gt; { // promise p2 console.log(&apos;result of p2: &apos;, data); return Promise.resolve(3); // p3 }) .catch(err =&gt; { console.log(&apos;err: &apos;, err); return false; }); // promise first then : undefined // get parent(p1) resolve data : 1 // err: Error: 哎呀,中断了,你能奈我何! // 这里在 then 返回 Promise.reject()的时候已经中断了链式调用.直接给 catch捕获到 复制代码 别急,假如你不管有没有捕获到错误,最后再执行一个回调函数如何实现? 这里说的就是类似try..catch..finally,给Promise实现一个 finally; // finally比较好加，按照现在社区的讨论，finally的特点如下： // url : https://www.v2ex.com/t/205715 //1. 不接收任何参数，原来的value或者Error在finally里是收不到的 //2. 处理后不影响原Promise的状态，该reject还是reject，该resolve还是resolve //3. 不影响Promise向后传递的传，resolve状态还是传递原来的value，reject状态还是传递原来的Error Promise.prototype.finally = function (callback) { let P = this.constructor; // 这里拿到的是 Promise 的构造函数 //不管前面的 Promise 是fulfilled还是rejected，都会执行回调函数callback。 return this.then( value =&gt; P.resolve(callback()).then(() =&gt; value), reason =&gt; P.resolve(callback()).then(() =&gt; { throw reason }) ); }; // 用法很简单,就是可以传入一个回调函数.. // https://developers.google.com/web/updates/2017/10/promise-finally // 这个 url 中说了 node 及 chrome 的哪些版本已经实现了 finally 及用法 // ES 2018已经把 finally 追加到 promise 的原型链中.. 复制代码 &lt;&gt;: 有助于你更加深刻的了解 promise 的运行情况 关于 Promise 的 9 个提示 更多的Promise 详情可以参考&lt;&gt;; Q: 谈谈你对 TCP 的理解; Q: TCP 是在哪个OSI 的哪个层!通讯过程是全双工还是半双工(单工)? A: 传输层,全双工 Q: TCP的通讯的过程是怎么样的! A: 整个过程是三次握手,四次挥手.. Q: 你说的没错,说说整个过程如何? A: 举个栗子,我把 TCP 比做两个人用对讲机沟通(大白话)..三次握手就是.A1(吼叫方,客户端)想要呼叫 A2(控制室的某某,服务端).. A1对着对讲机说”over over ,听到请回答”(第一次,请求应答) … A2收到回应”收到收到,你说”(第二次,确认应答) A1开始巴拉巴拉个不停而 A2没拒绝(第三次,通讯建立) 而四次挥手则是两者确认互相倾述完毕的过程.. A1说:”控制室,报告完毕了”(第一次挥手) A2说:”知道了…那么你废话说完就好好听我指挥….巴拉巴拉..”(第二次挥手) A1此时等待控制室说完毕,而控制室等回应(第三次挥手) 等到 A1回馈控制室确认都知道完毕了..(第四次挥手)… 以上都是瞎掰,可能有些地方描述不当,笑笑就好了 TCP没有百分百建立成功的,会造成链接失败的情况有很多.. 比如长时间没应答(A1吼了半天没有反应或者 A2应答了而 A1不再鸟它)..亦或者丢包(对讲机也没了); TCP 协议相关的文章网上很多,若是要更加全面的了解该协议请自行引擎.. 我建议阅读&lt;&lt;TCP-IP详解卷1~卷3&gt;&gt;,这个是网络圣经…很厚…我只看了一丢丢.. Q: TCP 你了解了,那么 OSI 七层协议和五层网络架构应该知道吧?对于这类的问题我也只能大体点了下,毕竟不是专攻网络这块的… OSI 七层涵盖:物理层,数据链路层,网络层,传输层,会话层,表示层,应用层; 五层模型就是”会话,表示,应用层”同为一层; Q: DNS 的大体的执行流程了解么,属于哪个层级?工作在哪个层级? DNS 属于应用层协议, 至于TCP/UDP哪一层上面跑,看情况 , 大体的执行流程是这样的; DNS 默认端口是53,走 UDP 优先读取浏览器缓存 其次系统的缓存 都没有的情况下,找本地hosts文件(比如你写了映射关系优先寻找) 再没有的情况找最近的域名解析服务器 再没有则扩大访问,最终找到根服务器,还是没有就失败了.. DNS 的解析的几个记录类型需要了解: A: 域名直接到 IP CNAME: 可以多个域名映射到一个主机,类似在 Github Page就用 CNAME 指向 MX: 邮件交换记录,用的不多,一般搭建邮件服务器才会用到 NS: 解析服务记录,可以设置权重,指定谁解析 TTL: 就是生存时间(也叫缓存时间),一般的域名解析商都有默认值,也可以人为设置 TXT: 一般指某个主机名或域名的说明 回来我找下相关的资料,有兴趣的可以深入了解下,传送门如下: 梳理Linux下OSI七层网络与TCP/IP五层网络架构 TCP/IP（六）应用层（DNS和HTTP协议） DNS域名解析解剖 Q: HTTP 和 HTTPS 有何差异? 听说过 SPDY 么?我只是粗浅的回答了下… HTTP相对于 HTTPS来说,速度较快且开销较小(没有 SSL/TSL) 对接,默认是80端口; HTTP容易遭受域名劫持,而HTTPS相对来说就较为安全但开销较大(数据以加密的形式传递),默认端口为443.. HTTP是明文跑在 TCP 上.而HTTPS跑在SSL/TLS应用层之下,TCP上的 Q: 那么 HTTPS中的TLS/SSL是如何保护数据的… 一般有两种形式,非对称加密,生成公钥和私钥,私钥丢服务器,公钥每次请求去比对验证; 更严谨的采用 CA(Certificate Authority),给密钥签名…. Q: 你说到对称加密和非对称加密,能说说整个流程如何运转的么(HTTPS) 对称加密: 双方都有同样的密钥,每次通讯都要生成一个唯一密钥,速度很快 安全性较低且密钥增长的数量极快 非对称加密(一般用 RSA) 安全性很高,对资源消耗很大(CPU),目前主流的加密算法(基本用于交换密钥或签名,而非所有通讯内容) CA(数字签名): 这个是为了防止中间人给偷换了造成数据被窃取而诞生的 用一些权威机构颁布的算法来签名,权威机构做中间人,通讯过程都会跟机构核对一遍 懂得真心不多,回来找了下相关资料,有兴趣可以点击看看; 深入揭秘HTTPS安全问题&amp;连接建立全过程 深入理解 https 通信加密过程:口语化 “ : 看了上面那篇文章来看下面,会清晰很多 Q: SPDY 听说过么.什么来的? 谷歌推行一种协议(HTTP 之下SSL之上[TCP]),可以算是HTTP2的前身,有这么些优点 压缩数据(HEADER) 多路复用 优先级(可以给请求设置优先级) 而这些优点基本 HTTP2也继承下来了.. Q: 你对 HTTP 的状态吗了解多少… 这里列举一丢丢常见的.. 1XX: 一般用来判断协议更换或者确认服务端收到请求这些 100: 服务端收到部分请求,若是没有拒绝的情况下可以继续传递后续内容 101: 客户端请求变换协议,服务端收到确认 2xx: 请求成功,是否创建链接,请求是否接受,是否有内容这些 200: (成功)服务器已成功处理了请求。 201: (已创建)请求成功并且服务器创建了新的资源。 202: (已接受)服务器已接受请求，但尚未处理。 204: (无内容)服务器成功处理了请求，但没有返回任何内容。 3XX: 一般用来判断重定向和缓存 301: 所有请求已经转移到新的 url(永久重定向),会被缓存 302: 临时重定向,不会被缓存 304: 本地资源暂未改动,优先使用本地的(根据If-Modified-Since or If-Match去比对服务器的资源,缓存) 4XX: 一般用来确认授权信息,请求是否出错,页面是否丢失 400: 请求出错 401: 未授权,不能读取某些资源 403: 阻止访问,一般也是权限问题 404: 页面丢失,资源没找到 408: 请求超时 415: 媒介类型不被支持，服务器不会接受请求。 5XX: 基本都是服务端的错误 500: 服务端错误 502: 网关错误 504: 网关超时 Q: HTTP的请求报文是怎么样的,能大体的说下么? HTTP 的请求报文 = 请求行 + 请求头 + 请求体; 请求行: 这个好理解就是访问的方法+ 协议+ 访问的 URL 构成 请求头: 这个也好理解,比如 accept,content-type,user-agent这类值键对,服务端可以直接读取的 请求体: 比如 POST 提交的一个表单,我们编码后放在上面需要传递的 想深入了解的具体引擎搜索 Q: 请求报文知道,那你说说cookie是如何跟随请求的? Cookie 就是保存在 HTTP 协议的请求或者应答头部(Cookie 是由服务端生成),这样一路漂泊… Q: Cookie 隔离是什么,如何做; cookie 隔离就是降低 header 的数据包含,以达到加快访问速度的目的 方案: 静态资源丢 CDN或者非主域来加载 Q: 浏览器缓存和服务端的缓存控制你了解多少,说说看? Last-Modified: 第一次请求资源从服务器拉取的会自动带上该属性 第二次请求会跟服务端比对If-Modified-Since的时间,没变动则使用本地的(状态304) 结合Expires(过期时间:缓存的载止时间),跟随请求一起发出..资源没过期拿本地,否则重新请求 Cache-control 是 HTTP1.1的东西,判断资源过期结合max-age来替代Expires[http 1.0] Etag: 第一次请求url 时候会给服务器上标记(一串字符串) 第二次请求时候会比对服务端的If-None-Match,没有改动依旧拿缓存(304) Q: 几个短而让我印象深刻的题if(!(&quot;a&quot; in window)){ var a = 10; } console.log(a); // undefined // !(&quot;a&quot; i n window) , 返回 true // 留言小伙伴的刨析,非常感谢,还是涉及变量提升的问题 /* var a; if(!(&quot;a&quot; in window)){ a = 10; } */ // 变种题 (function(){ var x = c = b = {a:1} })() console.log(x.a); // error , x is not defined console.log(c,b) // {a: 1} {a: 1} 复制代码 var count = 0; console.log(typeof count === &quot;number&quot;); // true , 这个不用解释了 console.log(!!typeof count === &quot;number&quot;); // false // 这里涉及到就是优先级和布尔值的问题 // typeof count 就是字符串&quot;number&quot; // !!是转为布尔值(三目运算符的变种),非空字符串布尔值为 true // 最后才=== 比较 , true === &quot;number&quot; , return false 复制代码 (function(){ var a = b = 3; })() console.log(typeof a === &quot;undefined&quot;); // false console.log(typeof b === &quot;undefined&quot;); // false // 这里涉及的就是立即执行和闭包的问题,还有变量提升,运算符执行方向(=号自左向右) // 那个函数可以拆成这样 (function() var a; /* 局部变量,外部没法访问*/ b = 3; /* 全局变量,so . window.b === 3 , 外部可以访问到*/ a = b; })() // 若是改成这样,这道题应该是对的 console.log(typeof b === &quot;number&quot; &amp;&amp; b ===3 ); // true 复制代码 function foo(something){ this.a = something; } var obj1 = { foo:foo }; var obj2 = {}; obj1.foo(2) console.log(obj1.a) // 2 ,此时的 this 上下文还在 obj1内,若是 obj1.foo 先保存当做引用再执行传参,则上下文为 window obj1.foo.call(obj2,3); // 用 call 强行改变上下文为 obj2内 console.log(obj2.a); // 3 var bar = new obj1.foo(4); // 这里产生了一个实例 console.log(obj1.a); // 2 console.log(bar.a); // 4; new的绑定比隐式和显式绑定优先级更高 复制代码 function fn(){ alert(a); var a = 200; alert(a); } fn(); // undefined / 200 ; 涉及变量提升 alert(a); // undefined var a; alert(a); // undefined var a = 300; alert(a); // 300 复制代码 var obj1= { name:&apos;obj1&apos;, fn:function(){ console.log(this.name); } }; var obj2 = {name:&apos;obj2&apos;}; var obj3 = {name:&apos;obj3&apos;}; // 这道题主要涉及的是 this 指向的问题.. obj1.fn(); // obj1 var newFn = obj1.fn; newFn(); // undefined, this 指向 window newFn.call(obj2);// obj2, this 指向 obj2 obj3.fn = newFn; /* ƒ (){ console.log(this.name); } */ obj3.fn(); // 这里指向的是 obj3 .所以输出 obj3 复制代码 // 这道题来作为笔试题很绕,因为要回答的答案很多(脑海构思)..反正我是遇到了.. // 这道题主要考核的是对原型链继承这块的理解 function Parent(){ this.a = 1; this.b = [1,2,this.a]; this.c = {demo:5}; this.show = function(){ console.log(this.a + &apos;&apos; + this.c.demo + &apos;:&apos; + this.b) } } function Child(){ this.a = 2; this.change = function(){ this.b.push(this.a); this.a = this.b.length; this.c.demo = this.a++; } } Child.prototype = new Parent(); var parent = new Parent(); var child1 = new Child(); var child2 = new Child(); child1.a = 11; child2.a = 12; // 这前面几个还算简单,继续看下去 parent.show(); // 15:1,2,1 // 因为 Child 自身没有 show 的方法,所以往原型链的上游找; // 找到父类的,this 因为没更改,所以输出结果如下 child1.show(); // 115:1,2,1 child2.show(); // 125:1,2,1 child1.change(); // 改变一些数据,没有输出 child2.change(); // +1 parent.show(); // 15:1,2,1 child1.show(); // 55:1,2,1,11,12 child2.show(); // 65:1,2,1,11,12 复制代码 // 这道题也很绕,函数递归调用的 function test(a,b){ console.log(b); return { test:function(c){ return test(c,a); } }; // 这道题的理解,拆成这样就好理解了 /*function test(a,b){ console.log(&quot;a:&quot;+a,&quot;b:&quot;+b); return { test:function(c){ console.log(&quot;a:&quot;+a,&quot;b:&quot;+b,&quot;c&quot;+c); return test(c,a); } } }*/ var a = test(100); // undefined, 这个是不言而喻的; a.test(200); // 100; a.test(300); // 100; var b = test(101).test(201).test(301); // undefined/101/201 var c = test(102).test(202); // undefined / 102 c.test(302); // 202 复制代码 Q:有字符串 var test=’abc345efgabcab’; 请根据提示实现对应要求 去掉字符串中的 a,b,c 字符 ,形成结果’345efg’; test.replace(/[abc]/g,&apos;&apos;); // &quot;345efg&quot; 复制代码 将字符串的数字用括号括起来, 形成结果: abc[3][4][5]efg….’ test.replace(/\\d/g,&apos;[$&amp;]&apos;); // &quot;abc[3][4][5]efgabcab&quot; // 若是有分组则按照$1, $2, $3的形式进行引用，而 $&amp; 则表示的是整个正则表达式匹配的内容。 复制代码 将字符串中的每个数字的值分别乘以2,输出:’abc6810….’ var temp = test.split(&apos;&apos;).map(function(item){ return /^\\d$/.test(item) ? item * 2 : item; }).join(&apos;&apos;); // &quot;abc6810efgabcab&quot; 复制代码 Q: 使用不少于三种方式替换文本&quot;dream&quot;改成&quot;package&quot;,提供字符串&quot;I have a dream&quot;; 正则替换 // 这是最简单的代码量了..var str = “I have a dream”;str.replace(/dream/g,”package”); // 不用正则也可以直接字符串替换str.replace(“dream”,”package”) 复制代码 数组遍历更改 // 很直白的大脑回路var str = “I have a dream”; str.split(“ “).map(function(item){ return item === “dream” ? item = “package”:item;}).join(“ “); 复制代码 数组查询切割法 var str = “I have a dream”; var tempArr = str.split(“ “); // [“I”, “have”, “a”, “dream”]var removeIndex = tempArr.indexOf(‘dream’); // 3 tempArr.splice(removeIndex,1,”package”); var transStr = tempArr.join(“ “); // “I have a package”; 复制代码 这类东东弄成数组还是挺好弄的 这个是留言区小伙伴提供的方法..大同小异,如下; // 源代码 // 字符串也有数组的 slice 以及 concat 的方法..思路和数组差不多 var str = &apos;I haved a dream&apos;; str.indexOf(&apos;dream&apos;) !== -1 ? str.slice(0,str.indexOf(&apos;dream&apos;)).concat(&apos;package&apos;):str; 复制代码 Q: 还有一道题目是涉及事件循环,执行优先权的..就是 macrotask和microtask 相关的, 具体记不起来了..那时候给了答案虽然对了. 要说出所以然,给秀了一脸..回来找了下相关的资料; JavaScript 运行机制详解：再谈Event Loop 深入理解事件循环和异步流程控制 所有你需要知道的关于完全理解 Node.js 事件循环及其度量 Q: 你对基础算法这块掌握的如何…. 来,这纸给你,写个快排试试… // 快排的大体思路是这样的, // 找个中位值,从原数组切割出来, // 剩下的作为两个数组,每次都去比较; // 直到递归的结果出来, 平均复杂度O(nlog n) function quickSort(arr) { //如果数组长度&lt;=1,则直接返回 if (arr.length &lt;= 1) { return arr; } // 中间位(基准)取长度的一半向下取整 var pivotIndex = Math.floor(arr.length / 2); //把中间位从原数组切割出来, splice 会改变原数组!!!! var pivot = arr.splice(pivotIndex, 1)[0]; //定义两个空数组来存放比对后的值 var left = []; var right = []; //比基准小的放在left，比基准大的放在right for (var i = 0 , j = arr.length; i &lt; j; i++) { if (arr[i] &lt;= pivot) { left.push(arr[i]); } else { right.push(arr[i]); } } //递归下去 arr = [ left , pivot , right] // 怎么个递归法,就是比对后的数组还是会重复之前的取基准再切开比较..直到最后没有可以切了 return quickSort(left).concat([pivot], quickSort(right)); } 复制代码 Q: 写一个二分法查找 // 二分法跟快排的思路差不多,对半比较 // 这个只用于排序好数组内的查询,高低位都知道的情况下 function binSearch(target, arr, start, end) { var start = start || 0; // 允许从什么位置开始,下标 var end = end || arr.length - 1; // 什么位置结束,下标 start &gt;= end ? -1 : &apos;&apos;; // 没有找到,直接返回-1 var mid = Math.floor((start + end) / 2); // 中位下标 if (target == arr[mid]) { return mid; // 找到直接返回下标 } else if (target &gt; arr[mid]) { //目标值若是大于中位值,则下标往前走一位 return binSearch(target, arr, start, mid - 1); } else { //若是目标值小于中位值,则下标往后退一位 return binSearch(target, arr, mid + 1, end); } } // binSearch(5,[1,2,3,4,5,6,7,8]) =&gt; 4 // 无序的数组则需要先排序好数组,否则会堆栈溢出(死循环) 复制代码 这类的文章很多,有兴趣的可以阅读下面的一些文章 传送门: &lt;&lt;十大经典排序算法总结（JavaScript描述&gt;&gt; JavaScript数据结构和算法 javascript 常见排序算法 Q: 设计模式你了解多少? Javascript常用的设计模式详解 js-design-pattern Q: 思维拓展题: 你有两个玻璃球,有个100米的高楼,求玻璃球在哪个楼层扔下会碎(用的次数最少);问题的要点: 玻璃球碎(有限个数) ,确定楼层数 , 最少次数 => 就是求最优的公式 在这道题上给秀的一脸,我的第一次的思路 先折半,就变成[1-50][51-100], 那就是 1+50 = 51次 … 面试大佬说,你用了快排的思路就肯定不是最优的.. 憋了许久,想到开平方 , 这样的话,最多只要20次 然后又说给我三个球,在1000米的高楼,判断多少次…但是根据我上面的话, 开立方, , 那最多不超过30次; 至于第一次丢球的位置如何确定, 就是开平之后的值作为一个区间. 若 N 个球和 M 米的大厦…第一次丢球的高度区间就是这个了 面试大佬说这个还可以…那就暂且告一段落 …回来用万能的搜索引擎找了下..最优方案+最少次数需要考虑的东西很多,没那么简单 传送门: 知乎有人讨论了这个问题; 但是高数还老师了..这种帖子看的一脸懵逼….抽空再好好研究下 Q: 你对优化这块了解多少?大体常见的手段了解. 比如从客户端着手的: 压缩代码(JS/CSS),压缩图片 合并一些小图片(css sprite) 若是打包的代码尽可能切割成多个 chunk,减少单一 chunk过大 静态文件采用 cdn 引入 HTTP的缓存头使用的合理 减小第三方库的依赖 对于代码应该考虑性能来编写,比如使用requestAnimationFrame绘制动画,尽可能减少页面重绘(DOM 改变) 渐进升级,引入preload这些预加载资源 看情况用service worker来缓存资源(比如移动端打算搞 PWA) 比如从服务端着手: 带宽,域名解析, 多域名解析等 页面做服务端渲染,减小对浏览器的依赖(不用客户端解析) 渐进升级,比如引入 HTTP2(多路复用,头部压缩这些可以明显加快加载速度) 当然,这是这些都是很片面的点到…实际工作中去开展要复杂的多; 比如我们要多个维度去考虑的话,要去优化 DOM 的绘制时间,资源的加载时间,域名解析这些; 要全面的优化一个项目是一个大工程… Q: MySQL有哪些索引类型? 索引的数据结构储存方式? MySQL和 MongoDB的差异MySQL索引类型: 普通索引: 就普通的类型 唯一索引: 代表索引的值唯一不重复(允许有空值),相对于上面多了个UNIQUE 主键索引:(创建表的跟随创建,唯一索引，不允许有空值) 组合索引(就是将多个字段都建立到一个索引) 索引有利有弊,用的好加快查询速度,滥用索引会造成大量磁盘空间占用,维护性也会增多; 索引不会包含null的列; 索引的数据结构储存方式,我只简单了解过B-Tree 至于MySQL 和 MongoDB的差异; 前者是关系型数据库, 后者非关系型数据库(数据是以文档的方式储存,值为 key-value); MySQL应用层面很广,有事务系统这些,链表查询这些都很方便.经常作为很多系统的主力数据库 而MongoDB作为NoSQL,虽然有些层面不如 MySQL,但是应用层面也挺广, 比如结合前端做一些用户的概要信息的维护,一些缓存信息的维护. em….后端了解不多,也能点到即止….大学的时候学过一些..都差不多还给老师…. Q: JS时间分段 给定一个时间段和步长，枚举该时间段内步长的划分 例如：时间段3:00-5:00，步长为20分钟 那么返回的数组为 [&#39;3:00-3:20&#39;, &#39;3:20-3:40&#39;....]等 这类问题,一般都要先梳理好思路再来写; 给定字符串时间段,切割,转换为分钟 跨日及跨时问题 // 这个东东我的小伙伴也写出来了.我的是在它的解答方式上加以注释和对参数的判断做了考虑 // 他的解法方案在他的 github 上 https://github.com/lyh2668/blog/issues/1 , by lyh2668 // 方便一些小伙伴的理解,以下代码包含ES6的姿势(参数默认值,剪头函数) let inputDateRange = (date, step = 30, separator = &apos;-&apos;) =&gt; { let startTime, endTime; // 开始时间和结束时间 if (Object.prototype.toString.call(date) === &apos;[object String]&apos;) { date = date.trim(); // 去除两边的空格 var tempDate = &apos;&apos;; if (separator) { tempDate = date.split(separator); } else { if (date.indexOf(&apos;-&apos;) !== -1) { tempDate = date.split(&apos;-&apos;); } else if (date.indexOf(&apos;~&apos;)) { tempDate = date.split(&apos;~&apos;); } else { console.log(&apos;您传入的也许不是一个时间段!!!&apos;); } } startTime = time2min(tempDate[0]); // 传入的开始时间 endTime = time2min(tempDate[1]); //传入的结束时间 } else if (Object.prototype.toString.call(date) === &apos;[object Array]&apos;) { if (date.length === 2) { startTime = time2min(date[0]); // 传入的开始时间 endTime = time2min(date[1]); //传入的结束时间 } } else { console.log(&apos;您传入的也许不是一个时间段!!!&apos;); } // 传入的 step 是否为数字,否则截图数字部分转化 // 为什么和 NaN 比较(自身不等性),若是传入的连正则都没法识别,那只能给默认值了 Object.prototype.toString.call(step) === &apos;[object Number]&apos; ? (step = parseInt(step, 10)) : parseInt(step.replace(/[W\\s\\b]/g, &apos;&apos;), 10) === NaN ? (step = parseInt(step.replace(/[W\\s\\b]/g, &apos;&apos;), 10)) : (step = 30); // 若是开始时间大于结束时间则结束时间往后追加一天 startTime &gt; endTime ? (endTime += 24 * 60) : &apos;&apos;; let transformDate = []; // 储存转换后的数组,时间分段 // 开始遍历判断,用 while while (startTime &lt; endTime) { // 如果开始时间+步长大于结束时间,则这个分段结束,否则结束时间是步长递增 let right = startTime + step &gt; endTime ? endTime : startTime + step; transformDate.push(`${min2time(startTime)}-${min2time(right)}`); startTime += step; // 步长递增 } return transformDate; }; // 时间转化为分钟 let time2min = time =&gt; { // 获取切割的 time.indexOf(&apos;:&apos;) ? (time = time.trim().split(&apos;:&apos;)) : &apos;&apos;; return time[0] * 60 + parseInt(time[1]); // 返回转化的分钟 }; // 分钟转会字符串时间 let min2time = minutes =&gt; { let hour = parseInt(minutes / 60); // 返回多少小时 let minute = minutes - hour * 60; // 扣除小时后剩余的分钟数 hour &gt;= 24 ? (hour = hour - 24) : &apos;&apos;; // 若是大于等于24小时需要扣除一天得到所剩下的小时 minute &lt; 10 ? (minute = &apos;0&apos; + minute) : &apos;&apos;; // 小于10的都要补零 hour &lt; 10 ? (hour = &apos;0&apos; + hour) : &apos;&apos;; // 小于10的都要补零 return `${hour}:${minute}`; }; // test ,支持字符串传入时间段 inputDateRange(&apos;3:00-5:00&apos;,&apos;20d&apos;); // [&quot;03:00-03:20&quot;, &quot;03:20-03:40&quot;, &quot;03:40-04:00&quot;, &quot;04:00-04:20&quot;, &quot;04:20-04:40&quot;, &quot;04:40-05:00&quot;] // 亦或者数组传入 inputDateRange([&apos;3:00&apos;,&apos;5:00&apos;],&apos;45df.3d&apos;); // [&quot;03:00-03:45&quot;, &quot;03:45-04:30&quot;, &quot;04:30-05:00&quot;] // step 支持数字亦或者带特殊字符的数字 inputDateRange([&apos;6:00&apos;,&apos;8:00&apos;],&apos;55df.3d&apos;); // [&quot;06:00-06:55&quot;, &quot;06:55-07:50&quot;, &quot;07:50-08:00&quot;] inputDateRange(&apos;3:00-5:00&apos;,60); // [&quot;03:00-04:00&quot;, &quot;04:00-05:00&quot;] 复制代码 JS不靠谱系列之枚举出时间段和对应的分钟数 Q: Vue-Router的两种模式主要依赖什么实现的 hash主要依赖location.hash来改动 URL,达到不刷新跳转的效果.每次 hash 改变都会触发hashchange事件(来响应路由的变化,比如页面的更换) history主要利用了 HTML5的 historyAPI 来实现,用pushState和replaceState来操作浏览历史记录栈 Q: MVVM 和 MVC 的差异? 听说过 MVP?这类的文章好多,三个开发模式的诞生都有前后,不是同时出现的. 传送门: MVC，MVP 和 MVVM 的图示 浅析前端开发中的 MVC/MVP/MVVM 模式 Q: 求100~999的所有”水仙花”数, 就是三位数中各数字的立方和等于自身,比如153=1^3+5^3+3^3 常规遍历法 function threeWaterFlower(rangeStart, rangeEnd) { var temp = []; rangeStart = rangeStart || 100; rangeEnd = rangeEnd || 999; for (var i = rangeStart; i &lt;= rangeEnd; i++) { var t = i.toString().split(&apos;&apos;); Math.pow(t[0], 3) + Math.pow(t[1], 3) + Math.pow(t[2], 3) == i ? temp.push(i) : &apos;&apos;; } return temp;} threeWaterFlower(100,999); // [153, 370, 371, 407] threeWaterFlower(); // [153, 370, 371, 407] 复制代码 拓展写法,ES6版+不定花数,不折腾不舒服版本 let manyWaterFlower = (rangeStart = 100, rangeEnd = 999, flower = 3) =&gt; { let temp = []; for (let i = rangeStart; i &lt;= rangeEnd; i++) { let t = i .toString() .split(&apos;&apos;) .map(item =&gt; Math.pow(item, flower)) .reduce((cur,next)=&gt; parseInt(cur)+parseInt(next)); let transformT = parseInt(t, 10); transformT == i ? temp.push(i) : &apos;&apos;; } return temp; } manyWaterFlower(); // [153, 370, 371, 407] manyWaterFlower(100,10000,4); // [1634, 8208, 9474] manyWaterFlower(100,10000,5); // [4150, 4151] 复制代码 这种是穷举遍历,若是要快一点呢(考虑的周全一点呢),以及传参范围的矫正 相信小伙伴都看得懂,我已经尽量注释了.. let manyWaterFlower = (flower = 3,rangeStart, rangeEnd ) =&gt; { let temp = [];// 缓存所有找到的花值 // 这一段就是填充开始循环的范围,处理完毕后转为数字,推荐的开始值 let flowerRecommandStart = Number( &apos;&apos;.padStart(flower, &apos;0&apos;).replace(/^(\\d{1})/g, &apos;1&apos;) ); let flowerRecommandEnd = Number(&apos;&apos;.padStart(flower, &apos;9&apos;)); // 判断是否传入开始值 if (rangeStart) { rangeStart &gt; flowerRecommandStart ? (rangeStart = flowerRecommandStart) : rangeStart; } else { rangeStart = flowerRecommandStart; } // 判断是否有传入结束值 if (rangeEnd) { rangeEnd &gt; flowerRecommandEnd ? (rangeEnd = flowerRecommandEnd) : rangeEnd; } else { rangeEnd = flowerRecommandEnd; } // 若是初始值大于结束值 if (rangeStart &gt; rangeEnd) { rangeEnd = flowerRecommandEnd; } for (let i = rangeStart; i &lt;= rangeEnd; i++) { let t = i .toString() .split(&apos;&apos;) .map(item =&gt; Math.pow(item, flower)) .reduce((cur, next) =&gt; parseInt(cur) + parseInt(next)); let transformT = parseInt(t, 10); transformT == i ? temp.push(i) : &apos;&apos;; } return temp; }; console.time(&apos;manyWaterFlower&apos;); manyWaterFlower(4) console.timeEnd(&apos;manyWaterFlower&apos;); // VM34013:4 manyWaterFlower: 8.112060546875ms ,这个是跑出来的时间 用上个例子的代码,从100到9999的,我们跑一下看看 console.time(&apos;manyWaterFlower&apos;); manyWaterFlower(100,9999,4) console.timeEnd(&apos;manyWaterFlower&apos;); // VM3135:4 manyWaterFlower: 10.51904296875ms // 我的 MBP 跑10花直接卡死...跑7花有点久... console.time(&apos;7 flower&apos;) manyWaterFlower(7); console.timeEnd(&apos;7 flower&apos;) // 7 flower: 6489.608154296875ms // 8 花 CPU 的风扇狂叫.... console.time(&apos;8 flower&apos;) manyWaterFlower(8); console.timeEnd(&apos;8 flower&apos;) // VM644:3 8 flower: 68010.26489257812ms // 对了我们还没有考虑数值溢出的问题..因为正整数在 JS 的范围是有限的. // 有兴趣的小伙伴可以自行完善 复制代码 Q: 请使用递归算法在 TODO 注释后实现通过节点 key 数组寻找 json 对象中的对应值比如console.log(findNode([‘a1’, ‘b2’], data)) === data.a1.b2 // 请使用递归算法在 TODO 注释后实现通过节点 key 数组寻找 json 对象中的对应值 var data = { a1: { b1: 1, b2: 2, b3: { b4: 5 } }, a2: { b1: 3, b2: 4 } }; function findNode(inPath, inData) { // TODO // 判断传入的是否是一个数组 if (Array.isArray(inPath)) { // 当长度为1的时候寻找该 key 是否有值,有则返回,无则返回-1 if (inPath.length === 1) { return inData[inPath[0]] ? inData[inPath[0]]: -1; }else{ return findNode(inPath.slice(1), inData[inPath[0]]); } } else{ console.log(&apos;您传入的不是一个数组&apos;) } } console.log(findNode([&apos;a1&apos;, &apos;b2&apos;], data)); // 2 console.log(findNode([&apos;a1&apos;, &apos;b3&apos;,&apos;b4&apos;], data)); // 5 复制代码 来个拓展版?支持字符串或数组传入;findNode(&#39;a1.b2&#39;,data)? var data = { a1: { b1: 1, b2: 2, b3: { b4: 5 } }, a2: { b1: 3, b2: 4 } }; // 判断格式 function isType(params) { let type = Object.prototype.toString.call(params); if (type === &apos;[object String]&apos;) { params = params.split(&apos;.&apos;); return params; } if (type === &apos;[object Array]&apos;) { return params; } } function findNode(inPath, inData) { inPath = isType(inPath); // 判断传入的是否是一个数组 if (Array.isArray(inPath)) { // 当长度为1的时候寻找该 key 是否有值,有则返回,无则返回-1 if (inPath.length === 1) { return inData[inPath[0]] ? inData[inPath[0]]: -1; }else{ return findNode(inPath.slice(1), inData[inPath[0]]); } } else { console.log(&apos;您传入的不是一个数组&apos;); } } console.log(findNode([&apos;a1&apos;, &apos;b2&apos;], data)); // 2 console.log(findNode(&apos;a1.b3.b4&apos;, data)); // 5 复制代码 Q: webpack 是什么?webpack 常见的优化手段有哪些;webpack 是一个资源处理工具,它的出现节省了我们的人力和时间; 可以对资源打包,解析,区分开发模式等等… 常见的优化手段: 分离第三方库(依赖),比如引入dll 引入多进程编译,比如happypack 提取公共的依赖模块,比如commonChunkPlugin 资源混淆和压缩:比如UglifyJS 分离样式这些,减小bundle chunk的大小,比如ExtractTextPlugin GZIP 压缩,在打包的时候对资源对齐压缩,只要部署的服务器能解析即可..减少请求的大小 还有按需加载这些,一般主流的框架都有对应的模块懒加载方式. 至于tree shaking目前webpack3/4已经默认集成 Q: 从你输入一个 URL 到页面渲染的大体过程…大体过程是这样的,想了解很细致的可以自行引擎; IP-&gt;DNS(浏览器=&gt;系统缓存=&gt;DNS 服务器)-&gt;域名解析完成(这一步不用太多解析吧) TCP 协议走完-&gt;HTTP(S) 协议-&gt;缓存-&gt;(分析请求头)-&gt; 回馈报文 请求文档下来-&gt;DOM-&gt;CSSDOM-&gt;静态资源下载-&gt;render(绘制文档)-&gt;js 解析 用户看到页面 Q: Vue 的组件的通讯手段有哪些.. 父-> 子: props 子-> 父: on+emit 父&lt;&gt;子: on.sync(语法糖)来的 兄弟 : event bus | vuex Q: Vuex你怎么理解?vuex是一个状态管理容器(你也可以理解为全局变量),数据的流向是是单向数据流, 且数据并不具有持久化的特性(默认情况下刷新就重置所有状态); 里面的一些数据乃至方法,可以大致理解为 vue 的一些特性,比如 Vuex Vue state data getter computed mutation/actions methods 至于单向数据流(全局单例模式)怎么理解 state只能给mutation(同步操作) 改动, action只能反馈给mutation,可以进行异步操作(比如和后端交互拉取数据), state能触发 render,action能用dispatch分发..如图 结语还有一些题目记不起来了,就没辙了…还有一些题目是看你个人发挥的,没法写,比如 Q: 让你来为公司的一个项目做技术选型,你会怎么做,为什么? Q: React,Angular,Vue的比较? Q: 说说你对 VNode的理解,diff的过程; Q: Vue的双向绑定如何实现,用了什么模式(订阅模式),大体如何实现的.. Q: cmd/amd/commonjs的差异 Q: 小程序以及React Native的差异..等等 面试的过程中磕磕碰碰才能发现自身的很多不足和需要去努力的方向. 有不对之处请留言,会及时跟进修正,谢谢各位大佬","categories":[{"name":"后端","slug":"后端","permalink":"https://motainzhang.com/categories/后端/"}],"tags":[]},{"title":"当大多数人对Vue理解到炉火纯青的时候，是不是该思考一下怎么让vue页面骚气起来","slug":"vue","date":"2018-07-19T15:22:38.000Z","updated":"2019-10-18T03:34:00.262Z","comments":true,"path":"2018/07/19/vue/","link":"","permalink":"https://motainzhang.com/2018/07/19/vue/","excerpt":"","text":"当大多数人对Vue理解到炉火纯青的时候，是不是该思考一下怎么让vue页面骚气起来写在前面 小菜0、页面布局之五彩斑斓的类似标签栏先来个效果热热身 上菜： 场景需求：最近设计湿丢来这样的页面设计，要求响应式。正常老铁们看到类似标签栏的设计，作为前端要切出来估计头皮一发麻，基本上实现的话要么简单粗暴上背景图，要么几个div，作为对代码有的洁癖的我就直接上v-for表单渲染，把中间这块封装了一个公用的容器组件wapper，于是乎下面代码来了（完整代码，见本文后github链接） &lt;template&gt; &lt;div class=&quot;com-wapper&quot;&gt; &lt;div class=&quot;wapper&quot;&gt; &lt;div class=&quot;content-header&quot;&gt; &lt;div class=&quot;list&quot; v-for=&quot;(item,index) in colorList&quot; :style=&quot;{ background: item }&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;content&quot;&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: &apos;wapper&apos;, data(){ return{ colorList: [&apos;#ea4035&apos;,&apos;#fbac46&apos;,&apos;#2eb472&apos;,&apos;#f7ec31&apos;,&apos;#1b72b4&apos;,&apos;#90268b&apos;] } } } &lt;/script&gt;复制代码 原理：v-for去遍历数组，把颜色加在背景上，样式部分就不贴代码了，原理就是css3的计算属性calc分成6等分，然后各种阴影、圆角之类的一上效果杠杠的。 [题外话：至于性能方面没有做过多的思考，v-for表单渲染与其他实现方式的性能对比，这里也不做过多讲，这样看起来代码是优雅的] 小菜1、爱心点赞，七夕特别贡献点赞场景，七夕了给相爱的ta一个赞吧 上菜： 场景需求：七夕马上就要到了，开始估计又要虐狗了，根据喜欢程度可以进行多次点击，从因为人群中偶然的一个回眸，平常到like,到love,再到love+,在到平常（点击通过爱心颜色和文字提示表示亲密度），项目中也常常出现，比如评论点赞，图书推荐点赞等场景，这里我把爱心抽离出一个heart组件，上核心代码： &lt;template&gt; &lt;a href=&quot;javascript:void(0)&quot; @click=&quot;handleHeart()&quot; :class=&quot;{ &apos;like&apos; : heart.level === 1, &apos;love&apos; : heart.level === 2, &apos;stalker&apos; : heart.level === 3 }&quot; class=&quot;heart&quot;&gt; &lt;i&gt;♥&lt;/i&gt; &lt;/a&gt; &lt;/template&gt; 复制代码 methods: { handleHeart: function() { var heart = this.heart; var level = heart.level; switch (level) { case 0: heart.level = 1; break; case 1: heart.level = 2; break; case 2: heart.level = 3; break; case 3: heart.level = 0; break; } // this.updateDB(); //写入数据库操作 }, updateDB() { } }, created() { if (!this.existing) { this.heart.level = 0; } else { this.heart.level = this.existing; } } 复制代码 原理：点赞功能究竟是怎么实现的呢，其实我在前一篇文章《从青铜到王者10个css3伪类使用技巧和运用，了解一哈》已经提到了，其实就是用伪类实现鼠标经过提示，点击修改循环heart.level，切换class来修改提示（伪类透明度），和爱心颜色（完整代码，见本文后github链接） [题外话：以上数据都是mock模拟，其实请求的是github里面的数据，github提供的api可以看到很多数据，感兴趣的同学可以拿取githubapi里自己的数据做一个关于自己的’大数据分析页面’，很赞哦] 小菜2、让新闻选项卡动起来新闻选项卡，门户网站出现概率贼高，告别枯燥无味翻动新闻选项卡，鼠标经过动起来 上菜： 场景需求：选项卡标题鼠标经过，对应切换新闻内容列表。jq深度患者，通常看到类似滚动推动效果的效果，肯定在想操作DOM啊，so easy。还是那句话，代码强迫症，es6和vue相结合，让你尽可能告别DOM操作，下面贴上代码（完整代码，本文后github链接） &lt;div class=&quot;news-wrapper&quot; v-cloak&gt; &lt;ul class=&quot;news-list&quot;&gt; &lt;li v-for=&quot;(item,index) in list&quot; :class=&quot; {&apos;active&apos;:index===activeTab}&quot; @mouseenter=&quot;tebHover(index)&quot;&gt;&lt;a href=&quot;javascript://&quot;&gt;{{item.newstitle}}&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;news-box&quot;&gt; &lt;div class=&quot;news-listbox&quot; :style=&quot;{&apos;margin-left&apos;: marginleft+&apos;%&apos;}&quot;&gt; &lt;ul v-for=&quot;(item,index) in list&quot;&gt; &lt;li class=&quot;clearFix&quot; v-for=&quot;(news, index) in item.datalist&quot; v-if=&quot;index &lt; 6&quot;&gt; &lt;a&gt; &lt;div class=&quot;news-date&quot;&gt; &lt;div class=&quot;date-day&quot;&gt;{{news.date.split(\"-\")[2]}}&lt;/div&gt; &lt;div class=&quot;date-year&quot;&gt;{{news.date.split(\"-\")[0]}}-{{news.date.split(\"-\")[1]}}&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;main-news&quot;&gt; &lt;div class=&quot;newstxt-title&quot;&gt;{{news.title}}&lt;/div&gt; &lt;div class=&quot;news-text&quot;&gt; {{news.content}} &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;time&quot;&gt;{{news.date}}&lt;/div&gt; &lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;more&quot; v-if=&quot;item.datalist.length &gt;= 6&quot;&gt;&lt;a&gt;更多&gt;&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;复制代码 tebHover(index){ this.activeTab = index; //计算margin-left的百分比 this.marginleft = -1*(this.activeTab)*100 }复制代码 原理：让新闻内容区news-listbox的宽度300%（因为有三个选项），超出部分隐藏，这边标题选项只需要鼠标经过的时候带上index，计算margin-left多少，配合css3动画，寥寥几行ES6就实现了以上效果！ [题外话：以上数据都是mock模拟，里面其实很多值得大家可以看的亮点，比如怎么样让新闻第一条数据是和其他li有区别，时间截取、li超出部分显示更多按钮，等等都可下载源码看看] 小菜3、让新闻卡片图片点击放大新闻卡片，点击图片平滑过渡放大，关闭缩小 上菜： 场景需求：其实就是一个查看点击查看大图插件 &lt;template&gt; &lt;div class=&quot;image-dialog&quot;&gt; &lt;button class=&quot;image-dialog-trigger&quot; type=&quot;button&quot; @click=&quot;showDialog&quot;&gt;&lt;img class=&quot;image-dialog-thumb&quot; ref=&quot;thumb&quot; :src=&quot;thumb&quot; /&gt; &lt;/button&gt; &lt;transition name=&quot;dialog&quot; @enter=&quot;enter&quot; @leave=&quot;leave&quot;&gt; &lt;div class=&quot;image-dialog-background&quot; v-show=&quot;appearedDialog&quot; ref=&quot;dialog&quot;&gt; &lt;button class=&quot;image-dialog-close&quot; type=&quot;button&quot; @click=&quot;hideDialog&quot; aria-label=&quot;Close&quot;&gt;&lt;/button&gt; &lt;img class=&quot;image-dialog-animate&quot; ref=&quot;animate&quot; :class=&quot;{ loading: !loaded }&quot; :src=&quot;loaded ? full : thumb&quot; /&gt; &lt;img class=&quot;image-dialog-full&quot; ref=&quot;full&quot; :src=&quot;appearedDialog &amp;amp;&amp;amp; full&quot; :width=&quot;fullWidth&quot; :height=&quot;fullHeight&quot; @load=&quot;onLoadFull&quot; /&gt; &lt;/div&gt; &lt;/transition&gt; &lt;/div&gt; &lt;/template&gt; 复制代码 原理：通过transform:属性scale实现图片缩放，其中图片是两张图小大图切换，目前只是实现了功能，有待优化，所以不贴代码了（完整代码，本文后github链接） 小菜4、轮播图轮播图，现在基于vue的开源的很多优秀的轮播图插件,比如vue-awesome-swiper，这个功能就不多讲， 这边的话我自己写的：1、支持浏览器任意放缩，兼容移动端，2、支持自动切换，鼠标经过停止切换，分页/任意页点击切换，左右切换，3、支持文字介绍（超过一行自动省略） 上菜： 值得一提的是：如果加载轮播图组件（其他组件有这种报错可能）在加载的过程中出现“Error in render: “TypeError: Cannot read property ‘url’ of undefined” 这是由于axios请求和组件渲染顺序的问题引起的，这时候，你只需要在axios请求到数据后，再去加载组件，这里我推荐用v-if，判断当数据的长度大于0，表示请求出来了数据，再去加载轮播组件，如此就不会报错了。 &lt;div class=&quot;slider-wapper&quot;&gt; &lt;slider :slides=&quot;slides&quot; :inv=&quot;invTime&quot; v-if=&quot;slides.length &gt; 0&quot;&gt;&lt;/slider&gt; &lt;/div&gt; 复制代码 对应轮播组件，感兴趣的同学可以看我之前发的文章《从开发到发布一款基于Vue2x的响应式自适应轮播组件插件VueSliderShow》 小菜5、即时检索上菜： 场景需求：通过输入即时检索列表里面的内容，列表的检索过滤，直接上代码（完整代码，本文后github链接） &lt;div class=&quot;search-box&quot;&gt; &lt;div class=&quot;search-wrapper&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;keyword&quot; placeholder=&quot;Search title...&quot; /&gt; &lt;label&gt;Search Title&lt;/label&gt; &lt;/div&gt; &lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;card&quot; v-for=&quot;post in filteredList&quot;&gt; &lt;a v-bind:href=&quot;post.link&quot; target=&quot;_blank&quot;&gt; &lt;img v-bind:src=&quot;post.img&quot; /&gt; &lt;small&gt;Posted by: {{ post.author }}&lt;/small&gt; {{ post.title }} &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 复制代码 methods:{ toggleOnOff() { this.onOff = !this.onOff; } }, computed: { filteredList() { return this.postList.filter((post) =&gt; { return post.title.toLowerCase().includes(this.keyword.toLowerCase()); }); } } 复制代码 原理：通过computed计算input框的内容，然后再展示内容 最后：（未完待续）","categories":[{"name":"前端","slug":"前端","permalink":"https://motainzhang.com/categories/前端/"}],"tags":[]},{"title":"charles","slug":"charles","date":"2018-07-19T15:14:47.000Z","updated":"2019-10-18T03:34:00.262Z","comments":true,"path":"2018/07/19/charles/","link":"","permalink":"https://motainzhang.com/2018/07/19/charles/","excerpt":"","text":"杭城小刘2018年07月18日阅读 1003# Charles抓包工具二三谈### 一、 下载地址Charles的下载地址：charles因为Charles只有30天的试用期，所以在这里给一个破解版的包：破解包### 二、破解方法 像正常安装应用一样，点击安装，之后将应用包拖到Application目录中。 右击Charles.app，显示包内容，然后将第二个链接下载下来的破解包复制黏贴到此目录下替换。### 三、使用教程 Charles上的设置。 在Charles的菜单栏上选择”Proxy” -&gt; “Proxy Settings”,填入代理端口8888，并且勾选”Enable transparent HTTP proxying”,就完成了Charles上的设置，如下图所示： 在电脑“系统偏好设置”中心打开网络查看本机ip地址，打开手机“设置”-&gt;“无线局域网”，进入选中的网络，HTTP代理选中“手动”。服务器处填写电脑ip地址，端口写8888。设置好后，我们打开iPhone上的任意需要网络通讯的程序，就可以看到Charles弹出请求的确认菜单，单击”Allow”按钮，即可完成设置。### 四、使用 Charles mock 接口数据发现有些时候我们需要对一个接口进行黑盒测试，我们可以通过 Charles 进行模拟，或者对某些 App 查看判断业务逻辑也可以用此方法。 选中 Charles 的具体某个接口，右击选择 “Map Local”。 在弹出的对话框中，点击红色圈出来的按钮，然后选择本地准备好的 JSON 文件这2个步骤做完后就可以 mock 接口数据了，每次要做操作，只需要修改本地的 JSON 文件即可当然，这是对于简单的调试，最好还是会写一些接口开发，比如 Node.js 、PHP、Java、Python等等### 五、抓取 HTTPS 数据 在电脑端 Charles 上菜单栏 Help -&gt; SSl Proxying -&gt; Install Charles Root Certificate 在 keychain 处将新安装的证书设置为永久信任 在 Charles 菜单栏 Proxy -&gt; SSL Proxying Setting -&gt; 点击 Add 按钮 -&gt; 在弹出的对对话框设置需要监听的 HTTPS 域（:代表通配符） 在手机上链接好电脑对应的 ip 和端口 在手机浏览器访问 Chls.pro/ssl 安装证书，并信任 iPhone 打开设置 -&gt; 通用 -&gt; 关于本机 -&gt; 证书信任设置 -&gt; 开启开关尽情玩乐吧 看到下方评论说“手机如果有vpn的话，需要现将vpn关闭才能成功”。如果各位在手机开着 VPN 的情况下无法抓包，那么尝试关闭 VPN。（具体未尝试）","categories":[{"name":"工具","slug":"工具","permalink":"https://motainzhang.com/categories/工具/"}],"tags":[]},{"title":"Spring MVC的Controller的几种常用返回类型（含请求转发、重定向）","slug":"Spring-MVC的Controller的几种常用返回类型（含请求转发、重定向）","date":"2018-06-14T23:35:50.000Z","updated":"2019-10-18T03:34:00.262Z","comments":true,"path":"2018/06/14/Spring-MVC的Controller的几种常用返回类型（含请求转发、重定向）/","link":"","permalink":"https://motainzhang.com/2018/06/14/Spring-MVC的Controller的几种常用返回类型（含请求转发、重定向）/","excerpt":"","text":"返回ModelAndView返回ModelAndView时最常见的一种返回结果。需要在方法结束的时候定义一个ModelAndView对象，并对Model和View分别进行设置。 返回String字符串代表逻辑视图名真实的访问路径=“前缀”+逻辑视图名+“后缀” 注意：如果返回的String代表逻辑视图名的话，那么Model的返回方式如下：1234public String testController(Model model)&#123; model.addAttribute(attrName,attrValue);//相当于ModelAndView的addObject方法 return &quot;逻辑视图名&quot;;&#125; 代表redirect重定向redirect的特点和servlet一样，使用redirect进行重定向那么地址栏中的URL会发生变化，同时不会携带上一次的request 案例：123public String testController(Model model)&#123; return &quot;redirect:path&quot;;//path代表重定向的地址&#125; 代表forward转发通过forward进行转发，地址栏中的URL不会发生改变，同时会将上一次的request携带到写一次请求中去 案例：123public String testController(Model model)&#123; return &quot;forward:path&quot;;//path代表转发的地址&#125; 返回void返回这种结果的时候可以在Controller方法的形参中定义HTTPServletRequest和HTTPServletResponse对象进行请求的接收和响应 使用request转发页面 request.getRequestDispatcher(&quot;转发路径&quot;).forward(request,response); 使用response进行页面重定向 response.sendRedirect(&quot;重定向路径&quot;); 也可以使用response指定响应结果123response.setCharacterEncoding(&quot;UTF-8&quot;);response.setContentType(&quot;application/json;charset=utf-8&quot;);response.getWriter.write(&quot;json串&quot;);","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"https://motainzhang.com/categories/Java-Web/"},{"name":"Spring MVC","slug":"Java-Web/Spring-MVC","permalink":"https://motainzhang.com/categories/Java-Web/Spring-MVC/"}],"tags":[{"name":"Controller","slug":"Controller","permalink":"https://motainzhang.com/tags/Controller/"},{"name":"返回类型， forward， redirect","slug":"返回类型，-forward，-redirect","permalink":"https://motainzhang.com/tags/返回类型，-forward，-redirect/"}]},{"title":"根据请求的具体扩展名、请求头不同，返回不同格式的相同内容","slug":"根据请求的具体扩展名、请求头不同，返回不同格式的相同内容","date":"2018-06-14T22:48:32.000Z","updated":"2019-10-18T03:34:00.262Z","comments":true,"path":"2018/06/14/根据请求的具体扩展名、请求头不同，返回不同格式的相同内容/","link":"","permalink":"https://motainzhang.com/2018/06/14/根据请求的具体扩展名、请求头不同，返回不同格式的相同内容/","excerpt":"","text":"内容协商多视图SpringMVC配置多视图-内容协商原理 1234&lt;bean class=&quot;org.springframework.web.servlet.view.ContentNegotiatingViewResolver&quot;&gt; &lt;property name=&quot;contentNegotiationManager&quot; ref=&quot;contentNegotiationManager&quot;/&gt; ...&lt;/bean&gt; Spring MVC三种方式实现HTTP内容协商(Content Negotiation)","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"https://motainzhang.com/categories/Java-Web/"},{"name":"Spring MVC框架","slug":"Java-Web/Spring-MVC框架","permalink":"https://motainzhang.com/categories/Java-Web/Spring-MVC框架/"},{"name":"视图","slug":"Java-Web/Spring-MVC框架/视图","permalink":"https://motainzhang.com/categories/Java-Web/Spring-MVC框架/视图/"}],"tags":[{"name":"视图","slug":"视图","permalink":"https://motainzhang.com/tags/视图/"},{"name":"ContentNegotiatingViewResolver","slug":"ContentNegotiatingViewResolver","permalink":"https://motainzhang.com/tags/ContentNegotiatingViewResolver/"},{"name":"contentNegotiationManager","slug":"contentNegotiationManager","permalink":"https://motainzhang.com/tags/contentNegotiationManager/"}]},{"title":"服务端返回JSON数据，实现客户端的无关性","slug":"服务端返回JSON数据，实现客户端的无关性","date":"2018-06-14T18:56:48.000Z","updated":"2019-10-18T03:34:00.262Z","comments":true,"path":"2018/06/14/服务端返回JSON数据，实现客户端的无关性/","link":"","permalink":"https://motainzhang.com/2018/06/14/服务端返回JSON数据，实现客户端的无关性/","excerpt":"","text":"","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"https://motainzhang.com/categories/Java-Web/"},{"name":"Spring MVC框架，视图","slug":"Java-Web/Spring-MVC框架，视图","permalink":"https://motainzhang.com/categories/Java-Web/Spring-MVC框架，视图/"}],"tags":[]},{"title":"批量执行与SqlSessionTemplate","slug":"批量执行与SqlSessionTemplate","date":"2018-06-14T12:21:46.000Z","updated":"2019-10-18T03:34:00.262Z","comments":true,"path":"2018/06/14/批量执行与SqlSessionTemplate/","link":"","permalink":"https://motainzhang.com/2018/06/14/批量执行与SqlSessionTemplate/","excerpt":"","text":"","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"https://motainzhang.com/categories/Java-Web/"},{"name":"测试","slug":"Java-Web/测试","permalink":"https://motainzhang.com/categories/Java-Web/测试/"}],"tags":[{"name":"SqlSession","slug":"SqlSession","permalink":"https://motainzhang.com/tags/SqlSession/"},{"name":"批量操作","slug":"批量操作","permalink":"https://motainzhang.com/tags/批量操作/"}]},{"title":"Spring test的测试操作","slug":"Spring-test的测试操作","date":"2018-06-14T12:20:53.000Z","updated":"2019-10-18T03:34:00.262Z","comments":true,"path":"2018/06/14/Spring-test的测试操作/","link":"","permalink":"https://motainzhang.com/2018/06/14/Spring-test的测试操作/","excerpt":"","text":"","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"https://motainzhang.com/categories/Java-Web/"},{"name":"测试","slug":"Java-Web/测试","permalink":"https://motainzhang.com/categories/Java-Web/测试/"}],"tags":[]},{"title":"Mybatis逆向工程","slug":"Mybatis逆向工程","date":"2018-06-13T20:41:41.000Z","updated":"2019-10-18T03:34:00.262Z","comments":true,"path":"2018/06/13/Mybatis逆向工程/","link":"","permalink":"https://motainzhang.com/2018/06/13/Mybatis逆向工程/","excerpt":"","text":"所需依赖mybatis-generator-core 创建generator的配置xml文件","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"https://motainzhang.com/categories/Java-Web/"},{"name":"数据库连接","slug":"Java-Web/数据库连接","permalink":"https://motainzhang.com/categories/Java-Web/数据库连接/"}],"tags":[{"name":"Mybatis逆向工程","slug":"Mybatis逆向工程","permalink":"https://motainzhang.com/tags/Mybatis逆向工程/"}]},{"title":"MySQL的外键关联","slug":"MySQL的外键关联","date":"2018-06-13T18:59:29.000Z","updated":"2019-10-18T03:34:00.262Z","comments":true,"path":"2018/06/13/MySQL的外键关联/","link":"","permalink":"https://motainzhang.com/2018/06/13/MySQL的外键关联/","excerpt":"","text":"外键的作用 保证数据的完整性和一致性，对业务处理有着很好的校验作用 增加ER图的可读性 当删除 某个数据库表中的 某一行数据，如果其中某列有外键关联，会联动删除外键指向的 数据库表的相关行。更新也是如此。 添加外键命令行操作12345ALTER TABLE yourtablename ADD [CONSTRAINT 外键名] FOREIGN KEY [id] (index_col_name, ...) REFERENCES tbl_name (index_col_name, ...) [ON DELETE &#123;CASCADE | SET NULL | NO ACTION | RESTRICT&#125;] [ON UPDATE &#123;CASCADE | SET NULL | NO ACTION | RESTRICT&#125;] 说明:ON DELETE/ON UPDATE用于定义delete,update操作.以下是update,delete操作的各种约束类型: CASCADE:外键表中外键字段值会被更新,或所在的列会被删除. RESTRICT:RESTRICT也相当于no action,即不进行任何操作.即,拒绝父表update外键关联列,delete记录. set null:被父面的外键关联字段被update ,delete时,子表的外键列被设置为null.而对于insert,子表的外键列输入的值,只能是父表外键关联列已有的值.否则出错. 外键定义服从下列情况：(前提条件) 所有tables必须是InnoDB型，它们不能是临时表.因为在MySQL中只有InnoDB类型的表才支持外键. 所有要建立外键的字段必须建立索引. 对于非InnoDB表，FOREIGN KEY子句会被忽略掉。 注意:创建外键时,定义外键名时,不能加引号.如: constraint ‘fk_1’ 或 constraint “fk_1”是错误的 MySQL Workbench操作","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://motainzhang.com/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://motainzhang.com/tags/MySQL/"},{"name":"Foreign Keys","slug":"Foreign-Keys","permalink":"https://motainzhang.com/tags/Foreign-Keys/"}]},{"title":"mybatis的驼峰命名","slug":"mybatis的驼峰命名","date":"2018-06-13T18:43:55.000Z","updated":"2019-10-18T03:34:00.262Z","comments":true,"path":"2018/06/13/mybatis的驼峰命名/","link":"","permalink":"https://motainzhang.com/2018/06/13/mybatis的驼峰命名/","excerpt":"","text":"Mybatis 支持驼峰命名的属性mapUnderscoreToCamelCase：下划线与驼峰式命名规则的映射。如： first_name =&gt; firstName A_COLUMN =&gt; aColumn Mybatis默认不开启该命名规则的转换。 启用驼峰命名spring配置： 12345&lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"mapperLocations\" value=\"classpath:sqlMapper/*\" /&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"&gt;&lt;/property&gt; &lt;/bean&gt; mybatis-config.xml：12345&lt;configuration&gt; &lt;settings&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\" /&gt; &lt;/settings&gt; &lt;/configuration&gt;","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"https://motainzhang.com/categories/Java-Web/"},{"name":"数据库连接","slug":"Java-Web/数据库连接","permalink":"https://motainzhang.com/categories/Java-Web/数据库连接/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"https://motainzhang.com/tags/Mybatis/"},{"name":"驼峰命名","slug":"驼峰命名","permalink":"https://motainzhang.com/tags/驼峰命名/"},{"name":"spring","slug":"spring","permalink":"https://motainzhang.com/tags/spring/"}]},{"title":"DOM","slug":"DOM","date":"2018-06-12T11:20:05.000Z","updated":"2019-10-18T03:34:00.262Z","comments":true,"path":"2018/06/12/DOM/","link":"","permalink":"https://motainzhang.com/2018/06/12/DOM/","excerpt":"","text":"","categories":[{"name":"前端","slug":"前端","permalink":"https://motainzhang.com/categories/前端/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"https://motainzhang.com/categories/前端/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://motainzhang.com/tags/JavaScript/"},{"name":"DOM","slug":"DOM","permalink":"https://motainzhang.com/tags/DOM/"}]},{"title":"缓存数据","slug":"缓存数据","date":"2018-05-22T15:07:54.000Z","updated":"2019-10-18T03:34:00.262Z","comments":true,"path":"2018/05/22/缓存数据/","link":"","permalink":"https://motainzhang.com/2018/05/22/缓存数据/","excerpt":"","text":"缓存的作用缓存（Caching）可以存储经常会用到的信息，这样每次需要的时候，这些信息都是立即可用的。尽管Spring自身没有实现缓存解决方案，但它对缓存功能提供了声明式的支持，能够与多种流行的缓存实现进行集成。 启用对缓存的支持Spring对缓存的支持有两种方式： 注解驱动的缓存 XML声明的缓存 使用Spring的缓存抽象时，最为通用的方式就是在方法上添加@Cacheable和@CacheEvict注解 使用XML声明缓存因为缓存是一种面向切面的行为，所以cache命名空间会与Spring的aop命名空间结合使用，用来声明缓存所应用的切点在哪里。 Redis缓存机制","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"https://motainzhang.com/categories/Java-Web/"},{"name":"缓存","slug":"Java-Web/缓存","permalink":"https://motainzhang.com/categories/Java-Web/缓存/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://motainzhang.com/tags/Spring/"},{"name":"缓存","slug":"缓存","permalink":"https://motainzhang.com/tags/缓存/"}]},{"title":"正则表达式","slug":"正则表达式","date":"2018-05-21T14:31:54.000Z","updated":"2019-10-18T03:34:00.262Z","comments":true,"path":"2018/05/21/正则表达式/","link":"","permalink":"https://motainzhang.com/2018/05/21/正则表达式/","excerpt":"","text":"正则表达式字符描述正则表达式30分钟入门教程 字符 含义 ^ 匹配输入的开始位置 \\ 将下一个字符标记为特殊字符或字面值 * 或 ? 匹配前一个字符零次或几次 + 匹配前一个字符一次或多次 (pattern) 与模式匹配并记住匹配 x &#124; y 匹配 x 或 y [a-z] 表示某个范围内的字符，与指定区间内的任何字符匹。 \\w 与任何单词字符匹配，包括下划线 {n,m} 最少匹配 n 次且最多匹配 m 次 $ 匹配输入的结尾 email的正则表达式引用自email正则表达式 一般的email,形如zhangshan@163.com,abc@sina.com.cn这样一些常用的形式就行了,但是在我们公司的一些客户中邮箱却有一些`zhangshna.Mr@163.com、abc_Wang.dd@sian.com、abc_Wang.dd.cc@sian.com这 种类似的形式。在@符号之前还有.`,原来是拿来就用,可是现在就不行,得自己研究正则的用法了。 原来的正则表达式^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(.[a-zA-Z0-9_-]+)+$根据实际情况修改后的正则表达式^(\\w)+(.\\w+)@(\\w)+((.\\w{2,3}){1,3})$或者^(\\w)+(.\\w+)@(\\w)+((.\\w+)+)$ 一些常用的正则表达式:1.验证用户名和密码：（”^[a-zA-Z]\\w{5,15}$”）正确格式：”[A-Z][a-z]_[0-9]”组成,并且第一个字必须为字母6~16位； 2.验证电话号码：（”^(\\d{3.4}-)\\d{7,8}$”）正确格式：xxx/xxxx-xxxxxxx/xxxxxxxx； 3.验证身份证号（15位或18位数字）：（”^\\d{15}|\\d{18}$”）； 4.验证Email地址：(“^\\w+([-+.]\\w+)@\\w+([-.]\\w+).\\w+([-.]\\w+)*$”)； 5.只能输入由数字和26个英文字母组成的字符串：(“^[A-Za-z0-9]+$”) ; 6.整数或者小数：^[0-9]+.{0,1}[0-9]{0,2}$ 7.只能输入数字：”^[0-9]*$”。 8.只能输入n位的数字：”^\\d{n}$”。 9.只能输入至少n位的数字：”^\\d{n,}$”。 10.只能输入m~n位的数字：。”^\\d{m,n}$” 11.只能输入零和非零开头的数字：”^(0|[1-9][0-9]*)$”。 12.只能输入有两位小数的正实数：”^[0-9]+(.[0-9]{2})?$”。 13.只能输入有1~3位小数的正实数：”^[0-9]+(.[0-9]{1,3})?$”。 14.只能输入非零的正整数：”^+?[1-9][0-9]*$”。 15.只能输入非零的负整数：”^-[1-9][]0-9”*$。 16.只能输入长度为3的字符：”^.{3}$”。 17.只能输入由26个英文字母组成的字符串：”^[A-Za-z]+$”。 18.只能输入由26个大写英文字母组成的字符串：”^[A-Z]+$”。 19.只能输入由26个小写英文字母组成的字符串：”^[a-z]+$”。 20.验证是否含有^%&amp;’,;=?$\\”等字符：”[^%&amp;’,;=?$\\x22]+”。 21.只能输入汉字：”^[\\u4e00-\\u9fa5]{0,}$” 22.验证URL：”^http://([\\w-]+.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$”。 23.验证一年的12个月：”^(0?[1-9]|1[0-2])$”正确格式为：”01”～”09”和”1”～”12”。 24.验证一个月的31天：”^((0?[1-9])|((1|2)[0-9])|30|31)$”正确格式为；”01”～”09”和”1”～”31”。","categories":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://motainzhang.com/categories/正则表达式/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://motainzhang.com/tags/正则表达式/"},{"name":"regexp","slug":"regexp","permalink":"https://motainzhang.com/tags/regexp/"}]},{"title":"将eclipse中web项目的默认发布路径改为本地Tomcat所在的webapp路径","slug":"将eclipse中web项目的默认发布路径改为本地Tomcat所在的webapp路径","date":"2018-05-19T00:50:06.000Z","updated":"2019-10-18T03:34:00.262Z","comments":true,"path":"2018/05/19/将eclipse中web项目的默认发布路径改为本地Tomcat所在的webapp路径/","link":"","permalink":"https://motainzhang.com/2018/05/19/将eclipse中web项目的默认发布路径改为本地Tomcat所在的webapp路径/","excerpt":"","text":"在Eclipse中做的Web项目默认会发布到工作空间的某个目录，因此无法在外部启动Tomcat来运行Web项目，只有打开Eclipse中的服务器，才能运行Web项目。 解决方式 在Eclipse中的最底下的Servers视图，将所有部署的项目移除 再双击这个tomcat server 在“Server Locations”处选择“Use Tomcat installation”，然后在Deploy的path处写上本地tomcat路径/webapps即可。 参考：Eclipse中web项目的默认发布路径改为外部Tomcat中webapp路径","categories":[{"name":"杀死exception","slug":"杀死exception","permalink":"https://motainzhang.com/categories/杀死exception/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"https://motainzhang.com/tags/Tomcat/"},{"name":"eclipse","slug":"eclipse","permalink":"https://motainzhang.com/tags/eclipse/"}]},{"title":"解决Properties文件的中文内容乱码","slug":"解决Properties文件的中文内容乱码","date":"2018-05-17T22:03:30.000Z","updated":"2019-10-18T03:34:00.262Z","comments":true,"path":"2018/05/17/解决Properties文件的中文内容乱码/","link":"","permalink":"https://motainzhang.com/2018/05/17/解决Properties文件的中文内容乱码/","excerpt":"","text":"用IDEA进行开发，导航栏File -&gt; Settings -&gt; Editor -&gt; File Encodings，把看到Encoding的地方都选为UTF-8，并把Transparent native-to-ascii conversion（自动进行unicode转码，待学习）勾上，ok。","categories":[{"name":"杀死exception","slug":"杀死exception","permalink":"https://motainzhang.com/categories/杀死exception/"}],"tags":[{"name":"中文乱码","slug":"中文乱码","permalink":"https://motainzhang.com/tags/中文乱码/"},{"name":".properties","slug":"properties","permalink":"https://motainzhang.com/tags/properties/"}]},{"title":"Spring MVC的简单总结","slug":"Spring-MVC的简单总结","date":"2018-05-14T19:39:51.000Z","updated":"2019-10-18T03:34:00.262Z","comments":true,"path":"2018/05/14/Spring-MVC的简单总结/","link":"","permalink":"https://motainzhang.com/2018/05/14/Spring-MVC的简单总结/","excerpt":"","text":"为什么需要Spring MVC框架 需要一个框架来处理路由（映射） 需要一个框架来处理MVC(前端、后端、数据处理的分离) DispatcherServletSpring MVC 是以一个servlet为核心来构建的——DispatcherServlet。 DispatcherServlet处理请求与相应的示意图： 工作流程： 客户端发送请求到DispatcherServlet DispatcherServlet查询一个或多个处理器映射（handler mapping）来确定发送给对应的Controller Controller处理发来的请求（设计良好的Controller本身只处理很少的工作，将业务逻辑委托给一个或多个service对象进行处理） Controller进行逻辑处理得到的内容称为模型（model），Controller将模型数据打包，并标示出用于渲染输出的视图名，发还给DispatcherServlet DispatcherServlet用view resolver将逻辑视图名匹配为一个特定的视图进行实现。 如何使用DispatcherServlet 添加相关依赖 spring-webmvc javax.servlet-api(待确认是否需要) 在web.xml文件中添加如下内容： 123456789101112&lt;servlet&gt; &lt;servlet-name&gt;自定义名称&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:[servlet-name]-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;与上边定义的name相同&lt;/servlet-name&gt; &lt;url-pattern&gt;/api/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 还需要创建一个[servlet-name]-servlet.xml文件，来定义该Servlet相关（MVC）的内容： HandlerMapping(可以不定义，有默认配置) Controllers(相对于在xml中定义，偏向用annotation来定义，然后开启自动发现机制) View解析相关（也有默认配置，偏向进行显式的具体配置） WebApplicationContext不同于IoC容器一文中介绍的，在非Web场景下，需要通过ClassPathXmlApplicationContext或FileSystemXmlApplicationContext来定义IoC容器。SpringMVC框架下，会根据DispatcherServlet的配置，自动生成ApplicationContext。 ContextLoaderListener我们希望DispatcherServlet加载包含Web组件的bean（如Controller、view resolver以及handler mapping）；ContextLoaderListener加载其他bean（驱动应用后端的中间层和数据层组件） 在web.xml文件中添加如下内容：1234567&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLation&lt;/param-name&gt; &lt;param-value&gt;applicationContext配置文件的路径.xml&lt;/param-value&gt;&lt;/context-param&gt; applicationContext配置文件的路径.xml用来定义DAO、Service相关的内容。 启用Spring MVCSpring MVC相关配置文件中，添加如下内容：&lt;mvc:annotation-driven /&gt; Controller定义Controller 在上述的[servlet-name]-servlet.xml文件中，添加：&lt;context:component-scan base-package=&quot;查找的范围&quot;&gt; 在具体的Java类上加上@Controller的注释，就会作为一个Bean（作用和@Component一样，只是更具备阅读性）被扫描到例子：123@Controller //annotation声明Controller即可@ResultMapping(\"/\")public class ... 声明@ResultMapping@ResultMapping有很多属性： value&amp;path：路径（没有其他参数时，可以直接写 “路径”，也可以接受String类型的数组） method：请求方法（GET、POST等） params：请求参数 headers：请求头… 如：@ResultMapping({&quot;/&quot;, &quot;/homepage&quot;}) view相关在Spring MVC的xml配置文件中，添加视图解析器1234567891011121314151617&lt;bean class=\"org.springframework.web.servlet.view.ContentNegotiatingViewResolver\"&gt; &lt;property name=\"viewResolvers\"&gt; &lt;list&gt; &lt;!-- 展示JSP --&gt; &lt;bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/JSP\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"defaultViews\"&gt; &lt;list&gt; &lt;!-- 展示Json --&gt; &lt;bean class=\"org.springframework.web.servlet.view.json.MappingJackson2JsonView\"/&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; 函数参数如：Modle、ViewAndModel、Map都是存放视图相关属性的k-v键值对，为视图模型。当视图是JSP时，模型数据会作为请求属性放到请求中。 JSP视图Spring提供了两种支持JSP视图的方式： InternalResourceViewResolver会将视图名解析为JSP文件。如果在JSP页面中使用了JSP标准标签库（JSTL）,通过设置，**视图可以被解析为JstlView形式的JSP文件，从而将JSTL本地化和资源bundle变量暴露给JSTL的格式化（formatting）和信息（message）标签。 Spring提供了两个JSP标签库，一个用于表单到模型的绑定，另一个提供通用的工具类特性。 解析JSTL视图如果JSP使用JSTL标签来处理格式化和信息的话，我们希望将视图解析为JSTLView。123456&lt;!-- 展示JSP --&gt;&lt;bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/JSP\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;property name=\"viewClass\" value=\"org.springframework.web.servlet.view.JstlView\" /&gt;&lt;/bean&gt; 使用Spring的JSP库将表单绑定到模型上 将表单绑定到模型上，表单就可以预先填充值，并在表单提交失败后，展现校验错误。 表单绑定JSP标签库的标签会绑定模型中的一个对象，能够根据模型对象中对象的属性填充值。还提供了一个为用户展现错误的标签，能将错误信息渲染到最终的HTML之中。 使用表单绑定库，需要在JSP页面声明： &lt;$@ taglib uri=&quot;http://www.springframework.org/tags/form&quot; prefix=&quot;sf&quot; %&gt; 前缀为自定义，sf意为spring form。包含的标签 展示错误说明如果存在校验错误，请求中会包含错误的详细信息。为了将错误的信息从视图模型中取出并展示给用户，需要用到&lt;sf:errors&gt;。例：&lt;sf:errors path=&quot;username&quot; /&gt;&lt;sf:errors&gt;的path属性用来指定要显示 绑定的模型对象中某个属性 的错误。只有发生错误，该标签才会渲染内容到HTML。 展示国际化信息使用通用标签库需要声明：&lt;$@ taglib uri=&quot;http://www.springframework.org/tags&quot; prefix=&quot;s&quot; %&gt; 前缀为自定义，s意为spring。 在JSP文件中，借助&lt;s:message&gt;可以将硬编码的欢迎信息转换成如下形式：&lt;h1&gt;&lt;s:message code=&quot;spittr.welcome&quot; /&gt;&lt;/h1&gt;&lt;s:message&gt;会根据key为spittr.welcome的信息源来渲染文本 校验请求的数据初级的校验方法：在Controller对应的映射方法中，添加检查值的校验逻辑（if判断） 与其让校验逻辑弄乱Controller方法，不如使用Spring对Java校验API（Java Validation API）的支持。 Java 校验API定义了多个注解，将注解放到属性上，就能限制属性的值。所需依赖: validation-api hibernate-validator 这里要注意，如果使用Maven的tomcat插件运行项目，而hibernate-validator的version是6.0+，会报错NoClassDefFoundError: javax/el/ELManager。但是其实tomcat有el的相关依赖。原因是hibernate-validator5.4+开始就开始依赖el-api3.0+ 的版本，但是Tomcat插件是7.0+的版本,自带的是2.2版本的el-api。 解决方式：不通过maven的tomcat插件，直接用高版本的Tomcat运行；或者降低hibernate-validator的版本（如用5.3.6.Final）。推荐降低版本，适用于更多环境。参考：找不到el依赖而报错的分析 validation-api提供的校验注解 注解 描述 @AssertFalse 所注解的元素必须是Boolean类型，并且值为false @AssertTrue 所注解的元素必须是Boolean类型，并且值为true @DecimalMax 所注解的元素必须是数字，并且值要 &lt;= 给定的BigDemicalString值 @DecimalMin 所注解的元素必须是数字，并且值要 &gt;= 给定的BigDemicalString值 @Digits 所注解的元素必须是数字，并且它的值必须有指定的位数 @Future 所注解的元素必须是一个将来的日期 @Max 所注解的元素必须是数字，并且值要 &lt;= 给定的值 @Min 所注解的元素必须是数字，并且值要 &gt;= 给定的值 @NotNull 所注解的元素不能为null @Null 所注解的元素必须为null @Past 所注解的元素必须是一个过去的日期 @Pattern 所注解的元素的值必须匹配给定的正则表达式 @Size 所注解的元素的值必须是String、集合或数组，并且长度要符合给定的范围 处理Multipart形式的数据处理异常不论请求处理的过程是否出现异常，Serlvet请求输出的都是一个Servlet响应，**异常必须要以某种方式转换为响应。Spring提供了多种方式将异常转换为响应： 特定的Spring异常将会自动映射为指定的HTTP状态码 异常上可以添加@ResponseStatus注解，从而将其映射为某一个HTTP状态码 方法上可以添加@ExceptionHandler注解，进而放到响应之中。 将异常映射为HTTP状态码 图中的异常会由Spring自身抛出，作为DispatcherServlet处理过程中或执行校验时出现问题的结果。例如：如果DispatcherServlet无法找到适合处理请求的控制器方法，将会抛出NoSuchRequestHandlingMethodException异常，从而产生404状态码的响应。 尽管这些内置的映射很有用，但是对于应用所抛出的异常，它们就无能为力了。这时，可以通过Spring提供的@ResponseStatus注解，将异常映射为HTTP状态码 异常添加@ResponseStatus注解，映射为HTTP状态码如果出现没有任何映射的异常，响应都会带有500状态码。可以通过映射的异常类对该默认行为进行变更。 自定义异常类，并添加@ResponseStatus注解12345@ResponseStatus(value = HttpStatus.NOT_FOUND, reason = \"Spittle Not Found\")public class SpittleNotFoundException extends RuntimeException &#123; ...&#125; 编写异常处理的方法在很多场景下，将异常映射为状态码是很简单的方案，并且就功能来说也足够。如果我们想在响应中不仅包括状态码，还要包含所产生的错误，就需要按照处理请求的方式来处理异常。 要将异常处理的操作从Controller的业务流程中剥离，单独为一个方法 跨重定向请求传递数据 一般情况，当一个处理器方法完成之后，该方法所指定的模型数据将会复制到请求中，并作为请求中的属性，请求会转发（forward）到视图上进行渲染。因为控制器方法和视图所处理的是同一个请求，所以转发过程中，请求属性得以保存。 但当控制器的结果是重定向的话，原始的请求就结束了（其中的模型数据也会一起消失），并会发起一个新的GET请求。在新的请求属性中，没有任何模型数据，新的请求必须要自己计算数据。 显然，对于重定向来说，模型不能用来传递数据。但可以通过两种方案，能够从发起重定向的方法传递数据给处理重定向方法中： 使用URL模板以路径变量（可以包含查询参数）的形式传递数据 通过flash属性发送数据 通过URL模板进行重定向通过路径变量和查询参数传递数据。 12345678model.addAttribute(\"username\", spitter.getUsername());model.addAttribute(\"userId\", spitter.getId());/** * username作为占位符填充到url模板中，比起String形式直连更安全 * 模型中其他所有的 原始类型值 都可以添加到URL中作为查询参数， * 如果没有相应的占位符，会自动以查询参数的形式附加到重定向URL上。 */return \"redirect:/spitter/&#123;username&#125;\";//redirect的路径实际还会加上 ?spitterId=xxxx 很简单，也有一定的限制：只能用来发送原始类型值。这时，flash属性可以提供帮助。 使用flash属性 其实还有个方案是将要传输的 对象放到会话(session)中。会话能够长期存在，并能跨多个请求，可以在重定向发生之前将Spitter放到会话中，并在重定向后，从会话中将其取出并将其从会话中清理掉。 但Spring认为我们并不需要管理这些数据（从会话中存取、清理等工作），提供了将数据发送为flash属性（flash attribute）的功能。按照定义，flash属性会一直携带这些数据直到下次请求，然后消失。 Spring提供了通过RedirectAttributes（Spring3.1引入的Model子接口，提供了Model的所有功能），设置flash属性的方法addFlashAtrribute()。例子：12345678910public String register(HttpServletRequest request, @RequestPart(\"icon\") MultipartFile icon, @Valid Spitter spitter, Errors errors, RedirectAttributes model) &#123; ... model.addAttribute(\"username\", spitter.getUsername()); model.addFlashAttribute(\"spitter\", spitter); return \"redirect:/spitter/&#123;username&#125;\"; 在重定向执行之前，所有的flash属性都会复制到会话中。在重定向之后，存在会话中的flash属性会被取出，转移到模型中。 实现全局的登录状态后端在Controller中 通过session对登录信息进行增删 - `session.setAttribute(&quot;user&quot;, user);` - `session.removeAttribute(&quot;user&quot;);` 前端在JSP页面中 通过jstl的c标签，获取session中的相关内容进行判断12345678&lt;c:if test=\"$&#123;empty sessionScope.spitter&#125;\"&gt; &lt;li&gt;&lt;a href=\"&lt;c:url value=\"/login\" /&gt;\"&gt;登录&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"&lt;c:url value=\"/register\"/&gt;\"&gt;注册&lt;/a&gt;&lt;/li&gt;&lt;/c:if&gt;&lt;c:if test=\"$&#123;!empty sessionScope.spitter&#125;\"&gt; &lt;li&gt;&lt;a href=\"&lt;c:url value=\"/$&#123;sessionScope.spitter.username&#125;\" /&gt;\"&gt;个人主页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"&lt;c:url value=\"/logout\"/&gt;\"&gt;退出&lt;/a&gt;&lt;/li&gt;&lt;/c:if&gt;","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"https://motainzhang.com/categories/Java-Web/"},{"name":"Spring MVC框架","slug":"Java-Web/Spring-MVC框架","permalink":"https://motainzhang.com/categories/Java-Web/Spring-MVC框架/"}],"tags":[{"name":"DispatcherServlet","slug":"DispatcherServlet","permalink":"https://motainzhang.com/tags/DispatcherServlet/"}]},{"title":"AOP的简单总结","slug":"AOP的简单总结","date":"2018-05-12T20:54:27.000Z","updated":"2019-10-18T03:34:00.262Z","comments":true,"path":"2018/05/12/AOP的简单总结/","link":"","permalink":"https://motainzhang.com/2018/05/12/AOP的简单总结/","excerpt":"","text":"AOP是什么AOP（Aspect-Oriented Programming）:面向切面编程 AOP实现了代码重用，以及业务逻辑与非业务逻辑（日志、安全）的分离。 Aspect： 拥有日志、安全等功能的类JoinPoint：函数执行过程或者属性访问Pointcut：匹配 横切目标函数 的表达式Pointcut表达式： 示例： 匹配所有public函数 12@Pointcut(\"execution(public * *(..))\") //对下一行的pointcut进行定义private void publicMethod()&#123;&#125; //命名的Pointcut 匹配某个具体路径范围内的public函数 1execution(public * com.hunter.dao.*.*(..)) //*.*(..) 路径下所有类的所有函数 所有以save开头的函数 12@Pointcut(\"execution(* save*(..))\")private void saveMethod()&#123;&#125; //命名的Pointcut 所有以save开头的public函数 12execution(publicMethod()&amp;&amp;saveMethod())... Advice：在目标函数上要执行切面功能（在目标函数上标注）Advice的类型： Before：函数执行之前 After returning：函数正常返回之后 After throwing：函数抛出异常之后 After finally：函数返回之后 Around：函数执行前后 Spring AOPSpring AOP是非完整的AOP实现（例如只支持 函数执行中的JoinPoint）。 Spring提供两种不同方式的AOP功能实现： 通过@AspectJ注解 通过XML文件配置 通过@AspectJ注解 添加aspectjweaver.jar和spring-aop的依赖 在XML配置文件中添加如下内容： 123456789101112&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" ... xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\" ... http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; ... &lt;aop:aspectj-autoproxy /&gt; ...&lt;/beans&gt; 定义AspectXML配置文件下：&lt;bean id=&quot;唯一标识符&quot; class=&quot;对应的类&quot;&gt;&lt;/bean&gt;对应的Java类： 1234@Aspectpublic class LoggingAspect &#123; ...&#125; 在上述Java类中定义Pointcut(可忽略这一步，直接在Advice的定义中写出Pointcut表达式)例： 12@Pointcut(\"Pointcut表达式\") //匹配目标函数private void 表达式名称() &#123;&#125; 定义Advice例： 1234@Before(\"Pointcut表达式 或 表达式对应的名称\")public void doLog()&#123; //具体的操作&#125; Advice参数… 通过XML文件配置…","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"https://motainzhang.com/categories/Java-Web/"},{"name":"Spring框架","slug":"Java-Web/Spring框架","permalink":"https://motainzhang.com/categories/Java-Web/Spring框架/"}],"tags":[{"name":"AOP","slug":"AOP","permalink":"https://motainzhang.com/tags/AOP/"},{"name":"Spring","slug":"Spring","permalink":"https://motainzhang.com/tags/Spring/"}]},{"title":"IoC容器及其管理对象Bean","slug":"IoC容器","date":"2018-05-12T17:08:10.000Z","updated":"2019-10-18T03:34:00.262Z","comments":true,"path":"2018/05/12/IoC容器/","link":"","permalink":"https://motainzhang.com/2018/05/12/IoC容器/","excerpt":"","text":"IoC容器是什么IOC(Inversion of Control)即控制反转。 控制什么控制对象的依赖（Dependency Injection，依赖注入）。 谁来控制对象的提供者来控制。 通过IoC容器完成依赖注入的过程。IoC位于Spring框架比较核心的地位，向上层的AOP、外部框架以及数据访问的框架提供了基本的支持。 Ioc容器类是ApplicationContext要使用ApplicationContext需要添加spring-context依赖。 初始化IoC容器ApplicationContext在web.xml配置文件中添加以下内容即可1234&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:ApplicationContext配置文件路径.xml&lt;/param-value&gt; &lt;/context-param&gt; ApplicationContext配置文件路径.xml需要添加xmlns:context和相关schemaLocation：12345678910&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" ... xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\" ... http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; ...&lt;/beans&gt; 如果在非Web场景下，可以通过以下两种方式初始化IoC容器： ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classPath下的XML配置文件&quot;) ApplicationContext context = new FileSystemXmlApplicationContext(&quot;文件系统中的相对路径/绝对路径&quot;) BeanBean的定义Bean是被实例化、组装，并通过IoC容器管理的对象。 在ApplicationContext的XML配置文件中通过以下内容，即可定义bean：&lt;bean id=&quot;唯一标识符&quot; class=&quot;对应的类&quot;&gt;&lt;/bean&gt; 非Web场景下Bean的使用12345678public static void main(String[] args) &#123; //初始化IoC容器 ApplicationContext context = new ClassPathXmlApplicationContext(\"classPath下的XML配置文件\"); //获取对象 类名 对象名 = context.getBean(BeanId, 对应类名.class); //使用对象 ...&#125; Bean的作用域 singleton（单例，默认的作用域）&lt;bean id=&quot;唯一标识符&quot; class=&quot;对应的类&quot; scope=&quot;singleton&quot;&gt;&lt;/bean&gt; prototype（每次引用，都创建一个新实例）Bean的生命周期回调功能创建bean时做额外的事情（如申请资源） 方式一：实现Spring提供的InitializingBean接口完成回调 123public interface InitializingBean &#123; void afterPropertiesSet() throws Exception;&#125; 方式二：&lt;bean&gt;中定义创建时调用的方法&lt;bean id=&quot;唯一标识符&quot; class=&quot;对应的类&quot; init-method=&quot;该bean中的方法名称&quot;&gt;&lt;/bean&gt; 销毁bean时做额外的事情（如释放资源） 方式一：实现Spring提供的DisposableBean接口完成回调 123public interface DisposableBean &#123; void destroy() throws Exception;&#125; 方式二：&lt;bean&gt;中定义创建时调用的方法&lt;bean id=&quot;唯一标识符&quot; class=&quot;对应的类&quot; destroy-method=&quot;该bean中的方法名称&quot;&gt;&lt;/bean&gt; 依赖注入依赖注入的条件是： 定义一个接口 实现该接口 以接口为基础注入 依赖注入的方式 基于构造函数注入（强依赖通过该方式注入） 基于Setter方法注入（可选依赖通过该方式注入） 依赖注入的类型 基本数据类型 集合 Bean 配置文件 自动装配 自动装配就是让Spring自动满足bean依赖的一种方式，会在Spring的applicationContext中寻找匹配某个bean的需求的其他bean。如果有多个bean能满足依赖关系，Spring会抛出异常：表明没有指定哪个bean进行自动装配。 XML方式代码独立，但是繁琐 Annotation方式简洁，但是代码耦合 @Valueproperties注入 @Autowired(Spring提供) / @Resource(Java提供)自动装配依赖的对象（如果后续项目想去除Spring IoC，建议使用@Resource）如果没有匹配的bean，那么在applicationContext创建的时候，Spring会抛出异常，为了避免异常，可以将@Autowired的required属性设为false。例：1234@Autowired(required=false)public CDPlayer(CompactDisc cd)&#123; this.cd = cd&#125; 注释Annotation简洁，但是代码耦合 如果想使用Annotation，需要在 IoC相关的XML配置文件中，添加如下内容：&lt;context:component-scan base-package=&quot;包名，搜索相关annotation的范围&quot; /&gt; 以下内容，在Java类中添加： @Component定义Bean @Value属性注入 @Autowired(Spring提供) / @Resource(Java提供)自动装配依赖的对象（如果后续项目想去除Spring IoC，建议使用@Resource） @PostConstruct&amp;@PreDestroy生命周期回调","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"https://motainzhang.com/categories/Java-Web/"},{"name":"Spring框架","slug":"Java-Web/Spring框架","permalink":"https://motainzhang.com/categories/Java-Web/Spring框架/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://motainzhang.com/tags/Spring/"},{"name":"IoC","slug":"IoC","permalink":"https://motainzhang.com/tags/IoC/"},{"name":"Bean","slug":"Bean","permalink":"https://motainzhang.com/tags/Bean/"},{"name":"依赖注入","slug":"依赖注入","permalink":"https://motainzhang.com/tags/依赖注入/"}]},{"title":"事务的简单总结","slug":"事务的简单总结","date":"2018-05-11T18:19:32.000Z","updated":"2019-10-18T03:34:00.262Z","comments":true,"path":"2018/05/11/事务的简单总结/","link":"","permalink":"https://motainzhang.com/2018/05/11/事务的简单总结/","excerpt":"","text":"什么是事务事务是并发控制的基本单元，指作为单个逻辑工作单元执行的一系列操作，而这些逻辑工作单元需要满足ACID特性。所谓ACID: Automicity(原子性)：事务包含的所有操作，要么全部完成，要么全部不完成。 Consistency(一致性)：事务执行前后，数据必须处于一致的状态。 Isolation(隔离性)：一个事务内部的操作及使用的数据对并发的其他事务是隔离的。 Durability(持久性)：一个事务一旦提交成功，则事务对数据的改变永久生效。 JDBC进行事务管理Connection对象的相关方法： setAutoCommit() commit() rollback() … 事务并发执行可能会导致的异常 脏读： 读取一个事务未提交的更新。 不可重复读：同一个事务中两次读取相同的记录，结果（值）不一样。 幻读：两次读取的结果包含的行记录数不一样。 事务的隔离级别 read uncommitted(读未提交)：允许出现脏读 read committed（读提交）：不允许脏读，允许不可重复读 repeatable read（重复读）：不允许不可重复读，允许幻读 serializable（串行化）：最高的事务隔离级别，不允许幻读，并发控制最严格，数据都串行执行。 MySQL默认的事务隔离级别是repeatable read（重复读）。 事务隔离级别越高，数据库性能越差，编程难度越低。 查看/设置 隔离级别Connection对象的getTransactionIsolation()和setTransactionIsolation() 死锁分析与解决… Spring进行事务管理优点： 统一的事务编程模型（不论底层的事务管理是JDBC还是Hibernate） 提供了编程式事务和声明式事务（通过AOP实现）两种方式 Spring对事务管理抽象出了一个PlatformTransactionManager接口：1234567public interface PlatformTransactionManager &#123; TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException; void commit(TransactionStatus status) throws TransactionException; void rollback(TransactionStatus status) throws TransactionException;&#125; PlatformTransactionManager接口有两个具体实现： DataSourceTransactionManager(JDBC) HibernateTransactionManager(Hibernate) 底层实现不同，但是接口一致 TransactionDefinition 事务的定义 getName()：获取事务名称 getIsolationLevel()：获取隔离级别 getPropagationBehavior()：获取传播行为 getTimeout()：获取超时时间 isReadOnly()：事务是否只读(Hiberate会用到这个属性) TransactionStatus 事务的状态 isNewTransaction()：是否是新事务 hasSavepoint()：是否有savepoint（诊断，NESTED） isCompleted()：是否已完成 isRollbackOnly()：事务结果是否是rollback-only setRollbackOnly()：设置事务为rollback-only 隔离级别 ISOLATION_READ_UNCOMMITTED：读未提交 ISOLATION_READ_COMMITTED：读提交 ISOLATION_REPEATABLE_READ：重复读 ISOLATION_SERIALIZABLE：串行化 ISOLATION_DEFAULT：默认（根据底层的事务管理是JDBC还是Hibernate而不同） 函数的传播行为 PROPAGATION_MANDATORY必须在一个事务中运行，不存在则抛异常（即运行该函数之前，已有事务） PROPAGATION_NEVER不应该在事务中运行，存在则抛异常（如果调用该函数是，已有事务，就抛出异常） PROPAGATION_NOT_SUPPORTED不应该在事务中运行，如果存在事务则将事务挂起 PROPAGATION_SUPPORTS不需要事务，已有事务则在事务中执行 PROPAGATION_REQUIRED必须在事务中执行，如果不存在事务，启动新事务。内部事务会影响外部事务（内部事务如果抛出异常，外部事务也将无法提交）。 PROPAGATION_NESTED必须在事务中执行，如果不存在，启动新事务。事物之间相互不影响（savepoints）。 PROPAGATION_REQUIRES_NEW必须在新事务中执行，已有事务则挂起当前事务。 声明式事务12345678910&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" ... xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\" ... http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt; ...&lt;/beans&gt; 定义事务管理器123&lt;bean id=\"txManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt;&lt;/bean&gt; 定义事务Advice123456&lt;tx:advice id=\"txAdvice\" transaction-manager=\"txManager\"&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"get*\" read-only=\"true\" /&gt; &lt;tx:method name=\"*\" /&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; 其中，子标签&lt;tx:method&gt;有如下属性 name：匹配的函数名称，支持*匹配 propagation：事务传播行为 isolation：事务隔离级别 timeout：超时 read-only：是否只读事务 rollback-for：触发回滚的异常，,分隔 no-rollback-for：不触发回滚的异常，,分隔 定义Pointcut在aop的配置标签中定义1234&lt;aop:config&gt; &lt;aop:pointcut id=\"\" expression=\"execute.....\" /&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"上一行定义的id\"/&gt;&lt;/aop:config&gt; 除了XML声明，可以通过@Transactional声明事务XML配置文件中添加如下内容：1&lt;tx:annotation-driven transaction-manager=\"txManager\" /&gt; 12@Transactional(propagation = Propagation.REQUIRED, rollbackFor = Exception.class)public ....()&#123;...&#125;//被声明为事务的具体函数 在@Transactional后边括号中可以填写的内容： value：使用的TransactionManager propagation：事务传播行为 isolation：事务隔离级别 timeout：超时 readOnly：是否只读事务 rollbackFor：触发回滚的异常类对象数组 rollbackForClassName：触发回滚的异常类名称数组 noRollbackFor：不触发回滚的异常类对象数组 noRollbackForClassName：不触发回滚的异常类名称数组 编程式事务两种方式： TransactionTemplate PlatformTransactionManager的实现 方式一：TransactionTemplate1.定义TransactionTemplate123456789public class SimpleService implements Service &#123; private final TransactionTemplate transactionTemplate; public SimpleService(PlatformTransactionManager transactionManager) &#123; transactionTemplate = new TransactionTemplate(transactionManager); transactionTemplate.setIsolationLevel(TransactionDefinition.ISOLATION_READ_UNCOMMITED); transactionTemplate.setTimeout(30); &#125;&#125; 使用TransactionTemplate1234567public Object someMethod() &#123; return transactionTemplate.execute(new TransactionCallback() &#123; public Object doInTransaction(TransactionStatus status) &#123; ... &#125; );&#125; … 方式二： PlatformTransactionManager的实现123456789101112DefaultTransactionDefinition def = new DefaultTransactionDefinition();def.setName(\"someTxName\");def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);TransactionStatus status = txManager.getTransaction(def);try &#123; //do some transaction logic&#125; catch(MyException ex) &#123; txManager.rollback(status); throw ex;&#125;txManager.commit(status); MyBatis和Spring整合之后，如何使用事务管理 代码中无需显式地指定事务的配置。底层的TransactionManager跟MyBatis的SQL操作无缝整合，无需额外的声明。可以直接使用事务管理的功能(同样支持声明式事务和编程式事务)。","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"https://motainzhang.com/categories/Java-Web/"},{"name":"事务","slug":"Java-Web/事务","permalink":"https://motainzhang.com/categories/Java-Web/事务/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://motainzhang.com/tags/Spring/"},{"name":"JDBC","slug":"JDBC","permalink":"https://motainzhang.com/tags/JDBC/"},{"name":"MyBatis","slug":"MyBatis","permalink":"https://motainzhang.com/tags/MyBatis/"},{"name":"transaction","slug":"transaction","permalink":"https://motainzhang.com/tags/transaction/"},{"name":"隔离级别","slug":"隔离级别","permalink":"https://motainzhang.com/tags/隔离级别/"},{"name":"死锁","slug":"死锁","permalink":"https://motainzhang.com/tags/死锁/"}]},{"title":"数据库连接池的简单总结","slug":"数据库连接池的简单总结","date":"2018-05-11T18:16:22.000Z","updated":"2019-10-18T03:34:00.262Z","comments":true,"path":"2018/05/11/数据库连接池的简单总结/","link":"","permalink":"https://motainzhang.com/2018/05/11/数据库连接池的简单总结/","excerpt":"","text":"应用程序所在服务器 与 MySQL数据库 进行连接 数据库的访问是多线程的，为了实现连接的复用，从创建数据库连接转变为租借连接，就需要连接池。 需要设置最大连接数限制，保证MySQL服务器资源没有被占用完。如果超出最大连接数，会抛出too many connections异常。但是对于应用程序来说： MySQL直接抛出异常对Java程序的处理不够友好，Java程序必须捕获这些异常并处理。 应该在数据库访问客户端时就实现限流，让数据库连接有序可控地被线程使用，多一种保护手段。 因此，在Java程序中就要实现业务线程排队获取数据库连接。限制同时获得数据库连接的线程数，起到限流、保护后端数据库的作用。 连接池 本质上是Jar包，介于Java应用程序和JDBC数据库物理连接之间，负责帮助应用程序管理JDBC连接。 通过连接池暴露的接口，业务程序可以获取数据库连接；使用完毕后，可以将数据库连接归还给连接池，供下一线程使用。 在连接池中，JDBC连接不足时，会自动创建连接；空闲连接过多时，会自动销毁连接。在多个线程同时获得数据库连接时，提供排队等待的功能，保证应用程序有序地获得数据库连接。 DBCP连接池DBCP是Tomcat所使用的连接池组件，包含三个Jar包：commons-dbcp.jar、commons-pool.jar、commons-logging.jar。 在Maven搭建的项目的pom.xml添加相关Jar包的依赖即可使用连接池提供的相关功能。 创建连接池对象创建BasicDataSource对象，并通过setDriverClassName(DRIVER_NAME)、setURL(DB_URL)、setUsername(USER_NAME)、setPassWord(PASSWORD)方法，配置具体连接的数据库信息。 获取数据库连接通过BasicDataSource对象的getConnection()方法，租借数据库连接，访问后端数据库。 释放数据库连接调用Connection的close()方法（DBCP的实现重写了close方法，将销毁连接的逻辑改成将连接归还连接池） 123456789101112131415161718192021222324252627282930313233343536373839...public static void dbPoolInit() &#123; ds = new BasicDataSource();//创建连接池对象 ds.setUrl(DB_URL); ds.setDriverClassName(DRIVER_NAME); ds.setUsername(DB_USER_NAME); ds.setPassword(DB_PASSWORD);&#125;public void dbPoolTest(String name) &#123; Connection conn = null; PreparedStatement ptmt = null; ResultSet rs = null; try &#123; conn = ds.getConnection(); ptmt = conn.prepareStatement(\"SELECT * FROM user WHERE name=?\");//参数格式化的SQL语句 ptmt.setString(1, name);//根据参数的顺序（从1开始，依次排序），设置参数。根据参数类型，还有setInt()等方法。 rs = stmt.executeQuery(); while(rs.next()) &#123; System.out.println(rs.getString(\"ProductName\"));//获取数据库对应列的内容 System.out.println(rs.getInt(\"Inventory\")); &#125; &#125;catch(SQLException e)&#123; e.printStackTrace(); &#125;finally&#123; try &#123; if (conn != null) conn.close(); if (stmt != null) stmt.close(); if (rs != null) rs.close(); &#125; catch (SQLException e) &#123; // 忽略 &#125; &#125;&#125;... 高级配置BasicDataSource对象的以下方法： setInitialSize(int size) 预置一定数量的数据库连接，提高第一次访问数据库的速度 setMaxTotal(int maxTotal) 设置客户端最大连接数，起到限流保护数据库的作用 setMaxWaitMillis() 设置最大等待时间，如果超过该时间，应用程序得到SQLException异常 setMaxIdle() 设置空闲连接数，减少资源损耗 setMinIdle() 保证连接池有足够的连接供租借 为了避免频繁地创建销毁连接，建议setMaxIdle()和setMinIdle()设为相同值。 DBCP定期检查MySQL会默认关闭空闲时间超过8小时的数据库连接。但是客户端不知道该情况，为了避免被关闭的连接被租借，从而导致异常。定期对连接池中连接的空闲时间进行检查，在服务端关闭连接之前，保证连接被销毁并补充新的连接，让用户租借的连接都是有效的。 BasicDataSource对象的以下方法： setTestWhileIdle(True) 开启连接的空闲时间检查 setMinEvicableIdleTimeMillis() 销毁连接的最小空闲时间 setTimeBetweenEvictionRunsMillis() 检查运行时的时间间隔","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"https://motainzhang.com/categories/Java-Web/"},{"name":"数据库连接","slug":"Java-Web/数据库连接","permalink":"https://motainzhang.com/categories/Java-Web/数据库连接/"}],"tags":[{"name":"数据库连接","slug":"数据库连接","permalink":"https://motainzhang.com/tags/数据库连接/"},{"name":"DBCP","slug":"DBCP","permalink":"https://motainzhang.com/tags/DBCP/"}]},{"title":"请求转发与重定向","slug":"请求转发与重定向","date":"2018-05-10T20:42:40.000Z","updated":"2019-10-18T03:34:00.262Z","comments":true,"path":"2018/05/10/请求转发与重定向/","link":"","permalink":"https://motainzhang.com/2018/05/10/请求转发与重定向/","excerpt":"","text":"请求转发请求转发就是将当前的HttpServletRequest和HttpServletResponse对象交给指定的web组件处理。对客户端来说，是一次请求，一次响应，浏览器的URL不变。 请求转发的步骤 获取请求转发对象即获取RequestDispatcher类的对象（由Servlet容器创建，封装由路径所标识的服务器资源）。获取请求转发对象有两种方式： 通过HTTPServletRequest对象获取:RequestDispatcher rd = request.getRequestDispatcher(&quot;绝对路径/相对路径&quot;); 通过ServleContext对象获取:RequestDispatcher rd = this.getServletContext().getNamedDispatcher(&quot;servlet-name&quot;);或者RequestDispatcher rd = this.getServletContext().getRequestDispatcher(&quot;绝对路径&quot;); 调用转发对象的forward(HttpServletRequest req, HttpServletResponse resp)方法 请求重定向请求重定向就是通过HttpServletResponse对象发送给客户端一个新的URL地址，让其重新请求。对客户端来说，是两次请求，两次响应。 请求重定向的方法：resp.sendRedirect(&quot;绝对路径/相对路径&quot;); Spring MVC的Controller如何处理请求转发与重定向","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"https://motainzhang.com/categories/Java-Web/"},{"name":"Servlet","slug":"Java-Web/Servlet","permalink":"https://motainzhang.com/categories/Java-Web/Servlet/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"https://motainzhang.com/tags/Servlet/"},{"name":"Controller","slug":"Controller","permalink":"https://motainzhang.com/tags/Controller/"}]},{"title":"Cookie和Session","slug":"Cookie和Session","date":"2018-05-10T15:47:04.000Z","updated":"2019-10-18T03:34:00.262Z","comments":true,"path":"2018/05/10/Cookie和Session/","link":"","permalink":"https://motainzhang.com/2018/05/10/Cookie和Session/","excerpt":"","text":"Cookie和HttpSession是什么Cookie和HttpSession是两种会话数据的保存方式。两者具体的类封装在javax.servlet.http中，servlet-api.jar是需要额外加载的Jar包,Tomcat安装目录下含有该Jar包。 Cookie的特性及方法 存储位置存储在客户端 生命周期默认会话结束后消失（存于内存中）；通过setMaxAge(int time)可以设置cookie的有效期（单位是s，存到硬盘）。 缺陷大小和数量限制：一般每个站点大约能保存20个cookie，大小限制在4k以内。数据安全性问题：http请求中的cookie是明文传递的。 相关方法 12345678910String userName = request.getParameter(\"userName\");Cookie userNameCookie = new Cookie(\"userName\", userName);userNameCookie.setMaxAge(10*60)response.addCookie(userNameCookie);Cookie[] cookies = request.getCookies();for(Cookie cookie : cookies) &#123; String name = cookie.getName(); String value = cookie.getValue();&#125; HttpSession的特性 存储位置保存于服务端。 生命周期 有效期30min，可以通过两种方式设置有效期： setMaxInactiveTnterval(int time)，单位是s 通过部署描述符配置session有效期,单位是min123&lt;session&gt; &lt;session-timeout&gt;time&lt;/session-timeout&gt;&lt;/session&gt; 还可以通过HttpSession的invalidate()方法，手动使session失效。 相关方法 1234567891011String password = request.getParameter(\"password\");HttpSession session = request.getSession();String name = (String)session.getAttribute(\"userName\");session.setMaxInactiveTnterval(30*60);session.setAttribute(\"password\", password);session.removeAttribute(\"password\");session.invalidate();","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"https://motainzhang.com/categories/Java-Web/"},{"name":"Servlet","slug":"Java-Web/Servlet","permalink":"https://motainzhang.com/categories/Java-Web/Servlet/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"https://motainzhang.com/tags/Servlet/"},{"name":"Cookie","slug":"Cookie","permalink":"https://motainzhang.com/tags/Cookie/"},{"name":"Session","slug":"Session","permalink":"https://motainzhang.com/tags/Session/"}]},{"title":"使用IDEA+Maven进行Java Web开发的操作流程","slug":"使用IDEA-Maven进行Java-Web开发的操作流程","date":"2018-05-08T00:44:17.000Z","updated":"2019-10-18T03:34:00.262Z","comments":true,"path":"2018/05/08/使用IDEA-Maven进行Java-Web开发的操作流程/","link":"","permalink":"https://motainzhang.com/2018/05/08/使用IDEA-Maven进行Java-Web开发的操作流程/","excerpt":"","text":"File → New → Project... 接着直接next → 自定义项目名称和项目存放位置 → finish 创建好基本框架后，IDEA会提示maven project need to be imported。选择Enable Auto-Import（之后对pom.xml添加新的依赖，IDEA会自动下载相关依赖包）。 创建源代码目录 maven web项目默认没有java源代码目录，需要手动创建，并设置其为源代码目录：右键main目录-&gt; New-&gt;Directory-&gt;输入java-&gt;右键java-&gt;Mark Directory as-&gt; Sources Root这样就创建了存放java源文件的目录。 创建resources目录在项目的 src → main目录下创建resources目录，并Mark Directory as → Resources Root 配置Maven的Tomcat插件eclipse配置Maven的Tomcat插件 先安装maven插件：导航栏 help → Install New Software… → 搜索 m2eclipse,选中并下载安装即可 右键项目 -&gt; Run As -&gt; Maven build(已有配置，直接运行)/Maven build...（新建配置） 填写项目名称Name、项目所在目录Base directory、Goals栏填写tomcat7:run；勾选Skip Tests（加快启动速度），Apply即可。 IDEA配置Maven的Tomcat插件 界面右上角select Run/Debug Configuration下拉菜单 -&gt; edit configurations... 点击 弹出窗口的左上角+号 -&gt; Maven 填写项目名称Name、项目所在目录Working directory、Command line栏填写tomcat7:run，Apply即可。 IDEA中的skip tests在界面右侧设置 -&gt; Maven Projects -&gt; 单击闪电标志即可 pom.xml中添加tomcat插件的相关配置12345678910111213141516&lt;build&gt; &lt;plugins&gt; ... &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt; &lt;finalName&gt;项目名称&lt;/finalName&gt; &lt;server&gt;tomcat&lt;/server&gt; &lt;/configuration&gt; &lt;/plugin&gt; ... &lt;/plugins&gt;&lt;/build&gt; pom.xml中添加compiler插件的相关配置 为什么需要配置？两个原因： 如果不配置，就会用maven-compiler-plugin默认的jdk版本来进行处理，容易出现版本不匹配的问题。 一般而言，target与source需要保持一致。但是，有时候为了让JavaWeb程序能在其他环境中运行，会将source和target设为要运行的环境中的jdk版本。（项目源代码中不能使用target的jdk不支持的语法，否则编译无法通过) 12345678910&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.7.0&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt;&lt;/plugin&gt;","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"https://motainzhang.com/categories/Java-Web/"},{"name":"IDE","slug":"Java-Web/IDE","permalink":"https://motainzhang.com/categories/Java-Web/IDE/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://motainzhang.com/tags/IDEA/"}]},{"title":"Servlet的简单总结","slug":"Servlet的简单总结","date":"2018-05-07T21:59:33.000Z","updated":"2019-10-18T03:34:00.262Z","comments":true,"path":"2018/05/07/Servlet的简单总结/","link":"","permalink":"https://motainzhang.com/2018/05/07/Servlet的简单总结/","excerpt":"","text":"Servlet是什么Servlet（Server + Applet），一个Servlet就是一个Java类，并提供 基于请求-响应模式 的Web服务。 要使用servlet需要添加javax.servlet-apiJar包。 Servlet的处理流程 接收客户端的HTTP请求路径及请求内容 根据web.xml（属于web应用程序的一部分，部署描述符），找到请求路径对应的Servlet 123456789...&lt;servlet&gt; &lt;servlet-name&gt;servlet名称（最好与类名相同）&lt;/servlet-name&gt; &lt;servlet-class&gt;类路径&lt;/servlet-calss&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;与&lt;servlet&gt;元素中的该元素内容相同&lt;/servlet-name&gt; &lt;url-pattern&gt;映射路径&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 将请求转发给Servlet对应的service方法（会传递HttpServletRequest对象和HttpServletResponse对象作为方法参数） service方法根据请求是 get/post/… 转发给 doGet/doPost方法处理 通过HttpResponse对象，将响应返回给客户端 Servlet生命周期init → service（doGet、doPost…） → destroy 管理Servlet的配置信息通过ServletConfig对象1234567891011121314...&lt;servlet&gt; &lt;init-param&gt; &lt;param-name&gt;参数名1&lt;/param-name&gt; &lt;param-value&gt;参数值1&lt;/param-value&gt; &lt;/init-param&gt; ... &lt;servlet-name&gt;servlet名称（最好与类名相同）&lt;/servlet-name&gt; &lt;servlet-class&gt;类名&lt;/servlet-calss&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;与&lt;servlet&gt;元素中的该元素内容相同&lt;/servlet-name&gt; &lt;url-pattern&gt;映射路径&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 每个Servlet支持设置多个&lt;init-param&gt;,Servlet初始化过程中，&lt;init-param&gt;参数将被封装到ServletConfig对象中。在Servlet中，通过调用ServletConfig对象，就可以利用配置信息：12ServletConfig config = this.getServletConfig();String value1 = config.getParameter(\"参数名1\");//根据查找参数名，获取参数值 通过ServletContext共享Servlet的配置信息Servlet容器在启动时，会为每个Web应用创建一个对应的ServletContext对象（代表当前的Web应用）。12345&lt;context-param&gt; &lt;param-name&gt;参数名1&lt;/param-name&gt; &lt;param-value&gt;参数值1&lt;/param-value&gt;&lt;/context-param&gt;... &lt;context-param&gt;是在各个具体的&lt;servlet&gt;元素之外的，同样可以设置多个&lt;context-param&gt;。在任意具体的Servlet中，通过调用ServletContext对象，就可以利用配置信息：12ServletContext context = this.getServletContext();String globalValue1 = context.getInitParameter(\"参数名\"); 通过ServletContext的属性（attribute）实现不同Servlet之间的通信实现不知道，无法预先配置的信息，应该如何共享？（比如将购物车中的商品共享给结算页面） 在具体的Serlvet中，通过ServletContext对象的属性（attribute）设置希望共享的信息：1234ServletContext context = this.getServletContext();context.setAttribute(\"属性名\",\"属性值\");String attribute = (String) context.getAttribute(\"属性名\");//getAttribute的返回值是Object类型context.removeAttribute(\"属性名\"); 读取外部资源配置文件信息通过ServletContext的方法读取 getResource(“外部资源配置文件的路径”)1234567ServletContext context = this.getServletContext();URL url = context.getResource(\"外部资源配置文件的相对路径\");InputStream in = url.openStream();/**利用编写的一个工具类，读取属性值String property1 = GeneralUtil.getProperty(\"属性名\", in);*/ getResourceAsStream(“外部资源配置文件的路径”)1234567ServletContext context = this.getServletContext();InputStream in = context.getResourceAsStream(\"外部资源配置文件的相对路径\");/**利用编写的一个工具类，读取属性值...*/ getRealPath(“外部资源配置文件的相对路径”)获取外部资源配置文件的绝对路径1String realPath = context.getRealPath(\"外部资源配置文件的相对路径\"); HttpServletRequest和HttpServletResponse的常用方法HttpServletRequest类中常用方法 getMethod() 返回所要求的HTTP方法，比如GET POST 或者PUT等； getHeader(String name) 返回指明的HTTP头部信息； getCookies() 返回客户端随请求一起发送的所有Cookies的一个数组； getSession() 返回与本请求相关的当前Session； 其它还有getRequestURL() getRemoteUser() 等。 HttpServletResponse类中常用方法 addCookie(Cookie cookie) 在回应当中加入指定的cookie； getHeader(String name) 用给出的name变量获得回应头不的值； getStatus() 获得本回复的当前状态码； 其它还有一些get或者add开头的方法。 Cookie和Session 请求转发与重定向SpringMVC框架用DispatcherServlet提供web服务","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"https://motainzhang.com/categories/Java-Web/"},{"name":"Servlet","slug":"Java-Web/Servlet","permalink":"https://motainzhang.com/categories/Java-Web/Servlet/"}],"tags":[{"name":"Servlet","slug":"Servlet","permalink":"https://motainzhang.com/tags/Servlet/"}]},{"title":"迭代器","slug":"迭代器","date":"2018-05-03T16:57:47.000Z","updated":"2019-10-18T03:34:00.262Z","comments":true,"path":"2018/05/03/迭代器/","link":"","permalink":"https://motainzhang.com/2018/05/03/迭代器/","excerpt":"","text":"迭代器是一个实现了hasNext()和next()方法的类的对象，由以下接口定义： 12345public interface Iterator&lt;Item&gt; &#123; boolean hasNext(); Item next(); void remove();&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://motainzhang.com/categories/Java/"}],"tags":[{"name":"Iterator","slug":"Iterator","permalink":"https://motainzhang.com/tags/Iterator/"}]},{"title":"读书笔记","slug":"读书笔记","date":"2018-04-26T16:07:20.000Z","updated":"2019-10-18T03:34:00.262Z","comments":true,"path":"2018/04/26/读书笔记/","link":"","permalink":"https://motainzhang.com/2018/04/26/读书笔记/","excerpt":"","text":"HTML5权威指南 数据结构 Java核心技术","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://motainzhang.com/categories/读书笔记/"}],"tags":[]},{"title":"上传图片的压缩","slug":"上传图片的压缩","date":"2017-05-31T17:51:21.000Z","updated":"2019-10-18T03:34:00.262Z","comments":true,"path":"2017/05/31/上传图片的压缩/","link":"","permalink":"https://motainzhang.com/2017/05/31/上传图片的压缩/","excerpt":"","text":"上传图片的裁剪、压缩，前端后端都可以实现。 前端实现的优势：用户实时预览裁切结果，用户体验好。 参考：选取图片裁剪并上传功能的实现 后端实现图片的压缩处理Thumbnailator，一个google使用的开源的工具类。 在pom.xml添加依赖：12345&lt;dependency&gt; &lt;groupId&gt;net.coobird&lt;/groupId&gt; &lt;artifactId&gt;thumbnailator&lt;/artifactId&gt; &lt;version&gt;0.4.8&lt;/version&gt;&lt;/dependency&gt; 指定大小进行缩放Thumbnailator使用简介","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"https://motainzhang.com/categories/Java-Web/"},{"name":"Spring MVC框架","slug":"Java-Web/Spring-MVC框架","permalink":"https://motainzhang.com/categories/Java-Web/Spring-MVC框架/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://motainzhang.com/tags/jQuery/"},{"name":"jcrop","slug":"jcrop","permalink":"https://motainzhang.com/tags/jcrop/"},{"name":"thumbnailator","slug":"thumbnailator","permalink":"https://motainzhang.com/tags/thumbnailator/"},{"name":"图片处理","slug":"图片处理","permalink":"https://motainzhang.com/tags/图片处理/"}]},{"title":"为什么有的JSP页面要设置session=false的指令","slug":"为什么有的JSP页面要设置session-false的指令","date":"2017-05-22T19:51:13.000Z","updated":"2019-10-18T03:34:00.262Z","comments":true,"path":"2017/05/22/为什么有的JSP页面要设置session-false的指令/","link":"","permalink":"https://motainzhang.com/2017/05/22/为什么有的JSP页面要设置session-false的指令/","excerpt":"","text":"一个原因是性能和记忆。如果你有一个页面不需要参与会话(比如说，一个about.jsp或faq.jsp)，那么在一个会话中涉及每个JSP的默认行为会增加创建一个新的会话对象的开销(如果尚不存在)和增加的内存使用，导致更多的session对象驻留在堆上。 当用户不继续浏览，而是在查看一个页面之后立即离开网站，这种效果将被极大地夸大。容器给用户创建的新的会话对象，将永远不会再次使用，并将最终被垃圾收集后超时。创建过多的session对象，内存使用和垃圾回收，而不给你任何真正的价值。","categories":[{"name":"解惑","slug":"解惑","permalink":"https://motainzhang.com/categories/解惑/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"https://motainzhang.com/tags/JSP/"},{"name":"session=false","slug":"session-false","permalink":"https://motainzhang.com/tags/session-false/"}]},{"title":"eclipse下，已引入jar包，仍然ClassNOtFoundException的解决方式","slug":"eclipse下，已引入jar包，仍然ClassNOtFoundException的解决方式","date":"2017-05-19T00:35:28.000Z","updated":"2019-10-18T03:34:00.262Z","comments":true,"path":"2017/05/19/eclipse下，已引入jar包，仍然ClassNOtFoundException的解决方式/","link":"","permalink":"https://motainzhang.com/2017/05/19/eclipse下，已引入jar包，仍然ClassNOtFoundException的解决方式/","excerpt":"","text":"原因eclipse编译项目的时候是根据build path的，如果不用eclipse来发布项目的话，就可能找不到jar包。tomcat运行项目首先是在它自己的公共lib里找jar，如果找不到的话就会去项目的WEB-INF/lib目录找，如果找不到就报错。 build path：可以说是引用； WEB-INF/lib：可以说是固定在一个地方； 有时候即使操作无误，eclipse也可能仍然这样，通过导航栏project -&gt; clean可以正常显示不报错。","categories":[{"name":"杀死exception","slug":"杀死exception","permalink":"https://motainzhang.com/categories/杀死exception/"}],"tags":[{"name":"eclipse","slug":"eclipse","permalink":"https://motainzhang.com/tags/eclipse/"}]},{"title":"Tomcat部署时war和war exploded的区别","slug":"Tomcat部署时war和war-exploded的区别","date":"2017-05-18T17:50:44.000Z","updated":"2019-10-18T03:34:00.262Z","comments":true,"path":"2017/05/18/Tomcat部署时war和war-exploded的区别/","link":"","permalink":"https://motainzhang.com/2017/05/18/Tomcat部署时war和war-exploded的区别/","excerpt":"","text":"war（发布模式）将WEB工程以包的形式上传到服务器 war exploded（开发时使用）将WEB工程以当前文件夹的位置关系上传到服务器，即直接把 文件夹、jsp页面 、classes等内容 移到 Tomcat部署文件夹里，进行加载部署，支持热部署（见参考链接）。 两种方式获取contextPath的绝对路径是不同的获取绝对路径的方式：String contextPath = request.getSession().getServletContext().getRealPath(&quot;/&quot;); war方式得到的绝对路径：本地安装的tomcat目录下的webapps\\ROOT\\ war exploded方式得到的绝对路径：项目所在目录下的target\\项目名称\\ 参考：war和war exploded的区别","categories":[{"name":"解惑","slug":"解惑","permalink":"https://motainzhang.com/categories/解惑/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"https://motainzhang.com/tags/Tomcat/"},{"name":"war","slug":"war","permalink":"https://motainzhang.com/tags/war/"},{"name":"war exploded","slug":"war-exploded","permalink":"https://motainzhang.com/tags/war-exploded/"},{"name":"IDEA","slug":"IDEA","permalink":"https://motainzhang.com/tags/IDEA/"}]},{"title":"文件、图片等数据的上传","slug":"文件、图片等数据的上传","date":"2017-05-18T17:36:14.000Z","updated":"2019-10-18T03:34:00.262Z","comments":true,"path":"2017/05/18/文件、图片等数据的上传/","link":"","permalink":"https://motainzhang.com/2017/05/18/文件、图片等数据的上传/","excerpt":"","text":"multipart文件、图片等内容的上传，multipart可以用二进制的形式传输数据。 配置multipart解析器 DispatcherServlet没有实现任何解析multipart请求数据的功能。它将该任务委托给了Spring中的MultipartResolver策略接口的实现，通过实现类来解析multipart请求的内容。Spring内置了两个相关的实现： StandardServletMultipartResolver(依赖于Serlvet3.0对multipart请求的支持，始于Spring3.1，优选方案) CommonsMultipartResolver(使用Jakarta Commons FileUpload解析multipart请求，需要依赖commons-fileupload) StandardServletMultipartResolver 兼容Servlet3.0的standardServletMultipartResolver没有构造函数，也没有需要设置的属性，只要声明bean即可。也因此，需要在Servlet中指定multipart的配置。如果没有指定文件上传的过程中，写入临时文件的路径，StandardServletMultipartResolver就无法正常工作，必须在web.xml或Servlet初始化类中，将multipart的具体细节作为DispatcherServlet配置的一部分。 通过xml配置文件的形式配置在servlet的xml配置文件需要添加的内容：12&lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.support.StandardServletMultipartResolver\"/&gt; bean的id必须为multipartResolver,StandardServletMultipartResolver的相关配置都写在web.xml中 multipart的相关配置由Servlet自身配置（servlet3.0开始支持，因此web.xml中web-app使用的版本，必须是3.0+）web.xml需要添加的内容：1234567891011121314151617181920212223242526272829&lt;web-app version=\"3.0\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app.xsd\"&gt; ... &lt;servlet&gt; &lt;servlet-name&gt;xxxxx&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; ... &lt;multipart-config&gt; &lt;!-- 运行环境为Tomcat9/maven的tomcat7插件；javax.servlet-api的版本为4.0.1； 配置方式和网上大多数描述出入很大。表现为： 1. file-size-threshold 必须显式指定，否则max-file-size和max-request-size无法生效 2. location 不必显式指定 --&gt; &lt;!-- 上传文件存放的临时文件目录（目录必须已经存在，否则报错）,有默认目录（建议按照默认） --&gt; &lt;location&gt;C:\\Users\\Hunter\\Desktop\\tmp&lt;/location&gt; &lt;!-- 文件的最大大小，单位为字节（Byte）。默认没有限制 --&gt; &lt;max-file-size&gt;1024&lt;/max-file-size&gt; &lt;!-- 请求的最大大小，单位为字节。默认没有限制 --&gt; &lt;max-request-size&gt;4194286&lt;/max-request-size&gt; &lt;!-- 当上传文件的大小 &gt; 这个阈值时将写入到临时目录下(避免内存空间不够)，否则在内存中 --&gt; &lt;file-size-threshold&gt;0&lt;/file-size-threshold&gt; &lt;/multipart-config&gt; &lt;/servlet&gt; ...&lt;/web-app&gt; 如何处理上传内容大小超过max-file-size和max-request-size时的报错？ 当我们把文件写入最终的目录（在具体的Java类中操作）之后，之前的临时文件就不存在了。 处理multipart请求编写控制器方法接收上传的文件，最常见的方式是**在方法参数上添加@RequestPart注解。 CommonsMultipartResolver参考：Spring MVC+Maven 轻松实现上传文件功能多图片上传","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"https://motainzhang.com/categories/Java-Web/"},{"name":"Spring MVC框架","slug":"Java-Web/Spring-MVC框架","permalink":"https://motainzhang.com/categories/Java-Web/Spring-MVC框架/"}],"tags":[{"name":"multipart","slug":"multipart","permalink":"https://motainzhang.com/tags/multipart/"}]},{"title":"File.separator和文件层级分隔符的区别","slug":"File-separator和文件分隔符的区别","date":"2017-05-18T14:47:25.000Z","updated":"2019-10-18T03:34:00.262Z","comments":true,"path":"2017/05/18/File-separator和文件分隔符的区别/","link":"","permalink":"https://motainzhang.com/2017/05/18/File-separator和文件分隔符的区别/","excerpt":"","text":"在windows中的文件分隔符是\\和/都可以；但是在Linux中，文件分隔符只能是/,所以用了\\的程序在Linux下会出问题。 而File.separator是系统默认的文件分割符号，屏蔽了这些系统的区别，用File.separator保证了在任何系统下不会出错。","categories":[{"name":"解惑","slug":"解惑","permalink":"https://motainzhang.com/categories/解惑/"}],"tags":[{"name":"文件层级分隔符","slug":"文件层级分隔符","permalink":"https://motainzhang.com/tags/文件层级分隔符/"}]},{"title":"MyBatis的简单总结","slug":"MyBatis的简单总结","date":"2017-05-11T18:20:08.000Z","updated":"2019-10-18T03:34:00.262Z","comments":true,"path":"2017/05/11/MyBatis的简单总结/","link":"","permalink":"https://motainzhang.com/2017/05/11/MyBatis的简单总结/","excerpt":"","text":"Mybatis是什么面向对象的世界中，数据是对象；关系型数据库中，数据时行列二元表。因此，需要一个中间映射的技术自动地实现 对象—二元表 之间的转换。MyBatis是 支持自定义 SQL、存储过程和高级映射 的持久化ORM框架。 ORMORM(Object/Relation Mapping) 持久化类与数据库表之间的映射关系 对持久化对象的操作自动转换成对关系数据库的操作 关系数据库的每一行映射为一个对象，每一列映射为对象的属性。 MyBatis的功能架构 MyBatis的工作流机制 根据XML文件或者注解 加载SQL语句、参数映射、结果映射到内存 应用程序调用API传入参数和SQL ID MyBatis自动生成SQL语句完成数据库访问，转换执行结果返回应用程序 MyBatis环境搭建所需Jar包： mybatis.jar mysql-connector-java.jar SqlSessionFactory每个MyBatis应用都是基于SqlSessionFactory实例为中心的，通过该实例可以获取 将对象操作转换成数据库sql 的session。 通过创建一个XML配置文件可以完成SqlSessionFactory的配置。该XML文件包含了对MyBatis系统的核心配置，包括 后端连接数据库实例的数据源 和 一个事务管理器（transactionManager，决定事务范围和控制方式）。 1234567891011121314&lt;configuration&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"jdbc\" /&gt; &lt;!-- MyBatis3.0内置连接池，通过 type=\"POOLED\"启用连接池--&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\" /&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/cloud_study\" /&gt; &lt;property name=\"userName\" value=\"root\" /&gt; &lt;property name=\"password\" value=\"123456\" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;/configuration&gt; 如上例所示，&lt;transactionManager&gt;标签中有一个type属性，属性有两种内容： jdbc：表示MyBatis依赖于从数据库源获得的数据库连接（connection）来管理事务的范围，即使用JDBC的提交和回滚。 managed：MyBatis的事务控制交给外部的容器，比如Spring。 Java对象 构造对象 构建接口 两种方式配置对象和SQL语句的映射关系方式一： 在接口中通过 注解 配置12345public interface GetUserInfoAnnotation &#123; @Select(\"SELECT * FROM user WHERE id = #&#123;id&#125;\") public User getUser(int id);&#125; 方式二：创建Java接口和SQL语句映射关系配置文件 XML映射文件： 123456789&lt;mapper namespace=\"包的限定名+对应的接口名称\"&gt; &lt;select id=\"getUser（要与之前构建的接口的方法名一致）\" parameterType=\"int\" resultType=\"包的限定名+之前定义的Java对象的类名称\"&gt; SELECT id, userName, crop FROM user WHERE id=#&#123;id&#125; &lt;/select&gt; &lt;insert id=\"addUser\" parameterType=\"com.micro.profession.mybatis.User\" useGeneratedKeys=\"true\" keyProperty=\"id\"&gt; INSERT INTO user(userName,corp) VALUES(#&#123;userName&#125;,#&#123;corp&#125;) &lt;/insert&gt; 注册 ORM配置文件到 先前的XML配置文件中 12345678&lt;configuration&gt; &lt;environments default=\"development\"&gt; ... &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=\"ORM配置文件的路径\" /&gt; &lt;/mappers&gt; &lt;/configuration&gt; 完成数据库查询……通过注解配置和XML文件配置的 查询方式略有不同 MyBatis的优势和劣势 优势 入门门槛低 更加灵活，SQL优化 劣势 需要自己编写SQL，工作量大 数据库移植性差 用&lt;ResultMap&gt;实现复杂查询resultType和resultMap的区别&lt;ResultMap&gt;用于映射配置文件中，是MyBatis中最重要最强大的元素，可以实现复杂查询结果到复杂对象关联关系的转化。 &lt;constructor&gt;处理关联时使用，用于将结果注入到构造方法中 &lt;idArg&gt;：ID参数，标记结果作为ID可以帮助提高整体效能 &lt;arg&gt;：注入到构造方法的一个普通结果 例：1234567891011&lt;select id=\"getUser\" parameterType=\"int\" resultMap=\"UserMap(与resultMap元素的id一致)\"&gt; SELECT id, userName, corp FROM user WHERE id=#&#123;id&#125;&lt;/select&gt;&lt;resultMap id=\"UserMap\" type=\"com.micro.profession.mybatis.resultMapTest.User\"&gt; &lt;constructor&gt; &lt;idArg column=\"id\" javaType=\"int\" /&gt; &lt;arg column=\"userName\" javaType=\"String\" /&gt; &lt;arg column=\"corp\" javaType=\"String\" /&gt; &lt;/constructor&gt;&lt;/resultMap&gt; 对象所属类的构造方法：12345public User(int id, String userName, String corp) &#123; this.id = id; this.userName = userName; this.corp = corp;&#125; &lt;collection&gt;用于实现一对多的关联，对java对象中的容器进行赋值 &lt;id&gt;：一个ID结果，标记结果作为ID可以帮助提高整体效能 &lt;result&gt;：注入到字段或JavaBean属性的普通结果 例：12345678910111213141516171819&lt;select id=\"getUser\" parameterType=\"int\" resultMap=\"UserMap\"&gt; SELECT u.id AS userId, userName, courseName, corp, c.id AS courseId FROM user u LEFT JOIN userCourse uc ON u.id=uc.user_id LEFT JOIN course c ON c.id=uc.course_id WHERE u.id=#&#123;id&#125;&lt;/select&gt;&lt;resultMap id=\"UserMap\" type=\"com.micro.profession.mybatis.resultMapTest.User\"&gt; &lt;constructor&gt; &lt;idArg column=\"id\" javaType=\"int\" /&gt; &lt;arg column=\"userName\" javaType=\"String\" /&gt; &lt;arg column=\"corp\" javaType=\"String\" /&gt; &lt;/constructor&gt; &lt;collection property=\"courses（需要和Java对象中的容器变量名一致）\" ofType=\"com.micro.profession.mybatis.resultMapTest.Course\"&gt; &lt;id property=\"id（ofType中的变量名）\" column=\"courseId\" /&gt; &lt;result property=\"courseName\" column=\"courseName\" /&gt; &lt;/collection&gt;&lt;/resultMap&gt; 对象所属类： 123456public class User &#123; private int id; private String userName; private String corp; private List&lt;Course&gt; courses;//collection的property值要和该变量名一致 ... &lt;association&gt;用于实现复杂类型之间的关联，如关联的容器之中嵌套着对象 &lt;id&gt;：一个ID结果标记结果作为ID可以提高整体效能 &lt;result&gt;：注入到字段或JavaBean属性的普通结果 1234567891011121314151617181920212223&lt;select id=\"getUser\" parameterType=\"int\" resultMap=\"UserMap\"&gt; SELECT u.id AS userId, userName, courseName, corp, c.id AS courseId FROM user u LEFT JOIN userCourse uc ON u.id = uc.user_id LEFT JOIN course c on c.id = uc.course_id LEFT JOIN teacher ON teacher.id=c.teacher_id WHERE u.id=#&#123;id&#125;&lt;/select&gt;&lt;resultMap id=\"UserMap\" type=\"com.micro.profession.mybatis.resultMapTest.User\"&gt; &lt;constructor&gt; ... &lt;/constructor&gt; &lt;collection property=\"courses\" ofType=\"com.micro.profession.mybatis.resultMapTest.Course\"&gt; &lt;id property=\"id\" column=\"courseId\" /&gt; &lt;result property=\"courseName\" column=\"courseName\" /&gt; &lt;association property=\"teacher\" column=\"teacher_id\" javaType=\"com.micro.profession.mybatis.resultMapTest.Teacher\"&gt; &lt;id property=\"id（javaType中的变量名）\" column=\"teacherId\" /&gt; &lt;result property=\"teacherName（javaType中的变量名）\" column=\"teacherName\" /&gt; &lt;/association&gt; &lt;/collection&gt;&lt;/resultMap&gt; Course类：12345public class Course &#123; private int id; private String courseName; private Teacher teacher;... DataSourceMyBatis3.0内置连接池，SqlSessionFactory的配置中，通过type=&quot;POOLED&quot;即可启用连接池。 1234567891011121314&lt;configuration&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"jdbc\" /&gt; &lt;!-- MyBatis3.0内置连接池，通过 type=\"POOLED\"启用连接池--&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\" /&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/cloud_study\" /&gt; &lt;property name=\"userName\" value=\"root\" /&gt; &lt;property name=\"password\" value=\"123456\" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;/configuration&gt; 数据库连接声明周期 连接池常用配置选项 poolMaximumActiveConnections poolMaximumIdleConnerctions poolMaximumCheckoutTime poolTimeToWait poolPingEnabled poolPingQuery poolPingConnectionsNotUsedFor Spring与MyBatis、数据库连接池的整合所需Jar包： mybatis-spring.jar mybatis.jar mysql-connector-java.jar spring-jdbc.jar(访问mysql基于jdbc的驱动) commons-dbcp2.jar commons-pool2.jar commons-logging.jar 在resources目录下创建存放 数据库连接参数 的文件db.properties文件内容：1234driverClassName=com.mysql.jdbc.Driverurl=数据库地址username=访问数据库的用户名password=访问密码 定义连接池相关的BasicDataSource Bean跟Spring相关的XML配置文件中添加123456&lt;bean id=\"dataSource\" class=\"org.apache.commons.dbcp2.BasicDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"$&#123;driverClassName&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"/&gt;&lt;/bean&gt; Maven项目，application-context.xml、db.properties文件均放置在src/main/resources目录下；Tomcat部署项目，src/main/resources目录下的配置文件默认位置为：{项目名}/WEB-INF/classes，而Spring却在项目根目录下寻找，肯定找不到，因此，需要指定classpath目录下寻找。1&lt;context:property-placeholder location=\"classpath:db.properties\"/&gt; 定义sqlSessionFactoryBean跟Spring相关的XML配置文件中添加123&lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;&lt;/bean&gt; 定义Mapper如前所述,两种方式： 方式一：创建Java接口，在接口中通过 注解 配置需要在Spring相关的XML配置文件中添加如下内容：123456789101112&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" ... xmlns:mybatis=\"http://mybatis.org/schema/mybatis-spring\" xsi:schemaLocation=\" ... http://mybatis.org/schema/mybatis-spring http://mybatis.org/schema/mybatis-spring.xsd\"&gt; ... &lt;mybatis:scan base-package=\"包名，搜索相关annotation的范围\" /&gt; ...&lt;/beans&gt; 方式二：创建Java接口和SQL语句映射关系配置文件与单纯的Mybatis配置不同，-写好XML映射文件之后，需要在Spring相关的XML配置文件中添加bean：1234&lt;bean id=\"UserMapper\" class=\"org.mybatis.spring.mapper.MapperFactoryBean\"&gt; &lt;property name=\"mapperInterface\" value=\"接口的具体包路径\" /&gt; &lt;property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\" /&gt;&lt;/bean&gt; 使用Mapper通过@Autowired 或 @Resource 自动装配 SqlSessionTemplate… MyBatis和Spring整合之后，如何使用事务管理见 事务的简单总结 一文。","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"https://motainzhang.com/categories/Java-Web/"},{"name":"数据库连接","slug":"Java-Web/数据库连接","permalink":"https://motainzhang.com/categories/Java-Web/数据库连接/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://motainzhang.com/tags/MyBatis/"}]},{"title":"web.xml配置详解","slug":"web.xml配置详解","date":"2017-05-08T16:55:55.000Z","updated":"2019-10-18T03:34:00.262Z","comments":true,"path":"2017/05/08/web.xml配置详解/","link":"","permalink":"https://motainzhang.com/2017/05/08/web.xml配置详解/","excerpt":"","text":"web.xml的作用设置web应用程序的组件部署信息。 首页（欢迎页面）设置1234&lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; ...&lt;/welcome-file-list&gt; 可以指定多个&lt;welcome-file&gt;，按顺序加载。 Servlet声明12345678910...&lt;servlet&gt; &lt;servlet-name&gt;servlet名称（最好与类名相同）&lt;/servlet-name&gt; &lt;servlet-class&gt;servlet路径&lt;/servlet-calss&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;与&lt;servlet&gt;元素中的该元素内容相同&lt;/servlet-name&gt; &lt;url-pattern&gt;映射的相对路径&lt;/url-pattern&gt; &lt;url-pattern&gt;支持多个路径&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; Servlet对外映射的路径是相对路径，支持模糊匹配，支持多个路径对应同一个Servlet。 ServletMapping匹配规则优先级从高到低排列 精确路径匹配，完全匹配 最长路径匹配，最长前缀匹配 扩展名匹配 default servlet(映射路径为/) 或者放弃匹配找不到对应的Servlet，报错） ServletConfig配置1234567891011121314...&lt;servlet&gt; &lt;init-param&gt; &lt;param-name&gt;参数名1&lt;/param-name&gt; &lt;param-value&gt;参数值1&lt;/param-value&gt; &lt;/init-param&gt; ... &lt;servlet-name&gt;servlet名称（最好与类名相同）&lt;/servlet-name&gt; &lt;servlet-class&gt;类名&lt;/servlet-calss&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;与&lt;servlet&gt;元素中的该元素内容相同&lt;/servlet-name&gt; &lt;url-pattern&gt;映射路径&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 每个Servlet支持设置多个&lt;init-param&gt;。 ServletContext配置12345&lt;context-param&gt; &lt;param-name&gt;参数名1&lt;/param-name&gt; &lt;param-value&gt;参数值1&lt;/param-value&gt;&lt;/context-param&gt;... &lt;context-param&gt;是在各个具体的&lt;servlet&gt;元素之外的，同样可以设置多个&lt;context-param&gt;。 如果需要在Servlet容器启动时执行操作1234&lt;servlet&gt; &lt;load-on-startup&gt;0&lt;/load-on-startup&gt; &lt;servlet-name&gt;servlet名称（最好与类名相同）&lt;/servlet-name&gt; &lt;servlet-class&gt;servlet路径&lt;/servlet-class&gt; 通过&lt;load-on-startup&gt;元素设置一个值，改变Servlet的默认初始化时间。当值 &gt;= 0时，Servlet容器启动时就会加载该Servlet；当值 &lt; 0时，则在容器第一次请求该Servlet时，才加载ervlet。 如果多个Servlet都设置了该值，数值越小，优先级越高。 如果访问页面不存在（404），如何更友好地显示页面1234&lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/404.html&lt;/location&gt;&lt;/error-page&gt; &lt;error-code&gt;当错误的返回码为设置的值时，跳转到指定的页面位置&lt;location&gt;。更高级的做法，添加&lt;exception-type&gt;元素，用来捕获Java的异常类型，使展示页面更有针对性。 访问公共资源的操作，是打开查看还是下载？1234&lt;mime-mapping&gt; &lt;extension&gt;浏览器要解析的文件的拓展名&lt;/extension&gt; &lt;mime-type&gt;操作的方式&lt;/extension&gt;&lt;/mime-mapping&gt;","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"https://motainzhang.com/categories/Java-Web/"},{"name":"Maven","slug":"Java-Web/Maven","permalink":"https://motainzhang.com/categories/Java-Web/Maven/"}],"tags":[{"name":"web.xml","slug":"web-xml","permalink":"https://motainzhang.com/tags/web-xml/"}]},{"title":"Maven的简单总结","slug":"Maven的简单总结","date":"2017-05-06T22:34:24.000Z","updated":"2019-10-18T03:34:00.262Z","comments":true,"path":"2017/05/06/Maven的简单总结/","link":"","permalink":"https://motainzhang.com/2017/05/06/Maven的简单总结/","excerpt":"","text":"Maven是什么Maven是一个免费、开源的，用Java编写的项目构建和依赖管理工具。 Maven的特点 默认的目录结构 第三方依赖管理 通过配置pom.xml文件，从远程仓库下载相关Jar包。解决了依赖维护问题。 提供了一致的项目构建管理方式 生命周期。减少了构建工作量。 插件式架构，大量的可重用插件 方便地集成于IDE MAVEN的安装及配置 官网下载压缩包，解压到合适文件目录下。 配置环境变量 M2_HOME = 文件目录 添加%M2_HOME%/bin到Path pom.xml的简单介绍pom（project object model,项目对象模型）pom.xml文件就是描述项目用的。 详细介绍见pom.xml配置详解 基本操作命令 命令 作用 mvn archetype:generate 使用模板生成项目 mvn compile 编译源代码 mvn test 单元测试 mvn package 打包项目，Java项目→Jar；Web项目→War mvn deploy 部署，把打包后的项目上传发布到远程仓库 mvn site 生成项目相关的站点、在线文档 mvn clean 清理，删除构建的Jar包、class文件等 mvn install 把打包的目录拷到本地仓库 Tomcat插件本地不需要有专门的tomcat存在，方便进行开发调试。 Tomcat插件配置步骤常见命令 mvn tomcat7:run： 启动一个嵌入的Tomcat实例，与本地安装的Tomcat无关，是根据Tomcat插件嵌入的。 mvn tomcat7:deploy mvn tomcat7:undeploy Maven的生命周期maven有三套独立的生命周期 clean(删除构建的Jar包、class文件等) pre-clean → clean → post-clean site(生成站点文档) pre-site → site → post-site → site-deploy default validate （验证项目是否正确，所需信息是否有缺失） process-resources（将资源文件复制到项目目录下，之后打包用） compile （编译源代码） test （单元测试） package （打包） install （把打包的项目拷到本地仓库下） deploy （把打包的项目上传到远程仓库）","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"https://motainzhang.com/categories/Java-Web/"},{"name":"Maven","slug":"Java-Web/Maven","permalink":"https://motainzhang.com/categories/Java-Web/Maven/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"https://motainzhang.com/tags/Maven/"},{"name":"依赖管理","slug":"依赖管理","permalink":"https://motainzhang.com/tags/依赖管理/"},{"name":"项目构建","slug":"项目构建","permalink":"https://motainzhang.com/tags/项目构建/"}]},{"title":"Tomcat的简单总结","slug":"Tomcat的简单总结","date":"2017-05-06T21:02:15.000Z","updated":"2019-10-18T03:34:00.262Z","comments":true,"path":"2017/05/06/Tomcat的简单总结/","link":"","permalink":"https://motainzhang.com/2017/05/06/Tomcat的简单总结/","excerpt":"","text":"Tomcat是什么Tomcat是一个免费、开源的，用Java编写的Java Web服务器。 Tomcat的安装及配置 官网下载压缩包，解压到合适文件目录下。 配置环境变量CATALINA_HOME和CATALINA_BASE，两者内容相同 需要Java配置相关环境变量： 运行bin目录下的startup.bat/shutdown.bat，即可启动/关闭 Tomcat。浏览器通过localhost:8080即可访问Tomcat本地展示的首页。 部署项目到Tomcat在Tomcat目录下，手动部署项目繁琐且效率低下。可以通过Maven的Tomcat插件进行项目的开发调试。 可以通过首页右侧的Manager App管理web项目。 首次使用Manager App需要修改 %CATALINA_HOME%/conf/tomcat-users.xml文件","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"https://motainzhang.com/categories/Java-Web/"},{"name":"服务器","slug":"Java-Web/服务器","permalink":"https://motainzhang.com/categories/Java-Web/服务器/"}],"tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"https://motainzhang.com/tags/Tomcat/"},{"name":"服务器","slug":"服务器","permalink":"https://motainzhang.com/tags/服务器/"}]},{"title":"js常用正则表达式","slug":"js常用正则表达式","date":"2016-07-19T15:22:38.000Z","updated":"2019-10-18T03:34:00.262Z","comments":true,"path":"2016/07/19/js常用正则表达式/","link":"","permalink":"https://motainzhang.com/2016/07/19/js常用正则表达式/","excerpt":"","text":"用技术提升美好事物发生的概率_ Technologically, for greater probability to be happy. 知道这20个正则表达式，能让你少写1,000行代码正则表达式，一个十分古老而又强大的文本处理工具，仅仅用一段非常简短的表达式语句，便能够快速实现一个非常复杂的业务逻辑。熟练地掌握正则表达式的话，能够使你的开发效率得到极大的提升。 正则表达式经常被用于字段或任意字符串的校验，如下面这段校验基本日期格式的JavaScript代码： var reg = /^(\\\\d{1,4})(-|\\\\/)(\\\\d{1,2})\\\\2(\\\\d{1,2})$/; var r = fieldValue.match(reg); if(r==null)alert(&apos;Date format error!&apos;); 下面是技匠整理的，在前端开发中经常使用到的20个正则表达式。 1 . 校验密码强度密码的强度必须是包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间。 ^(?=.*\\\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$ 2. 校验中文字符串仅能是中文。 ^[\\\\u4e00-\\\\u9fa5]{0,}$ 3. 由数字、26个英文字母或下划线组成的字符串^\\\\w+$ 4. 校验E-Mail 地址同密码一样，下面是E-mail地址合规性的正则检查语句。 [\\\\w!#$%&amp;&apos;*+/=?^_`{|}~-]+(?:\\\\.[\\\\w!#$%&amp;&apos;*+/=?^_`{|}~-]+)*@(?:[\\\\w](?:[\\\\w-]*[\\\\w])?\\\\.)+[\\\\w](?:[\\\\w-]*[\\\\w])? 5. 校验身份证号码下面是身份证号码的正则校验。15 或 18位。 15位： ^[1-9]\\\\d{7}((0\\\\d)|(1[0-2]))(([0|1|2]\\\\d)|3[0-1])\\\\d{3}$ 18位： ^[1-9]\\\\d{5}[1-9]\\\\d{3}((0\\\\d)|(1[0-2]))(([0|1|2]\\\\d)|3[0-1])\\\\d{3}([0-9]|X)$ 6. 校验日期“yyyy-mm-dd“ 格式的日期校验，已考虑平闰年。 ^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$ 7. 校验金额金额校验，精确到2位小数。 ^[0-9]+(.[0-9]{2})?$ 8. 校验手机号下面是国内 13、15、18开头的手机号正则表达式。（可根据目前国内收集号扩展前两位开头号码） ^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\\\d{8}$ 9. 判断IE的版本IE目前还没被完全取代，很多页面还是需要做版本兼容，下面是IE版本检查的表达式。 ^.*MSIE [5-8](?:\\\\.[0-9]+)?(?!.*Trident\\\\/[5-9]\\\\.0).*$ 10. 校验IP-v4地址IP4 正则语句。 \\\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\b 11. 校验IP-v6地址IP6 正则语句。 (([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])) 12. 检查URL的前缀应用开发中很多时候需要区分请求是HTTPS还是HTTP，通过下面的表达式可以取出一个url的前缀然后再逻辑判断。 if (!s.match(/^[a-zA-Z]+:\\\\/\\\\//)) { s = &apos;http://&apos; + s; } 13. 提取URL链接下面的这个表达式可以筛选出一段文本中的URL。 ^(f|ht){1}(tp|tps):\\\\/\\\\/([\\\\w-]+\\\\.)+[\\\\w-]+(\\\\/[\\\\w- ./?%&amp;=]*)? 14. 文件路径及扩展名校验验证windows下文件路径和扩展名（下面的例子中为.txt文件） ^([a-zA-Z]\\\\:|\\\\\\\\)\\\\\\\\([^\\\\\\\\]+\\\\\\\\)*[^\\\\/:*?&quot;&lt;&gt;|]+\\\\.txt(l)?$ 15. 提取Color Hex Codes有时需要抽取网页中的颜色代码，可以使用下面的表达式。 ^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$ 16. 提取网页图片假若你想提取网页中所有图片信息，可以利用下面的表达式。 \\\\&lt; *[img][^\\\\\\\\&gt;]*[src] *= *[\\\\&quot;\\\\&apos;]{0,1}([^\\\\&quot;\\\\&apos;\\\\ &gt;]*) 17. 提取页面超链接提取html中的超链接。 (&lt;a\\\\s*(?!.*\\\\brel=)[^&gt;]*)(href=&quot;https?:\\\\/\\\\/)((?!(?:(?:www\\\\.)?&apos;.implode(&apos;|(?:www\\\\.)?&apos;, $follow_list).&apos;))[^&quot;]+)&quot;((?!.*\\\\brel=)[^&gt;]*)(?:[^&gt;]*)&gt; 18. 查找CSS属性通过下面的表达式，可以搜索到相匹配的CSS属性。 ^\\\\s*[a-zA-Z\\\\-]+\\\\s*[:]{1}\\\\s[a-zA-Z0-9\\\\s.#]+[;]{1} 19. 抽取注释如果你需要移除HMTL中的注释，可以使用如下的表达式。 &lt;!--(.*?)--&gt; 20. 匹配HTML标签通过下面的表达式可以匹配出HTML中的标签属性。 &lt;\\\\/?\\\\w+((\\\\s+\\\\w+(\\\\s*=\\\\s*(?:&quot;.*?&quot;|&apos;.*?&apos;|[\\\\^&apos;&quot;&gt;\\\\s]+))?)+\\\\s*|\\\\s*)\\\\/?&gt; 正则表达式的相关语法下面是我找到的一张非常不错的正则表达式 Cheat Sheet，可以用来快速查找相关语法。 学习正则表达式我在网上看到了一篇相当不错的正则表达式快速学习指南.aspx)，有兴趣继续深入学习的同学可以参考。 正则表达式在线测试工具regex101是一个非常不错的正则表达式在线测试工具，你可以直接在线测试你的正则表达式哦。 另外，我也网上找到几本不错的正则表达式方面的教程和书籍，并将它们分享到了技匠社jijiangshe.com，如果你有兴趣学习欢迎访问获取。_ 简书签约作者，技匠，以上内容欢迎大家分享到朋友圈/微博等。","categories":[{"name":"前端","slug":"前端","permalink":"https://motainzhang.com/categories/前端/"}],"tags":[]},{"title":"js常用代码段","slug":"js常用代码段","date":"2016-07-19T15:19:23.000Z","updated":"2019-10-18T03:34:00.262Z","comments":true,"path":"2016/07/19/js常用代码段/","link":"","permalink":"https://motainzhang.com/2016/07/19/js常用代码段/","excerpt":"","text":"用技术提升美好事物发生的概率_ Technologically, for greater probability to be happy. 推荐10 个短小却超实用的 JavaScript 代码段JavaScript正变得越来越流行，它已经成为前端开发的第一选择，并且利用基于JavaScript语言的NodeJS，我们也可以开发出高性能的后端服务，甚至我还看到在硬件编程领域也出现了JavaScript的身影。JavaScript正在逐渐进化为一门全能的开发语言。 但用好JavaScript并不容易，你除了需要掌握它的语法并知道如何写出高质量的代码之外，还需要了解如何解决那些几乎在每个项目中都会遇到的需求场景，比如：判断日期，高亮文本，限制字符数等等，有很多第三方库可以解决这些问题，但这些库可能并非只是为解决这一个问题而创建的，这意味着你需要引入了很多无关的代码，这将使你的整个系统变得臃肿，而且也会影响到系统的性能。我的做法是，收集和使用那些常见的JavaScript代码段，并在需要时，尽可能首先使用它们。下面便是我收集的10段实用JavaScript代码，基于它们你还可以创造出更强大的JS插件或功能函数。 1. 判断日期是否有效JavaScript中自带的日期函数还是太过简单，很难满足真实项目中对不同日期格式进行解析和判断的需要。JQuery也有一些第三方库来使日期相关的处理变得简单，但有时你可能只需要一个非常简单的函数，而不想引入一个庞大的第三方库。这时，你可以使用下面这段日期校验代码，它允许你自定义日期格式并进行日期有效性的校验。 function isValidDate(value, userFormat) { // Set default format if format is not provided userFormat = userFormat || &apos;mm/dd/yyyy&apos;; // Find custom delimiter by excluding // month, day and year characters var delimiter = /[^mdy]/.exec(userFormat)[0]; // Create an array with month, day and year // so we know the format order by index var theFormat = userFormat.split(delimiter); // Create array from user date var theDate = value.split(delimiter); function isDate(date, format) { var m, d, y, i = 0, len = format.length, f; for (i; i &lt; len; i++) { f = format[i]; if (/m/.test(f)) m = date[i]; if (/d/.test(f)) d = date[i]; if (/y/.test(f)) y = date[i]; } return ( m &gt; 0 &amp;&amp; m &lt; 13 &amp;&amp; y &amp;&amp; y.length === 4 &amp;&amp; d &gt; 0 &amp;&amp; // Check if it&apos;s a valid day of the month d &lt;= (new Date(y, m, 0)).getDate() ); } return isDate(theDate, theFormat); } 使用方法：下面这个调用返回false，因为11月份没有31天 isValidDate(&apos;dd-mm-yyyy&apos;, &apos;31/11/2012&apos;) 2. 获取一组元素的最大宽度或高度下面这个函数，对于需要进行动态排版的开发人员非常有用。 var getMaxHeight = function ($elms) { var maxHeight = 0; $elms.each(function () { // In some cases you may want to use outerHeight() instead var height = $(this).height(); if (height &gt; maxHeight) { maxHeight = height; } }); return maxHeight; }; 使用方法： $(elements).height( getMaxHeight($(elements)) ); 3. 高亮文本有很多JQuery的第三方库可以实现高亮文本的功能，但我更喜欢用下面这一小段JavaScript代码来实现这个功能，它非常短小，而且可以根据我的需要去进行灵活的修改，而且可以自己定义高亮的样式。下面这两个函数可以帮助你创建自己的文本高亮插件。 function highlight(text, words, tag) { // Default tag if no tag is provided tag = tag || &apos;span&apos;; var i, len = words.length, re; for (i = 0; i &lt; len; i++) { // Global regex to highlight all matches re = new RegExp(words[i], &apos;g&apos;); if (re.test(text)) { text = text.replace(re, &apos;&lt;&apos;+ tag +&apos; class=&quot;highlight&quot;&gt;$&amp;&lt;/&apos;+ tag +&apos;&gt;&apos;); } } return text; } 你同样会需要取消高亮的函数： function unhighlight(text, tag) { // Default tag if no tag is provided tag = tag || &apos;span&apos;; var re = new RegExp(&apos;(&lt;&apos;+ tag +&apos;.+?&gt;|&lt;\\/&apos;+ tag +&apos;&gt;)&apos;, &apos;g&apos;); return text.replace(re, &apos;&apos;); } 使用方法： $(&apos;p&apos;).html( highlight( $(&apos;p&apos;).html(), // the text [&apos;foo&apos;, &apos;bar&apos;, &apos;baz&apos;, &apos;hello world&apos;], // list of words or phrases to highlight &apos;strong&apos; // custom tag )); 4. 文字动效有时你会希望给你的一段文字增加动效，让其中的每个字都动起来。你可以使用下面这段jQuery插件代码来达到这个效果。当然你需要结合一个CSS3 transition样式来达到更好的效果。 $.fn.animateText = function(delay, klass) { var text = this.text(); var letters = text.split(&apos;&apos;); return this.each(function(){ var $this = $(this); $this.html(text.replace(/./g, &apos;&lt;span class=&quot;letter&quot;&gt;$&amp;&lt;/span&gt;&apos;)); $this.find(&apos;span.letter&apos;).each(function(i, el){ setTimeout(function(){ $(el).addClass(klass); }, delay * i); }); }); }; 使用方法： $(&apos;p&apos;).animateText(15, &apos;foo&apos;); 5. 逐个隐藏元素下面这个jQuery插件可以根据你设置的步长（间隔时间）来逐个隐藏一组元素。在列表元素的重新加载中使用，可以达到很好的效果。 $.fn.fadeAll = function (ops) { var o = $.extend({ delay: 500, // delay between elements speed: 500, // animation speed ease: &apos;swing&apos; // other require easing plugin }, ops); var $el = this; for (var i=0, d=0, l=$el.length; i&lt;l; i++, d+=o.delay) { $el.eq(i).delay(d).fadeIn(o.speed, o.ease); } return $el; } 使用方法： $(elements).fadeAll({ delay: 300, speed: 300 }); 6. 限制文本字数下面这端脚本允许你根据给定的字符长度截取文本，如果文本被截取，那么它的后面会自动带上省略号。 function excerpt(str, nwords) { var words = str.split(&apos; &apos;); words.splice(nwords, words.length-1); return words.join(&apos; &apos;) + (words.length !== str.split(&apos; &apos;).length ? &apos;…&apos; : &apos;&apos;); } 7. 判断相应式布局中当前适配度目前很多设计已经采用了响应式布局来适配网站或应用在不同设备上的显示。你经常需要在代码中判断当前处于哪一个屏幕适配度下。 function isBreakPoint(bp) { // The breakpoints that you set in your css var bps = [320, 480, 768, 1024]; var w = $(window).width(); var min, max; for (var i = 0, l = bps.length; i &lt; l; i++) { if (bps[i] === bp) { min = bps[i-1] || 0; max = bps[i]; break; } } return w &gt; min &amp;&amp; w &lt;= max; } 使用方法： if ( isBreakPoint(320) ) { // breakpoint at 320 or less } if ( isBreakPoint(480) ) { // breakpoint between 320 and 480 } … 8. 全局计数在一些游戏或广告场景中，你需要记录用户在当前页面上点击某一个按钮的次数，这时你可以使用jQuery的.data()函数来处理： $(element) .data(&apos;counter&apos;, 0) // begin counter at zero .click(function() { var counter = $(this).data(&apos;counter&apos;); // get $(this).data(&apos;counter&apos;, counter + 1); // set // do something else... }); 9. 嵌入优酷视频function embedYouku(link, ops) { var o = $.extend({ width: 480, height: 320, params: &apos;&apos; }, ops); var id = /\\?v\\=(\\w+)/.exec(link)[1]; return &apos;&lt;embed allowFullScreen=&quot;true&quot; id=&quot;embedid&quot; quality=&quot;high&quot; width=&quot;&apos;+o.width+&apos;&quot; height=&quot;&apos;+o.height+&apos;&quot; align=&quot;middle&quot; allowScriptAccess=&quot;always&quot; type=&quot;application/x-shockwave-flash&quot; src=&quot;&apos;+id+&apos;?&apos;+o.ops&apos;&quot;&apos;; } 使用方法： embedYouku( &apos;http://static.youku.com/v/swf/qplayer.swf&apos;, {&apos;winType=adshow&amp;VideoIDS=XMTE3NzQ0NTky&amp;isAutoPlay=false&amp;isShowRelatedVideo=false&apos;} ); 10. 创建动态菜单或下拉列表在很多场景中，我们都需要动态地创建菜单、下拉列表或列表项。下面是一段最基础的代码实现上面的功能，你可以根据实际需要进行相应的扩展。 function makeMenu(items, tags) { tags = tags || [&apos;ul&apos;, &apos;li&apos;]; // default tags var parent = tags[0]; var child = tags[1]; var item, value = &apos;&apos;; for (var i = 0, l = items.length; i &lt; l; i++) { item = items[i]; // Separate item and value if value is present if (/:/.test(item)) { item = items[i].split(&apos;:&apos;)[0]; value = items[i].split(&apos;:&apos;)[1]; } // Wrap the item in tag items[i] = &apos;&lt;&apos;+ child +&apos; &apos;+ (value &amp;&amp; &apos;value=&quot;&apos;+value+&apos;&quot;&apos;) +&apos;&gt;&apos;+ // add value if present item +&apos;&lt;/&apos;+ child +&apos;&gt;&apos;; } return &apos;&lt;&apos;+ parent +&apos;&gt;&apos;+ items.join(&apos;&apos;) +&apos;&lt;/&apos;+ parent +&apos;&gt;&apos;; } 使用方法： // Dropdown select month makeMenu( [&apos;January:JAN&apos;, &apos;February:FEB&apos;, &apos;March:MAR&apos;], // item:value [&apos;select&apos;, &apos;option&apos;] ); // List of groceries makeMenu( [&apos;Carrots&apos;, &apos;Lettuce&apos;, &apos;Tomatos&apos;, &apos;Milk&apos;], [&apos;ol&apos;, &apos;li&apos;] ); 总结：以上只是那些实用JavaScript代码段中的一小部分，我也建议你平时注意收集或自己编写这样的基础代码段，它们能在很多项目中使用或通过一些改造提供更完善的功能，使用这些代码段将为你节省下大量的开发时间。 简书签约作者：技匠，以上内容欢迎大家分享到朋友圈/微博等。 如果你觉得文章不错，或许也会喜欢我的新书《程序员的自我修养》，一本写给程序员的思考书（清华大学… 赞赏支持 技匠•程序员 © 著作权归作者所有","categories":[{"name":"前端","slug":"前端","permalink":"https://motainzhang.com/categories/前端/"}],"tags":[]},{"title":"hexo github个人博客搭建","slug":"hexo-github个人博客搭建","date":"2016-07-19T15:14:47.000Z","updated":"2019-10-18T03:34:00.262Z","comments":true,"path":"2016/07/19/hexo-github个人博客搭建/","link":"","permalink":"https://motainzhang.com/2016/07/19/hexo-github个人博客搭建/","excerpt":"","text":"一、添加扫描二维码关注功能打开 themes 目录下的 next 主题配置文件，找到 Wechat Subscriber 标签，将该标签下的配置改成如下形式： # Wechat Subscriber wechat_subscriber: enabled: true # 打开图片显示功能 qcode: /images/wechat-qcode.jpg # 需要显示的二维码图片 description: 扫描二维码关注微信公众号，了解更多 # 在图片的底部添加描述 复制代码 配置完成后，切记将所需要扫描的二维码图片放置在 images 文件夹下面，否则系统找不到图片。 结果如下图所示： 二、添加文章赞赏功能打开 themes 目录下的 next 主题配置文件，找到 Reward 标签，将该标签下的配置改成如下形式： # Reward reward_comment: 赞赏是最好的支持与鼓励！ # 添加打赏描述 wechatpay: /images/wechatpay.jpg # 微信收款码图片 alipay: /images/alipay.jpg # 支付宝收款码图片 #bitcoin: /images/bitcoin.png 复制代码 配置完成后，切记将所需要收款码图片放置在 images 文件夹下面，否则系统找不到图片。 结果如下图所示： 三、添加文章版权声明功能打开 themes 目录下的 next 主题配置文件，找到 Declare license on posts 标签，将该标签下的配置改成如下形式： # Declare license on posts post_copyright: enable: true # 激活版权声明模块 license: CC BY-NC-SA 3.0 # 版权许可协议 license_url: https://compassblog.github.io/ # 声明的文章的可点击链接（域名） 复制代码 配置完成后，执行如下 主目录下打开 Git Bash 命令窗口，执行如下命令开启 hexo 服务器： hexo s 复制代码 浏览器访问，显示结果如下图所示： 四、添加 Gitalk 评论系统1、什么是 GitalkGitalk 是一个基于 Github Issue 和 Preact 开发的评论插件，这款评论插件使用 Github 登录，也可以快速提交评论，其实有一款与 Gitalk 类似的评论插件叫 Gitment，然而这款有国内大神编写的评论插件已经不再维护，因此就只能选择国外的 Gitalk 了，并且 Gitalk 支持移动端。 2、为什么要用 Gitalk我们知道 hexo 博客 的 Next 主题支持多种评论系统的继承，例如 Disqus，畅言，网易云跟帖，多说，来比力，友说，红杏等评论系统，但是这些评论系统要么不再提供服务，要么需要「科学上网」才能够加载，要么就是龟速加载，好吧，我想说的就是 Gitalk ，现在你明白为啥要用 Gitalk 了？ 3、Gitalk 评论系统集成（1）新建一个 GitHub 仓库，用于存放评论的记录，如下图所示： （2）在 GitHub 上新建一个 OAuth application ： 点击这里可以直接新建 新建 OAuth application 详细说明： Application name //第（1）点建立的仓库名称 Homepage URL //博客地址 Application description //可不填 Authorization callback URL //博客地址 复制代码 如下图所示： 完成后，我们回获得如下图中的相关信息，后面可能会用到： （3）创建 Gitalk 的 swig 文件，在博客的主目录中打开 themes/next/layout/_third-party/comments 文件夹，新建 gitalk.swig 文件，在文件中配置如下代码： {% if not (theme.duoshuo and theme.duoshuo.shortname) and not theme.duoshuo_shortname %} {% if theme.gitalk.enable %} //_config.yml文件若没有添加enable: true可删除该判断 {% if theme.gitalk.distractionFreeMode %} var gitalk = new Gitalk({ clientID: '{{theme.gitalk.clientID}}', clientSecret: '{{theme.gitalk.clientSecret}}', id: window.location.pathname, repo: '{{theme.gitalk.repo}}', owner: '{{theme.gitalk.owner}}', admin: '{{theme.gitalk.admin}}', distractionFreeMode: '{{theme.gitalk.distractionFreeMode}}', }) gitalk.render('gitalk-container') {% endif %} {% endif %} {% endif %} 复制代码 （4）在同样的目录下找到并打开 index.swig 文件，在文件中配置如下代码引入 gitalk.swig 文件： {% include 'gitalk.swig' %} 复制代码 （5）在博客的主目录中打开 themes/next/layout/_partials/ 文件夹，找到并打开 comments.swig 文件，找到最后一个if分支，即下面这个分支代码： {% elseif theme.valine.appid and theme.valine.appkey %} &lt;div id=&quot;vcomments&quot;&gt;&lt;/div&gt; 复制代码 在这个 if 分支后加一个 Gitalk 的分支，代码如下： {% elseif theme.gitalk.enable %} &lt;div id=&quot;gitalk-container&quot;&gt;&lt;/div&gt; 复制代码 （6）在 themes/next/_config.xml 主题配置文件中加入如下配置： gitalk: enable: true # 是否开启 Gitalk 评论 owner: # GitHub 用户名 repo: #仓库名称 ClientID: ****** ClientSecret: ****** admin: # GitHub 用户名 distractionFreeMode: true 复制代码 到这里，Gitalk 评论系统基本就已经集成了。 后记： 最近 GitHub 限制了访问 label 的长度，即当我们博客文章的标题标签转换成 Issue超过 50 个字符时，Gitalk 评论系统便无法进行初始化，即对我们博客题目有了限制。而对于这个问题的解决，目前的想法是可以通过 md5 转换的方式封装 id，后续如果有好的解决办法，再更新吧。 扫描二维码关注微信公众号，了解更多 =====================","categories":[{"name":"前端","slug":"前端","permalink":"https://motainzhang.com/categories/前端/"},{"name":"后端","slug":"前端/后端","permalink":"https://motainzhang.com/categories/前端/后端/"}],"tags":[]},{"title":"Java集合类的比较","slug":"Java集合类的比较","date":"2016-06-15T12:46:49.000Z","updated":"2019-10-18T03:34:00.262Z","comments":true,"path":"2016/06/15/Java集合类的比较/","link":"","permalink":"https://motainzhang.com/2016/06/15/Java集合类的比较/","excerpt":"","text":"","categories":[{"name":"Java 面试题","slug":"Java-面试题","permalink":"https://motainzhang.com/categories/Java-面试题/"}],"tags":[]},{"title":"jQuery监听用户名输入+AJAX校验用户名是否被注册","slug":"jQuery监听用户名输入-AJAX校验用户名是否被注册","date":"2016-06-12T23:13:13.000Z","updated":"2019-10-18T03:34:00.262Z","comments":true,"path":"2016/06/12/jQuery监听用户名输入-AJAX校验用户名是否被注册/","link":"","permalink":"https://motainzhang.com/2016/06/12/jQuery监听用户名输入-AJAX校验用户名是否被注册/","excerpt":"","text":"前端代码展示123456789101112131415161718192021222324252627282930&lt;body&gt; ... &lt;div class=\"col-md-2\"&gt; &lt;sf:input cssClass=\"form-control\" path=\"username\"/&gt; &lt;sf:errors path=\"username\"/&gt; &lt;/div&gt; &lt;div class=\"col-md-2\" id=\"usernameError\"&gt;&lt;/div&gt; ...&lt;/body&gt;&lt;script type=\"text/javascript\"&gt; $(function () &#123; //键盘松开时触发监听事件，有实时反馈的效果（focus、blur等体验不好，都需要DOM失去焦点时才触发） $(\":input[name='username']\").keyup(function () &#123; var val = $(this).val(); val = $.trim(val); if(val != \"\")&#123; //发送请求到指定url，后端需要针对该url写对应的处理方法 var url = \"$&#123;pageContext.request.contextPath&#125;/validateUsername\"; var args = &#123;\"username\": val, \"time\": new Date()&#125;; //使用jQuery的ajax相关方法进行前后端交互 $.post(url, args, function (data) &#123; //将服务端返回的数据作为html元素放到指定位置 $(\"#usernameError\").html(data); &#125;); &#125; &#125;); &#125;)&lt;/script&gt; 后端处理 @responseBody注解返回，出现返回的中文内容乱码显示为?的问题，进行排查（已在web.xml中配置字符编码过滤器，前端页面也声明了charset…）。查看发现response返回的内容编码是”ISO-8859-1”，最简单的解决方案如下：在对应方法的@RequestMapping中添加produces = &quot;application/html;charset=utf-8&quot;。 123456@RequestMapping(value = &quot;/validateUsername&quot;, method = RequestMethod.POST, produces = &quot;application/html;charset=utf-8&quot;)@ResponseBodypublic String validateUsername(@RequestParam(&quot;username&quot;) String username)&#123; return spitterService.validateUsername(username);&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://motainzhang.com/categories/前端/"},{"name":"监听校验","slug":"前端/监听校验","permalink":"https://motainzhang.com/categories/前端/监听校验/"}],"tags":[{"name":"jQuery， AJAX， @Responsebody， 中文乱码， SSM","slug":"jQuery，-AJAX，-Responsebody，-中文乱码，-SSM","permalink":"https://motainzhang.com/tags/jQuery，-AJAX，-Responsebody，-中文乱码，-SSM/"}]},{"title":"jQuery","slug":"jQuery","date":"2016-06-12T16:30:14.000Z","updated":"2019-10-18T03:34:00.262Z","comments":true,"path":"2016/06/12/jQuery/","link":"","permalink":"https://motainzhang.com/2016/06/12/jQuery/","excerpt":"","text":"概述jQuery是使用最广泛的一个JavaScript库。 特点 消除浏览器差异：你不需要自己写冗长的代码来针对不同的浏览器来绑定事件，编写AJAX等代码； 简洁的操作DOM的方法：document.getElementById(&#39;test&#39;) 简化为$(&#39;#test&#39;) 轻松实现动画、修改CSS等各种操作。 $符号$是全局变量jQuery的别名，包含了jQuery的所有功能。 选择器选择器的作用：快速定位到一个或多个DOM节点。 按ID查找 12// 查找&lt;div id=&quot;abc&quot;&gt;var div = $(&apos;#abc&apos;); 按tag查找 12var ps = $(&apos;p&apos;); // 返回所有&lt;p&gt;节点ps.length; // 数一数页面有多少个&lt;p&gt;节点 按class查找 123var a = $(&apos;.red&apos;); // 所有包含 class=&quot;red&quot; 的节点都将返回//通常很多节点有多个class，可以查找同时包含red和green的节点：var a = $(&apos;.red.green&apos;); // 注意没有空格！ 按属性查找 123var email = $(&apos;[name=email]&apos;); // 找出&lt;??? name=&quot;email&quot;&gt;//当属性的值包含空格等特殊字符时，需要用双引号括起来var a = $(&apos;[items=&quot;A B&quot;]&apos;); // 找出&lt;??? items=&quot;A B&quot;&gt; 组合查找 12var emailInput = $(&apos;input[name=email]&apos;); // 查找&lt;input name=&quot;email&quot;&gt;var tr = $(&apos;tr.red&apos;); // 找出&lt;tr class=&quot;red ...&quot;&gt; 多项选择器多项选择器就是把多个选择器用,组合起来一块选 12$(&apos;p,div&apos;); // 把&lt;p&gt;和&lt;div&gt;都选出来$(&apos;p.red,p.green&apos;); // 把&lt;p class=&quot;red&quot;&gt;和&lt;p class=&quot;green&quot;&gt;都选出来 层级选择器查找和过滤操作DOM事件动画jQuery实现AJAX扩展","categories":[{"name":"前端","slug":"前端","permalink":"https://motainzhang.com/categories/前端/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"https://motainzhang.com/categories/前端/JavaScript/"},{"name":"jQuery","slug":"前端/JavaScript/jQuery","permalink":"https://motainzhang.com/categories/前端/JavaScript/jQuery/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://motainzhang.com/tags/JavaScript/"},{"name":"jQuery","slug":"jQuery","permalink":"https://motainzhang.com/tags/jQuery/"}]},{"title":"JSON","slug":"JSON","date":"2016-06-12T11:48:47.000Z","updated":"2019-10-18T03:34:00.262Z","comments":true,"path":"2016/06/12/JSON/","link":"","permalink":"https://motainzhang.com/2016/06/12/JSON/","excerpt":"","text":"JSON概述JSON（JavaScript Object Notation，JavaScript对象表示法），是一种简单轻量的数据格式。JSON是JavaScript的原生格式，在JavaScript中处理JSON数据不需要额外的API或工具包。 JSON的语法 {}：是对象 属性名 必须用&quot; &quot;包含 属性值 null 数值 字符串 数组：用[]括起来 boolean值：true和false JSON对象由 名称/值对组成，名称和值之间用:隔开；不同的名称/值对之间用 逗号,隔开。值可以是任意javascript数据类型，字符串，布尔，数字 ，数组甚至是对象、方法 。 示例123456789101112&lt;script type=&quot;text/javascript&quot;&gt; var person = &#123;&quot;name&quot;:&quot;zhangSan&quot;, &quot;age&quot;:18, &quot;sex&quot;:&quot;male&quot; &quot;address&quot;:&#123;&quot;province:&quot;:&quot;浙江&quot;, &quot;city&quot;:&quot;温州&quot;&#125;, &quot;work&quot;:function()&#123; alert(&quot;江南皮革厂&quot;); &#125; &#125;; &lt;!-- 调用方法：弹出对话框显示内容 --&gt; person.work();&lt;/script&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://motainzhang.com/categories/前端/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"https://motainzhang.com/categories/前端/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://motainzhang.com/tags/JavaScript/"},{"name":"JSON","slug":"JSON","permalink":"https://motainzhang.com/tags/JSON/"}]},{"title":"使用jQuery实现Ajax","slug":"使用jQuery实现Ajax","date":"2016-06-12T10:41:23.000Z","updated":"2019-10-18T03:34:00.262Z","comments":true,"path":"2016/06/12/使用jQuery实现Ajax/","link":"","permalink":"https://motainzhang.com/2016/06/12/使用jQuery实现Ajax/","excerpt":"","text":"概述jQuery对AJAX操作进行了封装，在JjQuery中: 最底层的方法：$.ajax() 第二层（最常用）：load(), $.get(), $.post() 第三层：$.getScript(), $.getJSON() load()方法 （处理HTML）load()方法是jQuery中最为简单和常用的Ajax方法，能载入远程的HTML代码并插入到DOM中。只需为HTML片段指定展示的位置，然后将要加载的内容的url作为参数传递给load()函数即可。 load()的参数（按顺序） 参数名称 类型 说明 url String 请求HTML页面的url地址 data(可选) Object 发送到服务器的 key/value 数据(json格式)，会作为QueryString附加到请求的URL中 callback(可选) Function 请求完成时的回调函数，无论请求是否成功 示例123456789101112131415161718192021&lt;body&gt; &lt;a href=\"链接地址\"&gt;平平无奇超链接&lt;/a&gt; &lt;div id=\"content\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script type=\"text/javascript\" src=\"jquery的路径\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; $(function()&#123; $(\"a\").click(function()&#123; //使用load方法处理AJAX var url = this.href + \" h2 a\";//\" h2 a\"表示只展示部分标签的内容，空格表示子标签的递进 //禁用缓存，效果等同于在url之后加上了 \"?time=\" + new Date() var args = &#123;\"time\": new Date()&#125;; //在指定标签加载内容 $&#123;\"#content\"&#125;.load(url, args); return false; &#125; &#125;);&lt;/script&gt; $.get() / $.post()方法$.get() / $.post()的参数（按顺序） 参数名称 类型 说明 url String 请求HTML页面的url地址 data(可选) Object 发送到服务器的 key/value 数据(json格式)，会作为QueryString附加到请求的URL中 callback(可选) Function 请求成功时的回调函数，自动将请求结果和状态传递给该方法 type（可选） String 服务器返回的内容格式，包括 xml、html、script、json、text和_default 处理XML数据示例 目标格式： 12&lt;h2&gt;&lt;a href=\"mailto:hspecial@163.com\"&gt;hunter&lt;/a&gt;&lt;/h2&gt;&lt;a href=\"https://hunter1023.github.io/\"&gt;https://hunter1023.github.io/&lt;/a&gt; 处理过程 1234567891011121314151617181920212223242526272829&lt;body&gt; &lt;a href=\"xxx\"&gt;一个平平无奇的超链接&lt;/a&gt; &lt;div id=\"details(指定标签的id用于存放结果)\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script type=\"text/javascript\" src=\"jquery的路径\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; $(function()&#123; $(\"a\").click(function()&#123; var url = this.href; var args = &#123;\"time\": new Date()&#125;; //返回的结果位于回调函数的参数data中，将其转为jQuery对象，获取节点内容 $.get(url, args, function(data)&#123; var name = $(data).find(\"name\").text(); var email = $(data).find(\"email\").text(); var website = $(data).find(\"website\").text(); //先清空标签内容，再添加 $(\"#details\").empty() .append(\"&lt;h2&gt;&lt;a href='mailto:\" + email + \"'&gt;\" + name + \"&lt;/a&gt;&lt;/h2&gt;\") .append(\"&lt;a href='\" + website +\"'&gt;\" + website + \"&lt;/a&gt;\"); &#125;)； return false; &#125; &#125;);&lt;/script&gt; $.getJSON()方法（处理JSON数据） JSON文件内容 123456&#123;\"person\":&#123; \"name\":\"Hunter\", \"website\":\"https://hunter1023.github.io/\", \"email\":\"hspecial@163.com\" &#125;&#125; 目标格式： 12&lt;h2&gt;&lt;a href=\"mailto:hspecial@163.com\"&gt;hunter&lt;/a&gt;&lt;/h2&gt;&lt;a href=\"https://hunter1023.github.io/\"&gt;https://hunter1023.github.io/&lt;/a&gt; 处理过程 12345678910111213141516171819202122232425262728293031&lt;body&gt; &lt;a href=\"xxx\"&gt;一个平平无奇的超链接&lt;/a&gt; &lt;div id=\"details(指定标签的id用于存放结果)\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script type=\"text/javascript\" src=\"jquery的路径\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; $(function()&#123; $(\"a\").click(function()&#123; var url = this.href; var args = &#123;\"time\": new Date()&#125;; /* 返回的结果位于回调函数的参数data中，data为json数据，可以通过`.`直接获取 也可以通过 $.get(),指定最后一个type参数为 \"JSON\"。也可按如下获取data中的数据 */ $.getJSON(url, args, function(data)&#123; var name = data.person.name; var email = data.person.email; var website = data.person.website; //先清空标签内容，再添加 $(\"#details\").empty() .append(\"&lt;h2&gt;&lt;a href='mailto:\" + email + \"'&gt;\" + name + \"&lt;/a&gt;&lt;/h2&gt;\") .append(\"&lt;a href='\" + website +\"'&gt;\" + website + \"&lt;/a&gt;\"); &#125;)； return false; &#125; &#125;);&lt;/script&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://motainzhang.com/categories/前端/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"https://motainzhang.com/categories/前端/JavaScript/"},{"name":"jQuery","slug":"前端/JavaScript/jQuery","permalink":"https://motainzhang.com/categories/前端/JavaScript/jQuery/"}],"tags":[{"name":"AJAX","slug":"AJAX","permalink":"https://motainzhang.com/tags/AJAX/"},{"name":"jQuery","slug":"jQuery","permalink":"https://motainzhang.com/tags/jQuery/"}]},{"title":"JavaScript","slug":"JavaScript","date":"2016-06-11T23:22:05.000Z","updated":"2019-10-18T03:34:00.262Z","comments":true,"path":"2016/06/11/JavaScript/","link":"","permalink":"https://motainzhang.com/2016/06/11/JavaScript/","excerpt":"","text":"JavaScript概述JavaScript是基于对象和事件驱动的脚本语言，主要应用在客户端，比如提交的时候，进行用户名是否为空的判断。 特点 交互性(信息的动态交互) 安全性(不允许直接访问本地硬盘) 跨平台性(只要是可以解析Js的浏览器都能运行，与平台无关) JavaScript和HTML的两种结合方式将JavaScript代码封装到标签中script标签可以放在html的任何地方，建议将script标签放到&lt;/body&gt;之后。如果JS需要获取input的值，因为html是从上到下解析，如果将script标签放到head里，直接取input里面的值，由于未解析到，导致无法获取。 123&lt;script type=\"text/javascript\"&gt; &lt;-- 填写JS代码 --&gt;&lt;/script&gt; 将JavaScript代码封装到JS文件中，并通过&lt;script&gt;的src属性进行导入1&lt;script type=\"text/javascript\" src=\"js文件路径\"&gt;&lt;/script&gt; 注意：如果&lt;script&gt;标签中使用src属性，那么该标签中封装的javascript代码将不会被执行。 JavaScript语法变量JS中定义变量，使用到关键字var(variable) 12345678var x = 3;//JS是弱类型语言alert(&quot;x=&quot;+x);//这是一个函数，将具体的参数通过对话框进行显示。``` 注：`&quot;&quot;`和`&apos;&apos;`所包括的内容，都是指字符串。### 运算符 - 算数运算符 var a = 3710;alert(“a=”+a/1000*1000);//a=3710var a1 = 2.3, b1 = 4.7;alert(“a1+b1=”+(a1+b1));//算数结果是7alert(“12”+1);//结果生成字符串121alert(“12”-1);//12会被转成数字，再进行算术运算。结果为11alert(true+1);//结果是2，JS中false就是0或者null；非0非null就是true，默认用1来表示。1234567- `==`和`===`的区别做判断时，`==`比较的是值，`===`比较的是值和类型- 逻辑运算符(! &amp;&amp; ||) 用来连接2个boolean型的表达式 var t = 4;alert(t&gt;3 &amp; t&lt;7);//结果是1alert(t&gt;3 &amp;&amp; t&lt;7);//结果是truealert(!t);//结果是false12345### 语法的一些细节 - undefined(未定义) 其实是一个常量 var x;alert(x==undefined);//true12- 通过`typeof()`，可以获得具体值的类型 alert(typeof(“abc”));//stringalert(typeof(2.5));//numberalert(typeof(true));//booleanalert(typeof(78));//numberalert(typeof’9’));//string1234567891011121314151617181920212223242526272829### 关于引入 直接向页面输出语句(可以把内容显示在页面上) `document.write(&quot;输出内容&quot;);`，document是javascript的内置对象，代表浏览器的文档部分，**可以向页面输出变量、固定值和HTML代码**。### JS的数组 - 三种定义方式 1. `var arr=[1,2,3]; var arr=[1,&quot;4&quot;, true];` //即**数组可以存放不同数据类型** 2. 使用内置对象 array对象 `var arr1=new array(5);`//定义一个数组，数组的长度是5 arr1[0]=&quot;1&quot;; 3. 使用内置对象 array对象 `var arr2=new array(3,4,5);`//定义一个数组，里面的元素是3、4、5 - 属性 - length（获取数组的长度） **数组长度可变**### JS的函数 **函数的参数列表里，不需要写var，直接写参数名称**- 三种定义方式 1. 使用到关键字 function ``` function 方法名(参数列表) &#123; 方法体; 返回值可有可无(根据实际需要); &#125;``` 2. 匿名函数 function(参数列表){ 方法体和返回值;}var add3 = function(m,n) { alert(m+n);}//调用方法add(5,6);` （用得少，作了解） 动态函数，用到JS里的一个内置对象 Functionvar add = new Function(&quot;参数列表&quot;,&quot;方法体和返回值&quot;); JS的全局变量和局部变量","categories":[{"name":"前端","slug":"前端","permalink":"https://motainzhang.com/categories/前端/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"https://motainzhang.com/categories/前端/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://motainzhang.com/tags/JavaScript/"},{"name":"js","slug":"js","permalink":"https://motainzhang.com/tags/js/"}]},{"title":"AJAX","slug":"AJAX","date":"2016-06-11T23:15:28.000Z","updated":"2019-10-18T03:34:00.262Z","comments":true,"path":"2016/06/11/AJAX/","link":"","permalink":"https://motainzhang.com/2016/06/11/AJAX/","excerpt":"","text":"AJAX是什么AJAX(Asynchronous Javascript And Xml)：异步（页面局部刷新）的js和xml。是无需刷新当前页面，即能让客户端与服务端进行通信的技术。 使用AJAXXMLHttpRequest（XHR）XMLHttpRequest对象是对JavaScript的扩展，它可以在用户没有感觉的情况下，悄悄的和服务器进行数据交互，是创建AJAX的最佳选择，通常把AJAX当做XMLHttpRequest对象的代名词。 XMLHttpRequest的方法 方法 描述 open(&quot;method&quot;, &quot;url&quot;) 建立对服务器的访问，method是GET、POST…, url可以是绝对/相对路径 send(&quot;content&quot;) 向服务器发送请求 onreadystatechange 状态的改变将会触发该事件处理器，通常是调用一个JavaScript函数 readyState 表示XMLHttpRequest的状态，可取0~4的5个整数。0：未初始化；1：正在加载；2：已经加载；3：交互中；4：完成 responseText 获取服务端传回的文本 responseXML 服务器的响应，表示为XML，可以解析为DOM对象 status 服务器的HTTP状态码：200（成功），404（未找到页面），403（禁止访问），500（服务器出错），304（没有被修改） setRequestHeader(&quot;header&quot;, &quot;value&quot;) 把指定首部设置为所提供的value，必须先调用open()才能设置。如果是POST请求，需要将”Content-type”的首部设置为”application/x-www-form-urlencoded”(告知服务器正在发送数据，并且数据已经符合URL编码) 创建XMLHttpRequest对象123&lt;script&gt;var xhr =new XMLHttpRequest();&lt;/script&gt; 实现AJAX示例123456789101112131415161718192021222324252627282930313233343536&lt;body&gt; &lt;a href=\"xxx\"&gt;一个平平无奇的超链接&lt;/a&gt;&lt;/body&gt;&lt;script type=\"text/javascript\"&gt; window.onload = function()&#123; //1.获取a节点，并为其添加onclick响应函数 document.getElementsByTagName(\"a\")[0].onclick = function()&#123; //3.创建一个XMLHttpRequest对象 var xhr = new XMLHttpRequest(); //4.准备发送请求的数据（url） var url = this.href;//可用通过在url最后添加 \"?time=\" + new Date();起到禁用缓存的效果 var method = \"GET\"; //5.调用XMLHttpRequest对象的open方法 xhr.open(method, url); //6.调用XMLHttpRequest对象的send方法 xhr.send(null); //7.为XMLHTTPRequest对象添加onreadystatechange响应函数 xhr.onreadystatechange = function()&#123; //8.判断响应是否完成：XHR对象的readyState属性值是否为4 if(xhr.readyState == 4)&#123; //9.判断响应是否可用：XHR对象的status值是否为200 if(xhr.status == 200 || xhr.status == 304)&#123; //10. 打印响应结果：responseText alert(xhr.responseText); &#125; &#125; &#125; //2.(如果是超链接)取消a节点的默认行为 return false； &#125; &#125;&lt;/script&gt; 展示HTML格式的内容document.getElementById(&quot;某个标签的id&quot;).innerHTML = xhr.responseText;设置标签的内容为服务端传递回来的HTML格式文本，按HTML格式显示。 优点 可读性好 HTML代码块与innerHTML属性搭配，效率高 服务端返回的HTML代码无需JavaScript解析 缺点 不适用于通过AJAX更新页面的多个部分 展示XML格式的内容例： xml格式的实例 123456&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;details&gt; &lt;name&gt;hunter&lt;/name&gt; &lt;website&gt;https://hunter1023.github.io/&lt;/website&gt; &lt;email&gt;hspecial@163.com&lt;/email&gt;&lt;/details&gt; 页面的展示 123456789101112131415161718192021222324252627282930313233343536373839&lt;body&gt; &lt;a href=\"xxx\"&gt;一个平平无奇的超链接&lt;/a&gt; &lt;div id=\"details(指定标签的id用于存放结果)\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script type=\"text/javascript\"&gt; ... //1.结果为XML格式，所以需要使用 responseXML 来获取 var result = xhr.responseXML; //2.结果不能直接使用，需要先创建对应的节点，再把节点加入到 #指定标签的id 中 /* 目标格式 &lt;h2&gt;&lt;a href=\"mailto:hspecial@163.com\"&gt;hunter&lt;/a&gt;&lt;/h2&gt; &lt;a href=\"https://hunter1023.github.io/\"&gt;https://hunter1023.github.io/&lt;/a&gt; */ var name = result.getElementsByTagName(\"name\")[0].firstChild.nodeValue; var website = result.getElementsByTagName(\"website\")[0].firstChild.nodeValue; var email = result.getElementsByTagName(\"email\")[0].firstChild.nodeValue; var aNode = document.createElement(\"a\"); aNode.appendChild(document.createTextNode(name)); aNode.href = \"mailto:\" + email; var h2Node = document.createElement(\"h2\"); h2Node.appendChild(aNode); var aNode2 = document.createElement(\"a\"); aNode2.appendChild(document.createTextNode(website)); aNode2.href = website; var detailsNode = document.getElementById(\"details\"); detailsNode.innnerHTML = null; detailsNode.appendChild(h2Node); detailsNode.appendChild(aNode2); ...&lt;/script&gt; 优点 XML是通用的数据格式 可以为数据自定义合适的标签 利用DOM可以完全掌控文档 缺点 如果文档来自服务器，必须保证文档含有正确的首部信息。如果文档类型不正确，responseXML的值为空。 当接收到内容较多的XML文件，DOM解析可能会很复杂 展示JSON格式的内容JSON的介绍JSON作为文本字符串，被存储在responseText属性中。 eval()函数可以通过JavaScript的eval()函数来读取其中的JSON数据。该函数可以把一个字符串作为参数，将其作为JavaScript代码来执行。如果想把JSON字符串转为JSON对象，需要先用( )将JSON字符串包含，再作为参数传给eval()例：var jsonObj = eval(&quot;(&quot; + jsonStr + &quot;)&quot;); 示例 JSON文件内容 123456&#123;\"person\":&#123; \"name\":\"Hunter\", \"website\":\"https://hunter1023.github.io/\", \"email\":\"hspecial@163.com\" &#125;&#125; 页面的展示 123456789101112131415161718192021222324252627282930313233343536373839&lt;body&gt; &lt;a href=&quot;xxx&quot;&gt;一个平平无奇的超链接&lt;/a&gt; &lt;div id=&quot;指定标签的id用于存放结果&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; ... //1.结果为JSON格式，所以需要使用 responseText 来获取 var result = xhr.responseText; var object = eval(&quot;(&quot; + result + &quot;)&quot;); //2.结果不能直接使用，需要先创建对应的节点，再把节点加入到 #指定标签的id 中 /* 目标格式 &lt;h2&gt;&lt;a href=&quot;mailto:hspecial@163.com&quot;&gt;hunter&lt;/a&gt;&lt;/h2&gt; &lt;a href=&quot;https://hunter1023.github.io/&quot;&gt;https://hunter1023.github.io/&lt;/a&gt; */ var name = object.person.name; var website = object.person.website; var email = object.person.email; var aNode = document.createElement(&quot;a&quot;); aNode.appendChild(document.createTextNode(name)); aNode.href = &quot;mailto:&quot; + email; var h2Node = document.createElement(&quot;h2&quot;); h2Node.appendChild(aNode); var aNode2 = document.createElement(&quot;a&quot;); aNode2.appendChild(document.createTextNode(website)); aNode2.href = website; var detailsNode = document.getElementById(&quot;details&quot;); detailsNode.innnerHTML = null; detailsNode.appendChild(h2Node); detailsNode.appendChild(aNode2); ...&lt;/script&gt; 优点 不需要从服务端发送含有特定内容类型的首部信息 缺点 语法过于严谨 代码不便阅读 eval函数存在风险 选择何种格式（html、xml、json）返回数据 应用程序不需要与其他应用程序共享数据，选择HTML格式返回数据 数据需要重用，选择JSON（性能和文件大小方面有优势） 远程应用程序未知时，选择XML(适用范围广) 使用jQuery实现AJAX","categories":[{"name":"前端","slug":"前端","permalink":"https://motainzhang.com/categories/前端/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"https://motainzhang.com/categories/前端/JavaScript/"}],"tags":[{"name":"AJAX","slug":"AJAX","permalink":"https://motainzhang.com/tags/AJAX/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://motainzhang.com/tags/JavaScript/"},{"name":"JSON","slug":"JSON","permalink":"https://motainzhang.com/tags/JSON/"},{"name":"jQuery","slug":"jQuery","permalink":"https://motainzhang.com/tags/jQuery/"}]},{"title":"MD5加密和验证","slug":"MD5加密和验证","date":"2016-06-01T17:15:44.000Z","updated":"2019-10-18T03:34:00.262Z","comments":true,"path":"2016/06/01/MD5加密和验证/","link":"","permalink":"https://motainzhang.com/2016/06/01/MD5加密和验证/","excerpt":"","text":"对密码加密的发展 为了解决 重要信息明文存储 的安全问题，从明文存储信息（如密码）改为存储加密信息，典型的加密算法是 MD5 和 SHA1。 当用户登陆的时候，会把用户输入的密码执行MD5（或者 SHA1）后再和数据库中的信息对比，判断用户身份是否合法，这种加密算法称为散列。 上述的设计方式已经有较高的安全性，但如果密码设置不够复杂，仍然可能被破解。好事者收集常用的密码，然后对他们执行 MD5 或者 SHA1，然后做成一个数据量非常庞大的数据字典，然后和泄露的数据库中的密码对比，如果你的原始密码很不幸的被包含在这个数据字典中，那么花不了多长时间就能把你的原始密码匹配出来。于是新的密码设计方法诞生——MD5+盐。由于加了 Salt，即便数据库泄露了，但是由于密码都是加了Salt之后的散列，坏人们的数据字典已经无法直接匹配，明文密码被破解出来的概率也大大降低。 什么是MD5加密参考：MD5加密 MD5(Message Digest Algorithm 5，消息摘要算法第五版)，是计算机安全领域广泛使用的一种散列函数，提供消息的完整性保护。严格来说，它是一种确保信息完整性的摘要算法。在某种意义上来说，也可以算作一种加密算法。 MD5加密后，数据的长度md5的长度，默认为128bit位。这样的表达不友好，所以将二进制转成了16进制，每4个bit表示一个16进制，所以换成16进制表示后，为32位。 MD5算法的特点 压缩性：任意长度的数据，算出的MD5值长度都是固定的。 容易计算：从原数据计算出MD5值很容易。 抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。 弱抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。 强抗碰撞：想找到两个不同的数据，使它们具有相同的MD5值，是非常困难的。 MD5 的作用是让大容量信息在用数字签名软件签署私人密钥前被”压缩”成一种保密的格式（就是把一个任意长度的字节串变换成一定长的十六进制数字串）。 MD5是一个不可逆的过程，生成消息摘要后不能通过结果解析得到原来的内容。 JAVA中实现MD5加密 JAVA中已有MD5类，在java.security.MessageDigest包中，名字就是MessageDigest，为应用程序提供信息摘要算法的功能，如 MD5 或 SHA 算法。 Spring提供DigestUtils类。只提供了MD5算法。实质也是用MessageDigest类进行处理，做了封装。 12byte[] bytes = password.getBytes();//password为String类型时，将其转换为byte数组DigestUtils.md5DigestAsHex(byte[] bytes);//返回类型为String 盐（Salt) 在密码学中，指在散列之前将散列内容（如密码）的任意固定位置插入特定的字符串。这样在散列中加入字符串的方式称为加盐，让加盐后的散列结果和没有加盐的结果不相同，在不同的应用情景中，这个处理可以增加额外的安全性。 编写MD5+Salt的工具类加密 利用Random类生成两个8位的随机数（nextInt方法最多能完全包含8位整数），将其拼接成16位字符串，作为Salt 通过Spring的DigestUtils类，将密码和盐拼接后进行加密，生成32位的密码 再将盐和32位的密码错位拼接，生成48位的密码校验从数据库取出加密的密码，取出错位的盐，将盐与用户输入的密码拼接。进行MD5加密后，与数据库密码进行比较 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class MD5Util &#123; //生成48位的加盐MD5 public static String generate(String password) &#123; Random r = new Random(); StringBuilder sb = new StringBuilder(16); //两个[0，99999999) 的随机整数拼接 sb.append(r.nextInt(99999999)).append(r.nextInt(99999999)); //保证StringBuilder的长度为16 int len = sb.length(); if (len &lt; 16) &#123; for (int i = 0; i &lt; 16 - len; i++) &#123; sb.append(&quot;0&quot;); &#125; &#125; String salt = sb.toString();//将StringBuilder转化为字符串，即为SALT password = md5Hex(password + salt);//将密码与该盐拼接，进行MD5加密，生成32位的密码 //将16位的salt与32位的（密码+salt）生成的MD5值再次拼接（因为MD5不可逆，这样能够重新获取salt），生成48位密码 char[] chars = new char[48]; for (int i = 0; i &lt; 48; i += 3) &#123; chars[i] = password.charAt(i / 3 * 2); char c = salt.charAt(i / 3); chars[i + 1] = c; chars[i + 2] = password.charAt(i / 3 * 2 + 1); &#125; return new String(chars); &#125; // 校验密码是否正确 public static boolean verify(String password, String md5) &#123; char[] cs1 = new char[32]; char[] cs2 = new char[16]; for (int i = 0; i &lt; 48; i += 3) &#123; //分解48位的密码，获取salt 和 MD5值 cs1[i / 3 * 2] = md5.charAt(i); cs1[i / 3 * 2 + 1] = md5.charAt(i + 2); cs2[i / 3] = md5.charAt(i + 1); &#125; String salt = new String(cs2); //将输入的密码和解析所获得的盐相加生成MD5值，与原MD5值比较来确认密码 return md5Hex(password + salt).equals(new String(cs1)); &#125; /** * 获取十六进制字符串形式的MD5摘要 */ private static String md5Hex(String src) &#123; return DigestUtils.md5DigestAsHex(src.getBytes()); &#125;&#125;","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"https://motainzhang.com/categories/Java-Web/"},{"name":"信息加密","slug":"Java-Web/信息加密","permalink":"https://motainzhang.com/categories/Java-Web/信息加密/"}],"tags":[{"name":"MD5","slug":"MD5","permalink":"https://motainzhang.com/tags/MD5/"},{"name":"Salt","slug":"Salt","permalink":"https://motainzhang.com/tags/Salt/"}]},{"title":"JDBC的简单总结","slug":"JDBC的简单总结","date":"2016-05-10T23:53:45.000Z","updated":"2019-10-18T03:34:00.262Z","comments":true,"path":"2016/05/10/JDBC的简单总结/","link":"","permalink":"https://motainzhang.com/2016/05/10/JDBC的简单总结/","excerpt":"","text":"JDBC是什么JDBC是实现Java Web程序对后端数据库访问的Jar包。应用程序通过调用JDBC提供的统一接口，可以实现对任意数据库的访问，JDBC屏蔽了客户端与服务器交互协议的实现细节。 JDBC的体系架构 JDBC API的结构图 DriverDriver是一个接口，定义了各个驱动程序都必须实现的功能，是驱动程序的抽象。通过操作Driver接口即可以实现对各个驱动程序的操作。 DriverManagerDriverManager是Driver的管理类。用户通过Class.forname(DriverName)向DriverManager注册一个驱动程序，再通过DriverManager的getConnection(DB_URL, USERNAME, PASSWORD)方法，即可调用该驱动程序，建立带有后端数据库的物理链接。 DB_URL是后端数据库的唯一标识符。例: Connection是获取物理链接的对象所属类，代表Java应用程序对后端数据库的一条物理链接。基于该链接可以执行一些sql语句。 常用方法：1Statement stmt = conn.createStatement(); StatementStatement是sql的容器，可以在其中对数据库进行select、delete、update等操作. 常用方法：123Result rs = stmt.excuteQuery(\"SELECT userName FROM user\");//查询结果Boolean isDelete = stmt.excute(\"sql语句\");//是否删除成功int num = stmt。excuteUpdate(\"sql语句\");//更新影响了多少条数据库记录 ResultSetResultSet对象代表sql查询的结果，该对象是由行、列组成的二元表。 通过指针移动到对应的行 获取对应列的值 构建Java程序和后端数据库连接的步骤 装载驱动程序 建立数据库连接 执行SQL语句 获取执行结果 清理环境 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.sql.Connection;import java.sql.DriverManager;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;public class HelloJDBC &#123; static final String DRIVER_NAME = \"com.mysql.jdbc.Driver\"; static final String DB_URL = \"jdbc:mysql://localhost:3306/cloud_study\"; static final String USERNAME = \"root\"; static final String PASSWORD = \"\"; public static void helloword() throws ClassNotFoundException &#123; Connection conn = null; Statement stmt = null; ResultSet rs = null; Class.forName(DRIVER_NAME);// 装载驱动程序 // 建立数据库连接 try &#123; conn = DriverManager.getConnection(DB_URL, USERNAME, PASSWORD); stmt = conn.createStatement(); rs = stmt.executeQuery(\"SELECT * FROM user WHERE Id=1\");// 执行sql语句 if(rs.absolute(1)) &#123;// 获取执行结果 System.out.println(rs.getInt(\"Id\")); System.out.println(rs.getString(\"ProductName\")); System.out.println(rs.getInt(\"Inventory\")); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; // 清理环境 try &#123; if (conn != null) conn.close(); if (stmt != null) stmt.close(); if (rs != null) rs.close(); &#125; catch (SQLException e) &#123; // 忽略 &#125; &#125; &#125; public static void main(String[] args) throws ClassNotFoundException &#123; helloword(); &#125;&#125; 读取数据库记录的几种情况海量数据读取海量数据读取，如果读取的数据超出了JVM的内存大小限制，就会导致内存溢出异常。解决方式：一次读取一部分数据进行处理，处理完成后读取下一部分数据，直到数据全部读取。 游标（cursor）：提供一种 客户端读取部分服务端结果集的机制。如何使用游标？通过在DB_URL末尾添加useCursorFetch=true来告知JDBC开启游标。 通过PreparedStatement接口（继承自Statement接口，要求生成时就要传入参数格式化的SQL语句，）的setFetchSize(int size)方法，设置客户端JDBC每次从服务器取得记录的数量，实现游标功能。 12345678910111213141516171819202122232425262728293031public class HelloJDBC &#123; static final String DRIVER_NAME = \"com.mysql.jdbc.Driver\"; static String DB_URL = \"jdbc:mysql://localhost:3306/cloud_study\"; static final String USERNAME = \"root\"; static final String PASSWORD = \"\"; public static void helloword() throws ClassNotFoundException &#123; Connection conn = null; PreparedStatement ptmt = null; ResultSet rs = null; Class.forName(DRIVER_NAME);// 装载驱动程序 // 建立数据库连接 try &#123; DB_URL = DB_URL + \"useCursorFetch=true\"; conn = DriverManager.getConnection(DB_URL, USERNAME, PASSWORD); ptmt = conn.prepareStatement(\"SELECT * FROM user\");//connection的方法是 prepareStatement ptmt.setFetchSize(1);//每次读取一条记录 rs = ptmt.executeQuery(); while(rs.next()) &#123;// 获取执行结果 System.out.println(rs.getString(\"ProductName\")); System.out.println(rs.getInt(\"Inventory\")); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; // 清理环境 ... &#125; &#125;&#125; 大对象读取对象过大，读取导致内存溢出。 流方式：将大字段的内容以二进制的方式按照区间进行划分，分为多个区间。每次读取一个区间的内容。处理结束后，读取下一个区间。 通过ResultSet对象的getBinaryStream()方法获取流对象。在外部生成文件，每次读取流对象中的一行，输出到文件，再读取下一行。 123456789101112131415161718192021222324try &#123; DB_URL = DB_URL + \"useCursorFetch=true\"; conn = DriverManager.getConnection(DB_URL, USERNAME, PASSWORD); ptmt = conn.prepareStatement(\"SELECT * FROM user\");//connection的方法是 prepareStatement rs = ptmt.executeQuery(); while(rs.next()) &#123;// 获取执行结果 InputStream in = rs.getBinaryStream(\"blog\"); //获取 数据库中某一列 的流对象 File f = new File(\"文件的存放地址\"); OutputStream out = new FileOutputStream(f); imt temp = 0;//行号 while((temp = in.read()) != -1) &#123;//边读边写 out.write(temp); &#125; in.close(); out.close(); &#125;&#125; catch (SQLException e) &#123; e.printStackTrace();&#125; finally &#123; // 清理环境 ...&#125; 海量数据插入每次执行executeUpdate()时，都是一次客户端发送SQL到服务端的过程，效率过低。 批处理：一次提交多条SQL语句，节省网络开销。 Statement/PreparedStatement的方法： addBatch(&quot;SQL语句&quot;);将SQL加入到Batch中 executeBatch();批量发送 clearBatch();清空Batch 字符集设置避免中文乱码,建议一致统一为UTF-8 数据库需要设置，JDBC也需要设置：DB_URL = DB_URL + “characterEncoding=utf8” Spring JDBCSpring JDBC封装了底层的实现内容。 先前总结的JDBC访问后端数据库的步骤： 装载驱动程序 建立数据库连接 执行SQL语句 获取执行结果 清理环境 通过Spring JDBC，只需要提供连接参数，提供SQL语句，即可获得执行结果。","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"https://motainzhang.com/categories/Java-Web/"},{"name":"数据库连接","slug":"Java-Web/数据库连接","permalink":"https://motainzhang.com/categories/Java-Web/数据库连接/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://motainzhang.com/tags/Spring/"},{"name":"数据库连接","slug":"数据库连接","permalink":"https://motainzhang.com/tags/数据库连接/"},{"name":"JDBC","slug":"JDBC","permalink":"https://motainzhang.com/tags/JDBC/"}]}]}