<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="MotainZhang" type="application/atom+xml" />






<meta property="og:type" content="website">
<meta property="og:title" content="MotainZhang">
<meta property="og:url" content="https://motainzhang.com/index.html">
<meta property="og:site_name" content="MotainZhang">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MotainZhang">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://motainzhang.com/"/>





  <title>MotainZhang</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">MotainZhang</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            站点地图
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://motainzhang.com/2019/10/18/pom.xml配置详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MotainZhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/27069108?s=460&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MotainZhang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/18/pom.xml配置详解/" itemprop="url">pom.xml配置详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-18T03:34:00+00:00">
                2019-10-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java-Web/" itemprop="url" rel="index">
                    <span itemprop="name">Java Web</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java-Web/Maven/" itemprop="url" rel="index">
                    <span itemprop="name">Maven</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/10/18/pom.xml配置详解/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/10/18/pom.xml配置详解/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="pom-xml的作用"><a href="#pom-xml的作用" class="headerlink" title="pom.xml的作用"></a>pom.xml的作用</h2><p>描述项目。<br><img src="https://github.com/Hunter1023/blogSource/raw/master/source/image/pom.xml%E7%9A%84%E9%83%A8%E5%88%86%E9%85%8D%E7%BD%AE.png" alt="pom.xml的简单介绍"></p>
<h2 id="groupId、artifactId和version构成项目的唯一标识（坐标），不能重复。"><a href="#groupId、artifactId和version构成项目的唯一标识（坐标），不能重复。" class="headerlink" title="groupId、artifactId和version构成项目的唯一标识（坐标），不能重复。"></a><code>groupId</code>、<code>artifactId</code>和<code>version</code>构成项目的唯一标识（坐标），不能重复。</h2><h2 id="lt-properties-gt-属性元素"><a href="#lt-properties-gt-属性元素" class="headerlink" title="&lt;properties&gt;属性元素"></a><code>&lt;properties&gt;</code>属性元素</h2><p><strong>自定义一些常量</strong>，比如版本号，字符编码，可以让之后一些依赖的版本直接从这里引用，便于后期修改及管理。</p>
<p><img src="https://github.com/Hunter1023/blogSource/raw/master/source/image/pom.xml%E4%B8%ADproperties%E7%9A%84%E9%85%8D%E7%BD%AE.png" alt=""></p>
<h2 id="lt-dependencies-gt-放置依赖，从远程仓库下载依赖的Jar包"><a href="#lt-dependencies-gt-放置依赖，从远程仓库下载依赖的Jar包" class="headerlink" title="&lt;dependencies&gt;放置依赖，从远程仓库下载依赖的Jar包"></a><code>&lt;dependencies&gt;</code>放置依赖，从远程仓库下载依赖的Jar包</h2><ul>
<li>依赖需要填写坐标：<code>groupId</code>、<code>artifactId</code>和<code>version</code></li>
<li>scope:依赖作用的范围：<ul>
<li>compile(<strong>默认</strong>) 编译时需要，打包时也将该依赖打包</li>
<li>provided 编译时需要，打包时不用</li>
</ul>
</li>
</ul>
<p>　　<strong>父pom中可以通过<code>&lt;dependencyManagement&gt;</code>放置<code>&lt;dependencies&gt;</code>,用于继承</strong>。</p>
<h3 id="如果访问Maven官方的中心仓库很慢（下载依赖耗时，浪费时间），可以更改为使用阿里云提供的镜像仓库："><a href="#如果访问Maven官方的中心仓库很慢（下载依赖耗时，浪费时间），可以更改为使用阿里云提供的镜像仓库：" class="headerlink" title="如果访问Maven官方的中心仓库很慢（下载依赖耗时，浪费时间），可以更改为使用阿里云提供的镜像仓库："></a>如果访问Maven官方的中心仓库很慢（<strong>下载依赖耗时，浪费时间</strong>），可以更改为使用阿里云提供的镜像仓库：</h3><ul>
<li>方式一： 修改<code>%M2_HOME%/conf/settings.xml</code>文件<br>　　在<code>&lt;mirrors&gt;</code>元素中添加一个<code>&lt;mirror&gt;</code>配置如下:<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>centeral<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun mirror<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>　　在<code>&lt;profiles&gt;</code>中添加一个<code>&lt;profile&gt;</code>配置如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>方式二： 修改本地仓库所在目录下的<code>setting.xml</code>文件内容如上。本地仓库一般位于<code>当前用户/.m2</code>目录下。</li>
</ul>
<h2 id="lt-build-gt-构建配置"><a href="#lt-build-gt-构建配置" class="headerlink" title="&lt;build&gt;构建配置"></a><code>&lt;build&gt;</code>构建配置</h2><ul>
<li><code>&lt;plugins&gt;</code>插件，比如compiler<br>  <strong>父pom中可以通过<code>&lt;pluginManagement&gt;</code>放置<code>&lt;plugins&gt;</code>,用于继承</strong>。</li>
</ul>
<h2 id="lt-parent-gt-多项目继承"><a href="#lt-parent-gt-多项目继承" class="headerlink" title="&lt;parent&gt;多项目继承"></a><code>&lt;parent&gt;</code>多项目继承</h2><p>参考：<a href="https://blog.csdn.net/ithomer/article/details/9332071" target="_blank" rel="noopener">Maven pom.xml配置详解</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://motainzhang.com/2019/10/18/vue权限路由总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MotainZhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/27069108?s=460&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MotainZhang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/18/vue权限路由总结/" itemprop="url">vue权限路由总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-18T03:34:00+00:00">
                2019-10-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/10/18/vue权限路由总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/10/18/vue权限路由总结/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h1 id="vue权限路由总结"><a href="#vue权限路由总结" class="headerlink" title="vue权限路由总结"></a>vue权限路由总结</h1><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>前端定义好路由，并且在路由上标记相应的权限信息</p>
<pre><code>const routerMap = [
  {
    path: &apos;/permission&apos;,
    component: Layout,
    redirect: &apos;/permission/index&apos;,
    alwaysShow: true, // will always show the root menu
    meta: {
      title: &apos;permission&apos;,
      icon: &apos;lock&apos;,
      roles: [&apos;admin&apos;, &apos;editor&apos;] // you can set roles in root nav
    },
    children: [{
      path: &apos;page&apos;,
      component: () =&gt; import(&apos;@/views/permission/page&apos;),
      name: &apos;pagePermission&apos;,
      meta: {
        title: &apos;pagePermission&apos;,
        roles: [&apos;admin&apos;] // or you can only set roles in sub nav
      }
    }, {
      path: &apos;directive&apos;,
      component: () =&gt; import(&apos;@/views/permission/directive&apos;),
      name: &apos;directivePermission&apos;,
      meta: {
        title: &apos;directivePermission&apos;
        // if do not set roles, means: this page does not require permission
      }
    }]
  }]
复制代码
</code></pre><p>全局路由守卫每次都判断用户是否已经登录，没有登录则跳到登录页。已经登录(已经取得后台返回的用户的权限信息(角色之类的))，则判断当前要跳转的路由，用户是否有权限访问(根据路由名称到全部路由里找到对应的路由，判断用户是否具备路由上标注的权限信息(比如上面的<code>roles: [&#39;admin&#39;, &#39;editor&#39;]</code>))。没有权限则跳到事先定义好的界面(403,404之类的)。</p>
<p>这种方式，菜单可以直接用路由生成(用户没有权限的菜单也会显示，点击跳转的时候才做权限判断)，也可以在用户登录后根据用户权限把路由过滤一遍生成菜单(菜单需要保存在vuex里)。</p>
<blockquote>
<p>目前<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fiview%2Fiview-admin%2Fblob%2Fdev%2Fsrc%2Frouter%2Findex.js" target="_blank" rel="noopener">iview-admin</a>还是用的这种方式</p>
</blockquote>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li><p>加载所有的路由，如果路由很多，而用户并不是所有的路由都有权限访问，对性能会有影响。</p>
</li>
<li><p>全局路由守卫里，每次路由跳转都要做权限判断。</p>
</li>
<li><p>菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译</p>
</li>
<li><p>菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识</p>
</li>
</ul>
<h2 id="登录页与主应用分离"><a href="#登录页与主应用分离" class="headerlink" title="登录页与主应用分离"></a>登录页与主应用分离</h2><p>针对前一种实现方式的缺点，可以将登录页与主应用放到不同的页面(不在同一个vue应用实例里)。</p>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>登录成功后，进行页面跳转(真正的页面跳转，不是路由跳转)，并将用户权限传递到主应用所在页面，主应用初始化之前，根据用户权限筛选路由，筛选后的路由作为vue的实例化参数，而不是像前一种方式所有的路由都传递进去，也不需要在全局路由守卫里做权限判断了。</p>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>需要做页面跳转，不是纯粹的单页应用</li>
<li>菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译</li>
<li>菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识</li>
</ul>
<h2 id="使用addRoutes动态挂载路由"><a href="#使用addRoutes动态挂载路由" class="headerlink" title="使用addRoutes动态挂载路由"></a>使用<code>addRoutes</code>动态挂载路由</h2><p><code>addRoutes</code>允许在应用初始化之后，动态的挂载路由。有了这个新姿势，就不用像前一种方式那样要在应用初始化之要对路由进行筛选。</p>
<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>应用初始化的时候先挂载不需要权限控制的路由，比如登录页，404等错误页。</p>
<p>有个问题，<code>addRoutes</code>应该何时调用，在哪里调用</p>
<p>登录后，获取用户的权限信息，然后筛选有权限访问的路由，再调用<code>addRoutes</code>添加路由。这个方法是可行的。但是不可能每次进入应用都需要登录，用户刷新浏览器又要登陆一次。</p>
<p>所以<code>addRoutes</code>还是要在全局路由守卫里进行调用</p>
<pre><code>import router from &apos;./router&apos;
import store from &apos;./store&apos;
import { Message } from &apos;element-ui&apos;
import NProgress from &apos;nprogress&apos; // progress bar
import &apos;nprogress/nprogress.css&apos;// progress bar style
import { getToken } from &apos;@/utils/auth&apos; // getToken from cookie

NProgress.configure({ showSpinner: false })// NProgress Configuration

// permission judge function
function hasPermission(roles, permissionRoles) {
  if (roles.indexOf(&apos;admin&apos;) &gt;= 0) return true // admin permission passed directly
  if (!permissionRoles) return true
  return roles.some(role =&gt; permissionRoles.indexOf(role) &gt;= 0)
}

const whiteList = [&apos;/login&apos;, &apos;/authredirect&apos;]// no redirect whitelist

router.beforeEach((to, from, next) =&gt; {
  NProgress.start() // start progress bar
  if (getToken()) { // determine if there has token
    /* has token*/
    if (to.path === &apos;/login&apos;) {
      next({ path: &apos;/&apos; })
      NProgress.done() // if current page is dashboard will not trigger    afterEach hook, so manually handle it
    } else {
      if (store.getters.roles.length === 0) { // 判断当前用户是否已拉取完user_info信息
        store.dispatch(&apos;GetUserInfo&apos;).then(res =&gt; { // 拉取user_info
          const roles = res.data.roles // note: roles must be a array! such as: [&apos;editor&apos;,&apos;develop&apos;]
          store.dispatch(&apos;GenerateRoutes&apos;, { roles }).then(() =&gt; { // 根据roles权限生成可访问的路由表
            router.addRoutes(store.getters.addRouters) // 动态添加可访问路由表
            next({ ...to, replace: true }) // hack方法 确保addRoutes已完成 ,set the replace: true so the navigation will not leave a history record
          })
        }).catch((err) =&gt; {
          store.dispatch(&apos;FedLogOut&apos;).then(() =&gt; {
            Message.error(err || &apos;Verification failed, please login again&apos;)
            next({ path: &apos;/&apos; })
          })
        })
      } else {
        // 没有动态改变权限的需求可直接next() 删除下方权限判断 ↓
        if (hasPermission(store.getters.roles, to.meta.roles)) {
          next()//
        } else {
          next({ path: &apos;/401&apos;, replace: true, query: { noGoBack: true }})
        }
        // 可删 ↑
      }
    }
  } else {
    /* has no token*/
    if (whiteList.indexOf(to.path) !== -1) { // 在免登录白名单，直接进入
      next()
    } else {
      next(&apos;/login&apos;) // 否则全部重定向到登录页
      NProgress.done() // if current page is login will not trigger afterEach hook, so manually handle it
    }
  }
})

router.afterEach(() =&gt; {
  NProgress.done() // finish progress bar
})
复制代码
</code></pre><p>关键的代码如下</p>
<pre><code>if (store.getters.roles.length === 0) { // 判断当前用户是否已拉取完user_info信息
        store.dispatch(&apos;GetUserInfo&apos;).then(res =&gt; { // 拉取user_info
          const roles = res.data.roles // note: roles must be a array! such as: [&apos;editor&apos;,&apos;develop&apos;]
          store.dispatch(&apos;GenerateRoutes&apos;, { roles }).then(() =&gt; { // 根据roles权限生成可访问的路由表
            router.addRoutes(store.getters.addRouters) // 动态添加可访问路由表
            next({ ...to, replace: true }) // hack方法 确保addRoutes已完成 ,set the replace: true so the navigation will not leave a history record
          })
        }).catch((err) =&gt; {
          store.dispatch(&apos;FedLogOut&apos;).then(() =&gt; {
            Message.error(err || &apos;Verification failed, please login again&apos;)
            next({ path: &apos;/&apos; })
          })
        })
复制代码
</code></pre><blockquote>
<p>上面的代码就是<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FPanJiaChen%2Fvue-element-admin" target="_blank" rel="noopener">vue-element-admin</a>的实现</p>
</blockquote>
<h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>全局路由守卫里，每次路由跳转都要做判断</li>
<li>菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译</li>
<li>菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识</li>
</ul>
<h2 id="菜单与路由分离，菜单由后端返回"><a href="#菜单与路由分离，菜单由后端返回" class="headerlink" title="菜单与路由分离，菜单由后端返回"></a>菜单与路由分离，菜单由后端返回</h2><p>菜单的显示标题，图片等需要随时更改，要对菜单做管理功能。</p>
<p>后端直接根据用户权限返回可访问的菜单。</p>
<h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><p>前端定义路由信息(标准的路由定义，不需要加其他标记字段)。</p>
<pre><code>{
    name: &quot;login&quot;,
    path: &quot;/login&quot;,
    component: () =&gt; import(&quot;@/pages/Login.vue&quot;)
}
复制代码
</code></pre><p>name字段都不为空，需要根据此字段与后端返回菜单做关联。</p>
<p>做菜单管理功能的时候，一定要有个字段与前端的路由的name字段对应上(也可以是其他字段，只要菜单能找到对应的路由或者路由能找到对应的菜单就行)，并且做唯一性校验。菜单上还需要定义权限字段，可以是一个或多个。其他信息，比如显示标题，图标，排序，锁定之类的，可以根据实际需求进行设计。</p>
<p><img src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1280&quot; height=&quot;655&quot;&gt;&lt;/svg" alt=""></p>
<p>还是在全局路由守卫里做判断</p>
<pre><code>function hasPermission(router, accessMenu) {
  if (whiteList.indexOf(router.path) !== -1) {
    return true;
  }
  let menu = Util.getMenuByName(router.name, accessMenu);
  if (menu.name) {
    return true;
  }
  return false;

}

Router.beforeEach(async (to, from, next) =&gt; {
  if (getToken()) {
    let userInfo = store.state.user.userInfo;
    if (!userInfo.name) {
      try {
        await store.dispatch(&quot;GetUserInfo&quot;)
        await store.dispatch(&apos;updateAccessMenu&apos;)
        if (to.path === &apos;/login&apos;) {
          next({ name: &apos;home_index&apos; })
        } else {
          //Util.toDefaultPage([...routers], to.name, router, next);
          next({ ...to, replace: true })//菜单权限更新完成,重新进一次当前路由
        }
      }  
      catch (e) {
        if (whiteList.indexOf(to.path) !== -1) { // 在免登录白名单，直接进入
          next()
        } else {
          next(&apos;/login&apos;)
        }
      }
    } else {
      if (to.path === &apos;/login&apos;) {
        next({ name: &apos;home_index&apos; })
      } else {
        if (hasPermission(to, store.getters.accessMenu)) {
          Util.toDefaultPage(store.getters.accessMenu,to, routes, next);
        } else {
          next({ path: &apos;/403&apos;,replace:true })
        }
      }
    }
  } else {
    if (whiteList.indexOf(to.path) !== -1) { // 在免登录白名单，直接进入
      next()
    } else {
      next(&apos;/login&apos;)
    }
  }
  let menu = Util.getMenuByName(to.name, store.getters.accessMenu);
  Util.title(menu.title);
});

Router.afterEach((to) =&gt; {
  window.scrollTo(0, 0);
});

复制代码
</code></pre><p>上面代码是<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fwjkang%2Fvue-quasar-admin" target="_blank" rel="noopener">vue-quasar-admin</a>的实现。因为没有使用<code>addRoutes</code>,每次路由跳转的时候都要判断权限，这里的判断也很简单，因为菜单的name与路由的name是一一对应的,而后端返回的菜单就已经是经过权限过滤的，所以如果根据路由name找不到对应的菜单，就表示用户有没权限访问。</p>
<p>如果路由很多，可以在应用初始化的时候，只挂载不需要权限控制的路由。取得后端返回的菜单后，根据菜单与路由的对应关系，筛选出可访问的路由，通过<code>addRoutes</code>动态挂载。</p>
<h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>菜单需要与路由做一一对应，前端添加了新功能，需要通过菜单管理功能添加新的菜单，如果菜单配置的不对会导致应用不能正常使用</li>
<li>全局路由守卫里，每次路由跳转都要做判断</li>
</ul>
<h2 id="菜单与路由完全由后端返回"><a href="#菜单与路由完全由后端返回" class="headerlink" title="菜单与路由完全由后端返回"></a>菜单与路由完全由后端返回</h2><p>菜单由后端返回是可行的，但是路由由后端返回呢？看一下路由的定义</p>
<pre><code>{
    name: &quot;login&quot;,
    path: &quot;/login&quot;,
    component: () =&gt; import(&quot;@/pages/Login.vue&quot;)
}
复制代码
</code></pre><p>后端如果直接返回</p>
<pre><code>{
    &quot;name&quot;: &quot;login&quot;,
    &quot;path&quot;: &quot;/login&quot;,
    &quot;component&quot;: &quot;() =&gt; import(&apos;@/pages/Login.vue&apos;)&quot;
}
复制代码
</code></pre><p>这是什么鬼，明显不行。<code>() =&gt; import(&#39;@/pages/Login.vue&#39;)</code>这代码如果没出现在前端，webpack不会对<code>Login.vue</code>进行编译打包</p>
<h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><p>前端统一定义路由组件，比如</p>
<pre><code>const Home = () =&gt; import(&quot;../pages/Home.vue&quot;);
const UserInfo = () =&gt; import(&quot;../pages/UserInfo.vue&quot;);
export default {
  home: Home,
  userInfo: UserInfo
};
复制代码
</code></pre><p>将路由组件定义为这种key-value的结构。</p>
<p>后端返回格式</p>
<pre><code>[
      {
        name: &quot;home&quot;,
        path: &quot;/&quot;,
        component: &quot;home&quot;
      },
      {
        name: &quot;home&quot;,
        path: &quot;/userinfo&quot;,
        component: &quot;userInfo&quot;
      }
]
复制代码
</code></pre><p>在将后端返回路由通过<code>addRoutes</code>动态挂载之间，需要将数据处理一下，将component字段换为真正的组件。</p>
<p>至于菜单与路由是否还要分离，怎么对应，可以根据实际需求进行处理。</p>
<p>如果有嵌套路由，后端功能设计的时候，要注意添加相应的字段。前端拿到数据也要做相应的处理。</p>
<h3 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>全局路由守卫里，每次路由跳转都要做判断</li>
<li>前后端的配合要求更高</li>
</ul>
<h2 id="不使用全局路由守卫"><a href="#不使用全局路由守卫" class="headerlink" title="不使用全局路由守卫"></a>不使用全局路由守卫</h2><p>前面几种方式，除了<code>登录页与主应用分离</code>,每次路由跳转，都在全局路由守卫里做了判断。</p>
<h3 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h3><p>应用初始化的时候只挂载不需要权限控制的路由</p>
<pre><code>const constRouterMap = [
  {
    name: &quot;login&quot;,
    path: &quot;/login&quot;,
    component: () =&gt; import(&quot;@/pages/Login.vue&quot;)
  },
  {
    path: &quot;/404&quot;,
    component: () =&gt; import(&quot;@/pages/Page404.vue&quot;)
  },
  {
    path: &quot;/init&quot;,
    component: () =&gt; import(&quot;@/pages/Init.vue&quot;)
  },
  {
    path: &quot;*&quot;,
    redirect: &quot;/404&quot;
  }
];
export default constRouterMap;
复制代码

import Vue from &quot;vue&quot;;
import Router from &quot;vue-router&quot;;
import ConstantRouterMap from &quot;./routers&quot;;

Vue.use(Router);

export default new Router({
  // mode: &apos;history&apos;, // require service support
  scrollBehavior: () =&gt; ({ y: 0 }),
  routes: ConstantRouterMap
});
复制代码
</code></pre><p>登录成功后跳到<code>/</code>路由</p>
<pre><code>submitForm(formName) {
      let _this=this;
      this.$refs[formName].validate(valid =&gt; {
        if (valid) {
          _this.$store.dispatch(&quot;loginByUserName&quot;,{
            name:_this.ruleForm2.name,
            pass:_this.ruleForm2.pass
          }).then(()=&gt;{
            _this.$router.push({
              path:&apos;/&apos;
            })
          })
        } else {

          return false;
        }
      });
    }
复制代码
</code></pre><p>因为当前没有<code>/</code>路由，会跳到<code>/404</code></p>
<pre><code>&lt;template&gt;
  &lt;h1&gt;404&lt;/h1&gt;
&lt;/template&gt;
&lt;script&gt;
export default {
  name:&apos;page404&apos;,
  mounted(){
    if(!this.$store.state.isLogin){
      this.$router.replace({ path: &apos;/login&apos; });
      return;
    }
    if(!this.$store.state.initedApp){
       this.$router.replace({ path: &apos;/init&apos; });
       return
    }
  }
}
&lt;/script&gt;
复制代码
</code></pre><p>404组件里判断已经登录，接着判断应用是否已经初始化(用户权限信息，可访问菜单，路由等是否已经从后端取得)。没有初始化则跳转到<code>/init</code>路由</p>
<pre><code>&lt;template&gt;
  &lt;div&gt;&lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
import { getAccessMenuList } from &quot;../mock/menus&quot;;
import components from &quot;../router/routerComponents.js&quot;;
export default {
  async mounted() {
    if (!this.$store.state.isLogin) {
      this.$router.push({ path: &quot;/login&quot; });
      return;
    }
    if (!this.$store.state.initedApp) {
      const loading = this.$loading({
        lock: true,
        text: &quot;初始化中&quot;,
        spinner: &quot;el-icon-loading&quot;,
        background: &quot;rgba(0, 0, 0, 0.7)&quot;
      });
      let menus = await getAccessMenuList(); //模拟从后端获取
      var routers = [...menus];
      for (let router of routers) {
        let component = components[router.component];
        router.component = component;
      }
      this.$router.addRoutes(routers);
      this.$store.dispatch(&quot;setAccessMenuList&quot;, menus).then(() =&gt; {
        loading.close();
        this.$router.replace({
          path: &quot;/&quot;
        });
      });
      return;
    } else {
      this.$router.replace({
        path: &quot;/&quot;
      });
    }
  }
};
&lt;/script&gt;

复制代码
</code></pre><p>init组件里判断应用是否已经初始化(避免初始化后，直接从地址栏输入地址再次进入当前组件)。</p>
<p>如果已经初始化，跳转<code>/</code>路由(如果后端返回的路由里没有定义次路由，则会跳转404)。</p>
<p>没有初始化，则调用远程接口获取菜单和路由等，然后处理后端返回的路由，将component赋值为真正 的组件，接着调用<code>addRoutes</code>挂载新路由，最后跳转<code>/</code>路由即可。菜单的处理也是在此处，看实际 需求。</p>
<blockquote>
<p><a href="https://link.juejin.im?target=https%3A%2F%2Fcodesandbox.io%2Fs%2Fr02zvvlpno" target="_blank" rel="noopener">实现例子</a></p>
</blockquote>
<h3 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>在404页面做了判断，感觉比较怪异</li>
<li>多引入了一个init页面组件</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>比较推荐后面两种实现方式。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://motainzhang.com/2019/10/18/西瓜播放器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MotainZhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/27069108?s=460&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MotainZhang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/18/西瓜播放器/" itemprop="url">洞察 video 超能力系列——玩转 mp4</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-18T03:34:00+00:00">
                2019-10-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/后端/" itemprop="url" rel="index">
                    <span itemprop="name">后端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/10/18/西瓜播放器/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/10/18/西瓜播放器/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="洞察-video-超能力系列——玩转-mp4"><a href="#洞察-video-超能力系列——玩转-mp4" class="headerlink" title="洞察 video 超能力系列——玩转 mp4"></a>洞察 video 超能力系列——玩转 mp4</h1><p><em>用技术提升美好事物发生的概率</em></p>
<p><em>Technologically, for greater probability to be happy.</em></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/6/1646f98cbbb5a15b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>只要在 HTML5 中使用过视频播放的同学对 video 标签一定不会陌生，不过很多同学只使用了 video 的基础功能，实际上 video 拥有强大潜能的，只要姿势正确就能让其拥有超能力。不妨从下面几个场景来逐渐了解下video 未曾被发掘的神秘空间：</p>
<ul>
<li><p>清晰度无缝切换</p>
</li>
<li><p>节省视频流量</p>
</li>
</ul>
<h2 id="清晰度无缝切换"><a href="#清晰度无缝切换" class="headerlink" title="清晰度无缝切换"></a>清晰度无缝切换</h2><p>点播领域里 mp4 是最普遍、兼容性最好的视频容器，不过 mp4 也有它的局限性，比如常见的清晰度切换，我们是无法像youtube那样做到无缝切换的。我们可以看下普通的mp4播放的网络请求和youtube视频播放的网络请求的区别。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/6/1646f98cbbcec4ef?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>图1.1 普通mp4的下载请求过程</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/6/1646f98cd48a0884?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="">  </p>
<p>图1.2 Youtube视频下载请求过程  </p>
<p>这两张图不难看出，在默认情况下 mp4 使用一次 http 请求所有的视频数据，Youtube 则分次请求。当然这个描述很不专业，但确实形象。造成这种差异的是 video 不支持流式的视频数据，Youtube 采用的是流式的视频容器 webm，而 mp4 是非流式的。那如何解释清楚流式的视频数据呢，从专业的角度三言两语很难说清楚，但用大白话翻译过来就是流式的视频数据支持分段独立播放，非流式的不可以。换句话说一个10M的视频文件，流式的视频可以把0~1M的数据请求回来单独播放，但是非流式的不可以。  </p>
<p>上面我们描述了视频格式的不同，接下来我们要说的是第一张图中的视频加载是浏览器来控制的，通过给 video 的 src 属性配置视频地址，触发播放之后浏览器就会开始下载了，JS干涉不了。而 Youtube 的视频加载是通过JS来控制的，各位可以再次看下第二张图的网络请求类型：xhr，足以证明这一点。</p>
<p>上面两点搞清楚之后我们就该说下清晰度切换的事情了。这个需求大家都不陌生，但是直接使用 mp4 格式做无缝清晰度切换，难度还挺大的。先解释下“无缝清晰度切换”的概念：从播放一个分辨率的视频到另一个分辨率且保证画面、声音不停顿的平滑切换过程。了解了这个概念，大家应该知道了用 video 无缝切换 mp4 有多难。一方面，video 是不支持流式的视频格式的，一方面，video 的加载是不受JS控制的。通过切换 video 的 src 属性，必然会导致画面中断、重新请求视频数据等。有的同学想到说利用两个 video 再结合 z-index 来搞，但是当你生成另一个video去加载视频的时候，无法保证两个画面是严格一致的，即使将原来的画面暂停到一个时刻，用另一个视频通过 currentTime 属性与之同步，切换仍然看到画面闪烁，基本无法和 Youtube 无缝切换的体验匹敌。而且还会造成更多流量的浪费，背后的原因大家可以研究下 mp4 容器和 webm 容器的异同，也可以看下视频解码相关的文章。</p>
<p>还有一种方法就是将 mp4 格式统统转码到流式的视频格式比如 hls、webm 等。不过这种看上去可行的方式实际上会带来很大的成本开销，如将大量视频做转码会消耗高昂的机器资源、双倍存储的费用、CDN的双倍费用等等。其实我们也是在这种背景下研究出来新的技术问题解决清晰度无缝切换的。</p>
<p>首先，我们改变对 mp4 视频的播放流程，不再直接使用 video 的 src 来播放，因为我们没有任何可以操作的空间。video不仅支持 src 属性还支持 Blob 对象，我们就是利用后者。播放的流程如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/6/1646f98cd46f50ae?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>图1.3 mp4 视频新播放流程</p>
<ol>
<li><p>来请求 mp4 视频数据，这样可以结合视频 Range 服务，做到精确加载。</p>
</li>
<li><p>编写解析器将加载回来的部分 mp4 视频数据进行解复用</p>
</li>
<li><p>将解复用的视频数据转成 fmp4 格式并传递给 MediaSource</p>
</li>
<li><p>使用 video 进行解码完成播放</p>
</li>
</ol>
<p>然后在做清晰度切换的时候流程如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/6/1646f98cd4990b8e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>图1.4 mp4视频清晰度切换原理示意图  </p>
<ol>
<li><p>播放视频A，过程同上</p>
</li>
<li><p>在某个时刻，用户切换到播放视频B，首先解析B的索引文件（moov），反向计算mp4的range区间</p>
</li>
<li><p>加载B的视频区间数据</p>
</li>
<li><p>解复用</p>
</li>
<li><p>把数据转换成fmp4格式并传递给MediaSource</p>
</li>
<li><p>删除A的部分Buffer</p>
</li>
<li><p>在下一个关键帧自动完成画质的切换</p>
</li>
</ol>
<p><img src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1080&quot; height=&quot;551&quot;&gt;&lt;/svg" alt=""></p>
<p>图1.5 mp4视频清晰度切换流程示意图</p>
<p>这个过程看上去比较繁琐，但是所有的操作都是在浏览器端完成，也就是说都是JS来实现的。这样之前说的所有成本问题都不存在，还能做到youtube相同体验的无缝切换。如果大家也想使用这个功能不需要自己再去实现一遍上述流程，可以使用如下代码：</p>
<p><img src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1080&quot; height=&quot;468&quot;&gt;&lt;/svg" alt=""></p>
<p>如果对这段代码有什么疑惑，或者想深入了解下它背后是如何实现的，可以参考<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fbytedance%2Fxgplayer" target="_blank" rel="noopener">github.com/bytedance/x…</a></p>
<p>长按识别二维码 ⬇️</p>
<p><img src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;136&quot; height=&quot;136&quot;&gt;&lt;/svg" alt=""></p>
<h2 id="节省视频流量"><a href="#节省视频流量" class="headerlink" title="节省视频流量"></a>节省视频流量</h2><p>使用 video 的同学基本上都是这样用的，如下：</p>
<ol>
<li>利用src属性</li>
</ol>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/6/1646f98ced13fa47?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>  2. 利用source标签</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/6/1646f98cf079b8bd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>这样就可以播放视频了，不过前面我们讲过这样使用 video ，视频的加载是受浏览器控制的，可以看下浏览器在视频刚开始播放的时候下载了多少数据：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/6/1646f98cf4a14e2c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>图2.1 video默认下载截图</p>
<p>我随便找了个视频，大家看下视频总长度是 02:08,在播放到 00:05 的时候，浏览器已经下载到 01:30 了，如果用户终止观看，下载的视频就这样被浪费掉了。当然，如果不断的 seek 也会造成较多的流量浪费。按照我们之前的统计在短视频领域，用户 seek 的频率在 80%，所以这部分流量是可以节省掉的。具体原理如下:</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/6/1646f98cfcfa6bc3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>图2.2 播放器加载视频原理</p>
<ol>
<li><p>设置每次加载的数据包大小</p>
</li>
<li><p>设置预加载时长</p>
</li>
<li><p>开启加载队列，完成第一次数据包下载，判断缓冲时间和预加载时长是否满足，不满足请求下一个数据包</p>
</li>
</ol>
<p>具体实现代码如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/6/1646f98cfdee42eb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>这样就实现了视频在播放过程中永远只预加载10秒的数据，进而保证节省流量。</p>
<p>了解超能力西瓜播放器是如何炼成的： <a href="https://link.juejin.im?target=http%3A%2F%2Fh5player.bytedance.com" target="_blank" rel="noopener">h5player.bytedance.com</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://motainzhang.com/2019/10/18/春招面试nodejs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MotainZhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/27069108?s=460&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MotainZhang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/18/春招面试nodejs/" itemprop="url">2018春招前端面试</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-18T03:34:00+00:00">
                2019-10-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/后端/" itemprop="url" rel="index">
                    <span itemprop="name">后端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/10/18/春招面试nodejs/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/10/18/春招面试nodejs/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h1 id="2018春招前端面试-闯关记-精排精校"><a href="#2018春招前端面试-闯关记-精排精校" class="headerlink" title="2018春招前端面试: 闯关记(精排精校)"></a>2018春招前端面试: 闯关记(精排精校)</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>去年年末研发组解散失业, so选择回去学车了,也顺利拿到了<strong>驾照</strong></p>
<p>最近回归大深圳….开始踏上漫漫的找工作之路;</p>
<p>“拉勾上吊一百年不匹配!!!”,”BOSS直聘日夜没反应!!!”</p>
<p>题目范围涵盖我最近遇到的笔试题和面谈的(CSS/JS/HTTP/Node/Hybrid/Vue/NG/React)</p>
<p>emm…..这里不列举哪些公司了, 若是你完整的阅读一遍,相信你有不少的收获,谢谢阅读</p>
</blockquote>
<ul>
<li>截止目前(2018/3/23)总共汇总了140个问题(我去面的创业,中大型皆有)…</li>
<li>期间死在各种一面/二面/三面/四面皆有之,也拿到部分和推掉部分<code>offer</code>,还有一些后续不清楚的</li>
</ul>
<hr>
<h1 id="问题汇总-想到就写…"><a href="#问题汇总-想到就写…" class="headerlink" title="问题汇总,想到就写…."></a>问题汇总,想到就写….</h1><h3 id="Q-CSS-有哪些样式可以给子元素继承"><a href="#Q-CSS-有哪些样式可以给子元素继承" class="headerlink" title="Q: CSS 有哪些样式可以给子元素继承!"></a>Q: CSS 有哪些样式可以给子元素继承!</h3><ul>
<li>可继承的:<code>font-size</code>,<code>font-weight</code>,<code>line-height</code>,<code>color</code>,<code>cursor</code>等</li>
<li>不可继承的一般是会改变盒子模型的:<code>display</code>,<code>margin</code>、<code>border</code>、<code>padding</code>、<code>height</code>等</li>
</ul>
<p>更加全面的可以到引擎找</p>
<hr>
<h3 id="Q-行内元素有哪些？块级元素有哪些？-空-void-元素有那些？"><a href="#Q-行内元素有哪些？块级元素有哪些？-空-void-元素有那些？" class="headerlink" title="Q: 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？"></a>Q: 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？</h3><ul>
<li>行内: <code>input</code>,<code>span</code>,<code>a</code>,<code>img</code>以及<code>display:inline</code>的元素</li>
<li>块级: <code>p</code>,<code>div</code>,<code>header</code>,<code>footer</code>,<code>aside</code>,<code>article</code>,<code>ul</code>以及<code>display:block</code>这些</li>
<li>void: <code>br</code>,<code>hr</code></li>
</ul>
<hr>
<h3 id="Q-CSS3实现一个扇形"><a href="#Q-CSS3实现一个扇形" class="headerlink" title="Q: CSS3实现一个扇形"></a>Q: CSS3实现一个扇形</h3><ul>
<li><p>思路跟画实体三角形一个道理,只不过多了一个圆角属性</p>
<p>&lt;!DOCTYPE html&gt;</p>
<html lang="en"><br><br><head><meta name="generator" content="Hexo 3.8.0"><br>  <meta charset="UTF-8"><br>  <meta name="viewport" content="width=device-width, initial-scale=1.0"><br>  <meta http-equiv="X-UA-Compatible" content="ie=edge"><br>  <title>扇形</title><br>  <style><br>    .sector {<br>      width: 0;<br>      height: 0;<br>      border-width: 50px;<br>      border-style: solid;<br>      border-color: #f00 transparent transparent;<br>      border-radius: 50px;<br>    }<br>  </style><br></head><br><body><br>  <div class="sector"></div><br><script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/haruto.model.json"},"display":{"position":"right","width":100,"height":200},"mobile":{"show":true},"react":{"opacityDefault":1,"opacityOnHover":0.2},"log":false});</script></body><br><br></html>

<p>复制代码</p>
</li>
</ul>
<hr>
<h3 id="Q-box-sizing常用的属性有哪些-分别有啥作用"><a href="#Q-box-sizing常用的属性有哪些-分别有啥作用" class="headerlink" title="Q: box-sizing常用的属性有哪些? 分别有啥作用?"></a>Q: <code>box-sizing</code>常用的属性有哪些? 分别有啥作用?</h3><p><code>box-sizing</code>有两个值:<code>content-box(W3C标准盒模型)</code>,<code>border-box(怪异模型)</code>,</p>
<p>这个css 主要是改变盒子模型大小的计算形式</p>
<p>可能有人会问<code>padding-box</code>,这个之前只有 Firefox 标准实现了,目前50+的版本已经废除;</p>
<p>用一个栗子来距离,一个<code>div</code>的宽高分别<code>100px</code>,<code>border</code>为<code>5px</code>,<code>padding</code>为<code>5px</code></p>
<pre><code>  &lt;style&gt;
    .test {
      box-sizing: content-box;
      border: 5px solid #f00;
      padding:5px;
      width: 100px;
      height: 100px;
    }

  &lt;/style&gt;
  &lt;div class=&quot;test&quot;&gt;&lt;/div&gt;
&lt;!--
content-box的计算公式会把宽高的定义指向 content,border和 padding 另外计算,
也就是说 content + padding + border = 120px(盒子实际大小)

而border-box的计算公式是总的大小涵盖这三者, content 会缩小,来让给另外两者
content(80px) + padding(5*2px) + border(5*2px) = 100px
--&gt;

复制代码
</code></pre><hr>
<h3 id="Q-清除浮动的方式有哪些-比较好的是哪一种"><a href="#Q-清除浮动的方式有哪些-比较好的是哪一种" class="headerlink" title="Q: 清除浮动的方式有哪些?比较好的是哪一种?"></a>Q: 清除浮动的方式有哪些?比较好的是哪一种?</h3><p>常用的一般为三种<code>.clearfix</code>, <code>clear:both</code>,<code>overflow:hidden</code>;</p>
<p>比较好是 <code>.clearfix</code>,伪元素万金油版本…后两者有局限性..等会再扯</p>
<pre><code>    .clearfix:after {
      visibility: hidden;
      display: block;
      font-size: 0;
      content: &quot; &quot;;
      clear: both;
      height: 0;
    }


&lt;!--
为毛没有 zoom ,_height 这些...IE6,7这类需要 csshack 不再我们考虑之内了
.clearfix 还有另外一种写法...
--&gt;

.clearfix:before, .clearfix:after {
    content:&quot;&quot;;
    display:table;
}
.clearfix:after{
    clear:both;
    overflow:hidden;
}
.clearfix{
    zoom:1;
}

&lt;!--
用display:table 是为了避免外边距margin重叠导致的margin塌陷,
内部元素默认会成为 table-cell 单元格的形式
--&gt;

复制代码
</code></pre><p><code>clear:both</code>:若是用在同一个容器内相邻元素上,那是贼好的…有时候在容器外就有些问题了, 比如相邻容器的包裹层元素塌陷</p>
<p><code>overflow:hidden</code>:这种若是用在同个容器内,可以形成 <code>BFC</code>避免浮动造成的元素塌陷</p>
<hr>
<h3 id="Q-CSS-中transition和animate有何区别-animate-如何停留在最后一帧"><a href="#Q-CSS-中transition和animate有何区别-animate-如何停留在最后一帧" class="headerlink" title="Q: CSS 中transition和animate有何区别? animate 如何停留在最后一帧!"></a>Q: CSS 中<code>transition</code>和<code>animate</code>有何区别? <code>animate</code> 如何停留在最后一帧!</h3><p>这种问题见仁见智,我的回答大体是这样的..待我捋捋.</p>
<p><code>transition</code>一般用来做过渡的, 没时间轴的概念, 通过事件触发(一次),没中间状态(只有开始和结束)</p>
<p>而<code>animate</code>则是做动效,有时间轴的概念(帧可控),可以重复触发和有中间状态;</p>
<p>过渡的开销比动效小,前者一般用于交互居多,后者用于活动页居多;</p>
<p>至于如何让<code>animate</code>停留在最后一帧也好办,就它自身参数的一个值就可以了</p>
<pre><code>animation-fill-mode: forwards;  
&lt;!--backwards则停留在首帧,both是轮流--&gt;
复制代码
</code></pre><p>让我们来举个栗子….自己新建一个 html 跑一下….</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
  &lt;title&gt;Box-sizing&lt;/title&gt;
  &lt;style&gt;
    .test {
      box-sizing: border-box;
      border: 5px solid #f00;
      padding: 5px;
      width: 100px;
      height: 100px;
      position:absolute;
      /*
      简写的姿势排序
      @keyframes name : 动画名
      duration 持续时间
      timing-function 动画频率
      delay 延迟多久开始
      iteration-count 循环次数
      direction 动画方式,往返还是正向
      fill-mode  一般用来处理停留在某一帧
      play-state running 开始,paused 暂停 ....
       更多的参数去查文档吧..我就不一一列举了
      */
      animation: moveChangeColor  ease-in 2.5s 1  forwards running;
    }

    @keyframes moveChangeColor {
       from {
         top:0%;
         left:5%;
         background-color:#f00
       }
       to{
         top:0%;
         left:50%;
         background-color:#ced;
       }
    }

  &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
  &lt;div class=&quot;test&quot;&gt;&lt;/div&gt;
&lt;/body&gt;

&lt;/html&gt;


复制代码
</code></pre><hr>
<h3 id="Q-块级元素水平垂直居中的方法"><a href="#Q-块级元素水平垂直居中的方法" class="headerlink" title="Q: 块级元素水平垂直居中的方法"></a>Q: 块级元素水平垂直居中的方法</h3><p>我们要考虑两种情况,定宽高和不定宽高的;</p>
<p>方案 N 多种,我记得我很早写过这类的笔记</p>
<p>传送门:<a href="https://link.juejin.im?target=http%3A%2F%2Fblog.csdn.net%2Fcolumn%2Fdetails%2Fcenter-layout.html" target="_blank" rel="noopener">网页元素居中攻略记</a></p>
<hr>
<h3 id="Q-说说样式权重的优先级"><a href="#Q-说说样式权重的优先级" class="headerlink" title="Q: 说说样式权重的优先级;"></a>Q: 说说样式权重的优先级;</h3><p><code>!important</code> &gt; 行内样式 > <code>id</code> > <code>class</code> > <code>tag</code></p>
<p>样式权重可以叠加, 比如 <code>id&gt;class</code></p>
<hr>
<h3 id="Q-对HTML语义化的理解"><a href="#Q-对HTML语义化的理解" class="headerlink" title="Q: 对HTML语义化的理解"></a>Q: 对HTML语义化的理解</h3><p>简言之:就是不滥用标签(比如 DIV)/随意嵌套(比如 span&gt;div) ,</p>
<p>类的命名要合理, 利于浏览器解析乃至引擎收录,也利于团队协作和维护</p>
<hr>
<h3 id="Q-JS有几种数据类型-其中基本数据类型有哪些"><a href="#Q-JS有几种数据类型-其中基本数据类型有哪些" class="headerlink" title="Q: JS有几种数据类型,其中基本数据类型有哪些!"></a>Q: JS有几种数据类型,其中基本数据类型有哪些!</h3><p><strong>七种数据类型</strong></p>
<ul>
<li>Boolean</li>
<li>Null</li>
<li>Undefined</li>
<li>Number</li>
<li>String</li>
<li>Symbol (ECMAScript 6 新定义)</li>
<li>Object</li>
</ul>
<p>(ES6之前)其中5种为基本类型:<code>string</code>,<code>number</code>,<code>boolean</code>,<code>null</code>,<code>undefined</code>,</p>
<p>ES6出来的<code>Symbol</code>也是原始数据类型 ，表示独一无二的值</p>
<p><code>Object</code> 为引用类型(范围挺大),也包括数组、函数,</p>
<hr>
<h3 id="Q-null和undefined的差异"><a href="#Q-null和undefined的差异" class="headerlink" title="Q: null和undefined的差异"></a>Q: <code>null</code>和<code>undefined</code>的差异</h3><p>大体说一下,想要知其所以然请引擎搜索</p>
<p>相同点:</p>
<ul>
<li>在 <code>if</code>判断语句中,值都默认为 <code>false</code></li>
<li>大体上两者都是代表<strong>无</strong>,具体看差异</li>
</ul>
<p>差异:</p>
<ul>
<li><code>null</code>转为数字类型值为0,而<code>undefined</code>转为数字类型为 <code>NaN(Not a Number)</code></li>
<li><code>undefined</code>是代表调用一个值而该值却没有赋值,这时候默认则为<code>undefined</code></li>
<li><code>null</code>是一个很特殊的对象,最为常见的一个用法就是作为参数传入(说明该参数不是对象)</li>
<li>设置为<code>null</code>的变量或者对象会被内存收集器回收</li>
</ul>
<hr>
<h3 id="Q-JS-的DOM-操作-Node节点获取及增删查改"><a href="#Q-JS-的DOM-操作-Node节点获取及增删查改" class="headerlink" title="Q: JS 的DOM 操作(Node节点获取及增删查改);"></a>Q: JS 的DOM 操作(Node节点获取及增删查改);</h3><ul>
<li>获取(太多了,有<code>document.getElementById/ClassName/Name/TagName 等,或者 querySelector</code>)</li>
</ul>
<pre><code>// example

// get Node
var element = document.querySelector(&apos;#test&apos;);

// 追加
element.appendChild(Node);

// 删除
element.removeChild(Node);

// 查找
element.nextSibling // 获取元素之后的兄弟节点 , 会拿到注释文本,空白符这些
element.nextElementSibling  // 等同, 获取标签(不会拿到注释文本这些)

element.previousSibling // 和上面同理,往前找兄弟节点
element.previousElementSibling

// 改动,比如 属性这些
element.setAttribute(name, value); // 增加属性
element.removeAttribute(attrName); //删除属性

// 来一个简易的练习题,随便一个网页追加插入一块DOM(非覆盖:不能 innerHTML);
/*
&lt;div id=&quot;test&quot;&gt;
   &lt;span&gt;Hello, World&lt;/span&gt;
&lt;/div&gt;
*/

// 以上面的例子为例
var test = document.createElement(&apos;div&apos;);  // 创建一个块级元素
test.setAttribute(&quot;id&quot;,&quot;test&quot;); // 设置其id 属性
var span = document.createElement(&apos;span&apos;); // 创建一个 span
span.innerText = &quot;Hello,world&quot;; // 插入 span 的文本内容
test.appendChild(span); // 组合节点

element.appendChild(test); //追加到某个节点区域


复制代码
</code></pre><hr>
<h3 id="Q-给一个-DOM添加捕获和冒泡的两种写法的事件点击-谁先执行"><a href="#Q-给一个-DOM添加捕获和冒泡的两种写法的事件点击-谁先执行" class="headerlink" title="Q: 给一个 DOM添加捕获和冒泡的两种写法的事件点击,谁先执行?"></a>Q: 给一个 <code>DOM</code>添加捕获和冒泡的两种写法的事件点击,谁先执行?</h3><p>分情况分析:</p>
<ul>
<li>有拿到节点的,优先捕获,没有才往上冒泡寻找</li>
<li>若是通过<code>node.addEventListener(&#39;event&#39;,callback,bubble or capture)</code>; 谁先调用谁先执行</li>
</ul>
<p><strong>stackoverflow 有相关的探讨</strong>:</p>
<ul>
<li><a href="https://link.juejin.im?target=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F11841330%2Fevent-listeners-registered-for-capturing-phase-not-triggered-before-bubbling-w" target="_blank" rel="noopener">Event listeners registered for capturing phase not triggered before bubbling - why?</a></li>
</ul>
<hr>
<h3 id="Q-谈谈你对ajax-的理解-以及用原生-JS-实现有哪些要点需要注意"><a href="#Q-谈谈你对ajax-的理解-以及用原生-JS-实现有哪些要点需要注意" class="headerlink" title="Q: 谈谈你对ajax 的理解,以及用原生 JS 实现有哪些要点需要注意;"></a>Q: 谈谈你对ajax 的理解,以及用原生 JS 实现有哪些要点需要注意;</h3><p><code>ajax</code>全称是<code>异步 javascript 和 XML</code>,用来和服务端进行数据交互的,让无刷新替换页面数据成了可能;</p>
<p>至于有哪些要要点,来一个简短的<code>ajax</code>请求</p>
<pre><code>var xhr = new XMLHttpRequest(); // 声明一个请求对象


xhr.onreadystatechange = function(){
    if(xhr.readyState === 4){  // readyState 4 代表已向服务器发送请求
        if(xhr.status === OK){ // // status 200 代表服务器返回成功
            console.log(xhr.responseText); // 这是返回的文本
        } else{
            console.log(&quot;Error: &quot;+ xhr.status); // 连接失败的时候抛出错误
        }
    }
}

xhr.open(&apos;GET&apos;, &apos;xxxx&apos;);

// 如何设置请求头? xhr.setRequestHeader(header, value);
xhr.setRequestHeader(&apos;Content-Type&apos;, &apos;application/json&apos;);

xhr.send(null); // get方法 send null(亦或者不传,则直接是传递 header) ,post 的 send 则是传递值



复制代码
</code></pre><p>更为详细的可以阅读此处;</p>
<ul>
<li><a href="https://link.juejin.im?target=http%3A%2F%2Fjavascript.ruanyifeng.com%2Fbom%2Fajax.html%23toc19" target="_blank" rel="noopener">&lt;<ajax 概念="" by="" 阮一峰="">&gt;</ajax></a></li>
<li><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.html5rocks.com%2Fzh%2Ftutorials%2Ffile%2Fxhr2%2F" target="_blank" rel="noopener">&lt;<xmlhttprequest2 用法指南="">&gt;</xmlhttprequest2></a></li>
</ul>
<hr>
<h3 id="Q-JS-实现一个闭包函数-每次调用都自增1"><a href="#Q-JS-实现一个闭包函数-每次调用都自增1" class="headerlink" title="Q: JS 实现一个闭包函数,每次调用都自增1;"></a>Q: JS 实现一个闭包函数,每次调用都自增1;</h3><p>这里主要考察了闭包,函数表达式以及 IIFE(立即执行表达式)</p>
<pre><code>var add = (function() {
  // 声明一变量,由于下面 return所以变量只会声明一次
  var count = 0; 
  return function() {
    return console.log(count++);
  };
})();

add(); // 0
add(); // 1
add(); // 2

复制代码
</code></pre><hr>
<h3 id="Q-‘1’-’2’-’3’-map-parseInt-输出什么-为什么"><a href="#Q-‘1’-’2’-’3’-map-parseInt-输出什么-为什么" class="headerlink" title="Q: [‘1’,’2’,’3’].map(parseInt) 输出什么,为什么?"></a>Q: [‘1’,’2’,’3’].map(parseInt) 输出什么,为什么?</h3><pre><code>[&apos;1&apos;,&apos;2&apos;,&apos;3&apos;].map(parseInt); // [1,NaN,NaN]

// 刨析

// map有三个参数:数组元素，元素索引，原数组本身
// parseInt有两个参数,元素本身以及进制
// 理清了这两个就好办了...
// [&apos;1&apos;,&apos;2&apos;,&apos;3&apos;].map(parseInt); 等于如下
[&apos;1&apos;,&apos;2&apos;,&apos;3&apos;].map(function(item,index,array){
    return parseInt(item,index); // 是不是一目了然
});

// parseInt(&quot;1&quot;,0); =&gt; 1
// parseInt(&quot;2&quot;,1); =&gt; NaN
// parseInt(&quot;3&quot;,2); =&gt; NaN


复制代码
</code></pre><hr>
<h3 id="Q-对数组-‘2018-03-05’-‘2013-06-12’-’2019-03-12’-’2018-03-05’-’2014-02-22’-去重且排序"><a href="#Q-对数组-‘2018-03-05’-‘2013-06-12’-’2019-03-12’-’2018-03-05’-’2014-02-22’-去重且排序" class="headerlink" title="Q: 对数组 [‘2018-03-05’, ‘2013-06-12’,’2019-03-12’,’2018-03-05’,’2014-02-22’] 去重且排序"></a>Q: 对数组 [‘2018-03-05’, ‘2013-06-12’,’2019-03-12’,’2018-03-05’,’2014-02-22’] 去重且排序</h3><p>我这里用的是结合 <code>ES6</code>的,代码量很短</p>
<pre><code>//很好理解, Set 具有值唯一性(但不是所有值,等会我抛出我的另外一篇文章)
// 结合...解构,可以把可迭代(比如 arguments/nodelist 等)的转为数组
// sort 里面传入 两个值比较,返回-1和1是因为1代表这个数大排后(相对),-1代表小(相对),0为相等

let arr = [...new Set([&apos;2018-03-05&apos;, &apos;2013-06-12&apos;,&apos;2019-03-12&apos;,&apos;2018-03-05&apos;,&apos;2014-02-22&apos;])].sort(function(a,b){
  return a&lt;b ? -1:1; // 这里返回的是升序的,降序改下返回值就好了.所以是相对
})

// [&quot;2013-06-12&quot;, &quot;2014-02-22&quot;, &quot;2018-03-05&quot;, &quot;2019-03-12&quot;]

复制代码
</code></pre><p>对于数组去重的,有兴趣的可以看下我这篇水文:</p>
<ul>
<li><a href="https://link.juejin.im?target=https%3A%2F%2Fjuejin.im%2Fpost%2F5913e038570c350069235fbe" target="_blank" rel="noopener">JS数组去重!!!一篇不怎么靠谱的”深度”水文</a></li>
</ul>
<hr>
<h3 id="Q-对数组-1-2-3-4-5-39-6-39-7-39-8-39-39-a-39-39-b-39-39-z-39-进行乱序"><a href="#Q-对数组-1-2-3-4-5-39-6-39-7-39-8-39-39-a-39-39-b-39-39-z-39-进行乱序" class="headerlink" title="Q: 对数组[1,2,3,4,5,&#39;6&#39;,7,&#39;8&#39;,&#39;a&#39;,&#39;b&#39;,&#39;z&#39;]进行乱序"></a>Q: 对数组<code>[1,2,3,4,5,&#39;6&#39;,7,&#39;8&#39;,&#39;a&#39;,&#39;b&#39;,&#39;z&#39;]</code>进行乱序</h3><pre><code>// 我们依旧可以用上面的 sort 的原理实现乱序

let tempArr = [1,2,3,4,5,&apos;6&apos;,7,&apos;8&apos;,&apos;a&apos;,&apos;b&apos;,&apos;z&apos;].sort(function(){
  return Math.random() &gt; 0.5 ? -1 : 1;
})

// 因为里面有随机数,所以答案没有标准答案,我这边跑了一次是输出这个
//[&quot;6&quot;, &quot;z&quot;, 3, &quot;b&quot;, 5, 2, 7, &quot;8&quot;, &quot;a&quot;, 1, 4]


复制代码
</code></pre><p><strong>上面和这道题逗涉及到数组顺序的问题,想了解下为什么 <code>a-b</code>,<code>a&gt;b</code>这类可以更改排序</strong></p>
<p>可以看看知乎对于这块的探讨: <a href="https://link.juejin.im?target=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F22781233" target="_blank" rel="noopener">传送门:javascript排序return a-b?</a></p>
<hr>
<h3 id="Q-求-1-10-11-1-39-5-39-12-13-14-15-2-3-4-7-8-9-内最大值与最小值之差"><a href="#Q-求-1-10-11-1-39-5-39-12-13-14-15-2-3-4-7-8-9-内最大值与最小值之差" class="headerlink" title="Q: 求[1, 10, 11, -1,&#39;-5&#39;,12, 13, 14, 15, 2, 3, 4, 7, 8, 9]内最大值与最小值之差"></a>Q: 求<code>[1, 10, 11, -1,&#39;-5&#39;,12, 13, 14, 15, 2, 3, 4, 7, 8, 9]</code>内最大值与最小值之差</h3><pre><code>// 来一个很粗糙的版本,只当传入是数组且可以隐性转为数字的
function MaxMinPlus(arr) {
  // 返回最大值与最小值之差
  return Array.isArray(arr) ? Math.max.apply(Math, arr) - Math.min.apply(Math, arr) : console.log(&apos;传入的不是数组亦或者未能解决的错误&apos;)
}

// 结果是 20

// 若是要完善的话,要考虑传入的是非数组,
//传入字符串的时候要判断,然后切割为数组..
// 都要考虑进去代码量不短

复制代码
</code></pre><hr>
<h3 id="Q-请给Array实现一个方法-去重后返回重复的字符-新数组"><a href="#Q-请给Array实现一个方法-去重后返回重复的字符-新数组" class="headerlink" title="Q: 请给Array实现一个方法,去重后返回重复的字符(新数组)"></a>Q: 请给<code>Array</code>实现一个方法,去重后返回重复的字符(新数组)</h3><pre><code>  var testArr = [1,6,8,3,7,9,2,7,2,4,4,3,3,1,5,3];

  Array.prototype.extraChar = function(){
      var cacheExtraChar = []; // 缓存重复出现的字符
      var that = this; // 缓存 this;
      this.map(function(item,index){
          // 怎么理解这段代码呢?
          // 就是向前往后查找一遍和从后往前查找一遍,不等就是没有重复
          // 为什么还要判断一遍缓存,是过滤缓存数组内多次写入
          (that.indexOf(item) !== that.lastIndexOf(item)) &amp;&amp; cacheExtraChar.indexOf(item) === -1 ? cacheExtraChar.push(item) : -1;
      });
      return cacheExtraChar;
  }


testArr.extraChar(); // [1, 3, 7, 2, 4]

// 若是还需要排序就再排序下

[1,6,8,3,7,9,2,7,2,4,4,3,3,1,5,3]
.extraChar()
.sort(function(a,b){return a-b}) // [1, 2, 3, 4, 7]

复制代码
</code></pre><hr>
<h3 id="Q-一个数组中-par中存放了多个人员的信息-每个人员的信息由-name-和-age-构成-name-39-张三-39-age-15-请用-JS-实现年龄从小到大的排序"><a href="#Q-一个数组中-par中存放了多个人员的信息-每个人员的信息由-name-和-age-构成-name-39-张三-39-age-15-请用-JS-实现年龄从小到大的排序" class="headerlink" title="Q: 一个数组中 par中存放了多个人员的信息,每个人员的信息由 name 和 age 构成({name:&#39;张三&#39;,age:15}).请用 JS 实现年龄从小到大的排序;"></a>Q: 一个数组中 par中存放了多个人员的信息,每个人员的信息由 <code>name</code> 和 <code>age</code> 构成(<code>{name:&#39;张三&#39;,age:15}</code>).请用 JS 实现年龄从小到大的排序;</h3><pre><code>var par = [{age:5,name:&apos;张三&apos;},{age:3,name:&apos;李四&apos;},{age:15,name:&apos;王五&apos;},{age:1,name:&apos;随便&apos;}]

var parSort = par.sort(function(a,b){
    return a.age - b.age;
})
复制代码
</code></pre><hr>
<h3 id="Q-判断一个回文字符串和同字母异序字符串"><a href="#Q-判断一个回文字符串和同字母异序字符串" class="headerlink" title="Q: 判断一个回文字符串和同字母异序字符串"></a>Q: 判断一个回文字符串和同字母异序字符串</h3><ul>
<li>回文字符串就是正序倒序都是一样的;</li>
<li>同字母异序字符串则是字符串都一样,但是位置可能不一定一样,比如<code>abcefd</code>和<code>dceabf</code>=&gt;<code>return true</code></li>
</ul>
<p>后者的思路就是用排序把异序扭正..</p>
<p><strong>普通版</strong></p>
<pre><code>// 回文判断 , 比如用 abcba
var isPalindromes = function(params){
  params = params.toString().toLowerCase()
  return params === params.split(&apos;&apos;).reverse().join(&apos;&apos;);
}

// 同字母异序判定,比如`abcefd`和`dceabf`
var isAnagram = function(str1, str2)  {
  str1 = str1.toString().toLowerCase();
  str2 = str2.toString().toLowerCase();
  return str1.split(&apos;&apos;).sort().join(&apos;&apos;) === str2.split(&apos;&apos;).sort().join(&apos;&apos;)
}



复制代码
</code></pre><p><strong>进阶版:多一些特殊字符</strong></p>
<p>若是我们要去除所有非字母数字的字符,则需要用到正则</p>
<pre><code>// 进阶版: isPalindromes(&apos;abc_ &amp;b #@a&apos;)

var isPalindromes = function(params){
  // 传入参数先转为字符串且全部转为小写,最后去除多余字符比较
  params = params.toString().toLowerCase().replace(/[\W_\s]/g,&apos;&apos;);
  console.log(params)
  return params === params.split(&apos;&apos;).reverse().join(&apos;&apos;);
}


// 进阶版同字母异序: isAnagram(&apos;ab *&amp;cef#d&apos;,&apos;!d@ce^abf&apos;)
var isAnagram = function(str1, str2)  {
  str1 = str1.toString().toLowerCase().replace(/[\W_\s]/g,&apos;&apos;);
  str2 = str2.toString().toLowerCase().replace(/[\W_\s]/g,&apos;&apos;);
  return str1.split(&apos;&apos;).sort().join(&apos;&apos;) === str2.split(&apos;&apos;).sort().join(&apos;&apos;)
}



复制代码
</code></pre><hr>
<h3 id="Q-JS-实现String-trim-方法"><a href="#Q-JS-实现String-trim-方法" class="headerlink" title="Q: JS 实现String.trim()方法;"></a>Q: JS 实现<code>String.trim()</code>方法;</h3><pre><code>// 原生是有 trim()方法的.我们要模拟一个;

String.prototype.emuTrim = function(){
    // 这条正则很好理解,就是把头部尾部多余的空格字符去除
    return this.replace(/(^\s*)|(\s*$)/g,&apos;&apos;);
}


&apos;  fsaf fsdaf f safl lllll    &apos;.emuTrim();  //&quot;fsaf fsdaf f safl lllll&quot; 

复制代码
</code></pre><hr>
<h3 id="Q-JS-实现函数运行一秒后打印输出0-9-给定如下代码"><a href="#Q-JS-实现函数运行一秒后打印输出0-9-给定如下代码" class="headerlink" title="Q: JS 实现函数运行一秒后打印输出0-9;给定如下代码"></a>Q: JS 实现函数运行一秒后打印输出0-9;给定如下代码</h3><pre><code>for(var i=0;i&lt;10;i++){
  // TODO
}

复制代码
</code></pre><ul>
<li>解法</li>
</ul>
<pre><code>// 这道题涉及到作用域
for(var i=0;i&lt;10;i++){
  setTimeout((function(i){
   return function(){
       console.log(i);
   }
  })(i),1000);
}

复制代码
</code></pre><p>若是用到 ES6…那简直不能再简便了</p>
<pre><code>for(let i=0;i&lt;10;i++){
  setTimeout(function(){
       console.log(i);
  },1000);
}

复制代码
</code></pre><hr>
<h3 id="Q-实现对一个数组或者对象的浅拷贝和”深度”拷贝"><a href="#Q-实现对一个数组或者对象的浅拷贝和”深度”拷贝" class="headerlink" title="Q: 实现对一个数组或者对象的浅拷贝和”深度”拷贝"></a>Q: 实现对一个数组或者对象的浅拷贝和”深度”拷贝</h3><p>浅拷贝就是把属于源对象的值都复制一遍到新的对象,不会开辟两者独立的内存区域;</p>
<p>深度拷贝则是完完全全两个独立的内存区域,互不干扰</p>
<ul>
<li>浅拷贝</li>
</ul>
<pre><code>// 这个 ES5的

function shallowClone(sourceObj) {
  // 先判断传入的是否为对象类型
  if (!sourceObj || typeof sourceObj !== &apos;object&apos;) {
    console.log(&apos;您传入的不是对象!!&apos;)
  }
  // 判断传入的 Obj是类型,然后给予对应的赋值
  var targetObj = sourceObj.constructor === Array ? [] : {};

  // 遍历所有 key
  for (var keys in sourceObj) {
    // 判断所有属于自身原型链上的 key,而非继承(上游 )那些
    if (sourceObj.hasOwnProperty(keys)) {
      // 一一复制过来
      targetObj[keys] = sourceObj[keys];
    }
  }
  return targetObj;
}

 // ES6 可以用 Object.assign(targeObj, source1,source2,source3) 来实现对象浅拷贝


复制代码
</code></pre><ul>
<li>深度拷贝</li>
</ul>
<pre><code>// 就是把需要赋值的类型转为基本类型(字符串这些)而非引用类型来实现
// JOSN对象中的stringify可以把一个js对象序列化为一个JSON字符串，parse可以把JSON字符串反序列化为一个js对象

var deepClone = function(sourceObj) {
  if (!sourceObj || typeof sourceObj !== &apos;object&apos;) {
    console.log(&apos;您传入的不是对象!!&apos;);
    return;
  }
  // 转-&gt;解析-&gt;返回一步到位
  return window.JSON
    ? JSON.parse(JSON.stringify(sourceObj))
    : console.log(&apos;您的浏览器不支持 JSON API&apos;);
};



复制代码
</code></pre><ul>
<li><a href="https://link.juejin.im?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F33489557" target="_blank" rel="noopener">深拷贝的考虑点实际上要复杂的多,详情看看知乎怎么说</a></li>
</ul>
<hr>
<h3 id="Q-this对象的理解"><a href="#Q-this对象的理解" class="headerlink" title="Q: this对象的理解"></a>Q: this对象的理解</h3><p>简言之:谁调用指向谁,运行时的上下文确定,而非定义的时候就确定;</p>
<p>强行绑定 <code>this</code>的话,可以用 <code>call</code>,<code>apply</code>,<code>bind</code>,箭头函数….来修改<code>this</code>的指向</p>
<p>这类的文章太多,自行搜索吧….</p>
<p>Q: 看到你说到 <code>bind</code>,能用 JS简单的模拟个么?</p>
<pre><code>Function.prototype.emulateBind =  function (context) {
    var self = this;
    return function () {
        return self.apply(context);
    }

}

复制代码
</code></pre><p>这个实现很粗糙…更为详细全面,考虑周全的(比如参数的处理什么的)…自行谷歌.</p>
<hr>
<h3 id="Q-JS-的作用域是什么-有什么特别之处么"><a href="#Q-JS-的作用域是什么-有什么特别之处么" class="headerlink" title="Q:JS 的作用域是什么?有什么特别之处么?"></a>Q:JS 的作用域是什么?有什么特别之处么?</h3><p>作用域就是有它自身的上下文区域(比如函数内),内部会有变量声明提升,函数声明提升这些;</p>
<p>函数声明提升优于变量声明提升..</p>
<p>作用域有全局作用域和块级作用域(局部,比如用 let 或者单纯花括号的);</p>
<p>作用域会影响<code>this</code>的指向</p>
<blockquote>
<p>坐等补充,我回答的时候,面试大佬只是 嗯..恩…恩…也不知道具体如何</p>
</blockquote>
<hr>
<h3 id="Q-怎么解决跨域问题-有哪些方法…"><a href="#Q-怎么解决跨域问题-有哪些方法…" class="headerlink" title="Q: 怎么解决跨域问题,有哪些方法…"></a>Q: 怎么解决跨域问题,有哪些方法…</h3><p>我一般用这三种,<code>cors</code>,<code>nginx反向代理</code>,<code>jsonp</code></p>
<ul>
<li><code>jsonp</code> : 单纯的 get 一些数据,局限性很大…就是利用script标签的src属性来实现跨域。</li>
<li><code>nginx 反向代理</code>: 主要就是用了<code>nginx.conf</code>内的<code>proxy_pass http://xxx.xxx.xxx</code>,会把所有请求代理到那个域名,有利也有弊吧..</li>
<li><code>cors</code>的话,可控性较强,需要前后端都设置,兼容性 IE10+ ,比如<ul>
<li>Access-Control-Allow-Origin: <a href="http://foo.example" target="_blank" rel="noopener">http://foo.example</a> // 子域乃至整个域名或所有域名是否允许访问</li>
<li>Access-Control-Allow-Methods: POST, GET, OPTIONS // 允许那些行为方法</li>
<li>Access-Control-Allow-Headers: X-PINGOTHER, Content-Type // 允许的头部字段</li>
<li>Access-Control-Max-Age: 86400 // 有效期</li>
</ul>
</li>
</ul>
<p>Q: 对于想携带一些鉴权信息跨域如何走起?比如<code>cookie</code>!</p>
<p>需要配置下 header <code>Access-Control-Allow-Credentials:true</code> ,具体用法看下面的<code>nginx</code>demo</p>
<p>当然<code>cros</code>的配置不仅仅这些,还有其他一些,具体引擎吧….</p>
<p>若是我们要用 <code>nginx</code>或者 <code>express</code> 配置<code>cors</code>应该怎么搞起? 来个简易版本的</p>
<ul>
<li><p>nginx</p>
<p>location / {</p>
<h1 id="检查域名后缀"><a href="#检查域名后缀" class="headerlink" title="检查域名后缀"></a>检查域名后缀</h1><pre><code>add_header Access-Control-Allow-Origin xx.xx.com;
add_header Access-Control-Allow-Methods GET,POST,OPTIONS;
add_header Access-Control-Allow-Credentials true;
add_header Access-Control-Allow-Headers DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type;
add_header Access-Control-Max-Age 86400;
</code></pre><p>} </p>
<p>复制代码</p>
</li>
<li><p>express, 当然这货也有一些别人封装好的 <code>cors</code>中间件,操作性更强…</p>
<p>let express = require(‘express’);<br>let app = express();  </p>
<p>//设置所有请求的头部<br>app.all(‘*’, (req, res, next) =&gt;  {  </p>
<pre><code>res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;xx.xx.com&quot;);  
res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&quot;);  
res.header(&quot;Access-Control-Allow-Credentials&quot;,&quot;true&quot;)
res.header(&quot;Access-Control-Allow-Methods&quot;,&quot;PUT,POST,GET,DELETE,OPTIONS&quot;);  
next();  
</code></pre><p>});  </p>
<p>复制代码</p>
</li>
</ul>
<p>有些还会跟你死磕,,除了这些还有其他姿势么…我说了一个HTML5的<code>postMessage</code>….</p>
<p>..因为真心没用过,只是以前查阅的时候了解了下..只能大体点下</p>
<p>这货用于<code>iframe</code> 传递消息居多, 大体有这么两步步</p>
<ul>
<li><code>window</code>打开一个实例,传递一个消息到一个x域名</li>
<li>x 域名下监听<code>message</code>事件,获取传递的消息</li>
</ul>
<p>这货的兼容性没那么好,而且没考虑周全下容易遭受 <code>CSRF</code> 攻击</p>
<hr>
<h3 id="Q-对于XSS-和-CSRF-如何防范"><a href="#Q-对于XSS-和-CSRF-如何防范" class="headerlink" title="Q: 对于XSS 和 CSRF 如何防范"></a>Q: 对于<code>XSS</code> 和 <code>CSRF</code> 如何防范</h3><p>这里就不说概念性的东西了</p>
<ul>
<li><p>XSS的防范</p>
<ul>
<li>我能想到的就是转义<code>&lt;&gt;</code>这些造成代码直接运行的的标签..轮询或者正则替换<ul>
<li>而面试官说这种的效率最低下,我回来仔细找了找相关资料好像没有更优方案…有的留言…</li>
</ul>
</li>
<li>若是有用到 <code>cookie</code>,设置为<code>http-only</code>,避免客户端的篡改</li>
</ul>
</li>
<li><p>CSRF的防范一般这几种</p>
<ul>
<li>验证码,用户体验虽然不好,,但是很多场合下可以防范大多数攻击</li>
<li>验证 HTTP Referer 字段,判断请求来源</li>
<li>token加密解密,这种是目前很常用的手段了…</li>
</ul>
</li>
</ul>
<p>任何防范都有代价的,比如验证码造成的体验不好,<code>token</code>滥用造成的性能问题,轮询替换造成的响应时间等</p>
<hr>
<h3 id="Q-描述下cookie-sessionStorage-localStorage的差异"><a href="#Q-描述下cookie-sessionStorage-localStorage的差异" class="headerlink" title="Q: 描述下cookie,sessionStorage,localStorage的差异.."></a>Q: 描述下<code>cookie</code>,<code>sessionStorage</code>,<code>localStorage</code>的差异..</h3><ul>
<li><code>cookie</code> : 大小4KB 左右,跟随请求(请求头),会占用带宽资源,但是若是用来判断用户是否在线这些挺方便</li>
<li><code>sessionStorage</code>和<code>localStorage</code>大同小异,大小看浏览器支持,一般为5MB,数据只保留在本地,不参与服务端交互.<ul>
<li><code>sessionStorage</code>的生存周期只限于会话中,关闭了储存的数据就没了.</li>
<li><code>localStorage</code>则保留在本地,没有人为清除会一直保留</li>
</ul>
</li>
</ul>
<hr>
<h3 id="Q-javascript的原型链你怎么理解"><a href="#Q-javascript的原型链你怎么理解" class="headerlink" title="Q: javascript的原型链你怎么理解?"></a>Q: <code>javascript</code>的原型链你怎么理解?</h3><p>原型链算是 JS 内一种独有的机制,</p>
<p>所有对象都有一个内置<code>[[proto]]</code>指向创建它的原型对象(<code>prototype</code>)</p>
<p>原型链的基本用来实现继承用的</p>
<hr>
<h3 id="Q-javascript里面的继承怎么实现，如何避免原型链上面的对象共享"><a href="#Q-javascript里面的继承怎么实现，如何避免原型链上面的对象共享" class="headerlink" title="Q: javascript里面的继承怎么实现，如何避免原型链上面的对象共享"></a>Q: <code>javascript</code>里面的继承怎么实现，如何避免原型链上面的对象共享</h3><p>我在写的时候,用了两种,一个是 ES5和 ES6的方案</p>
<ul>
<li>ES5:寄生组合式继承:通过借用构造函数来继承属性和原型链来实现子继承父。</li>
</ul>
<pre><code>    function ParentClass(name) {
      this.name = name;
    }
    ParentClass.prototype.sayHello = function () {
      console.log(&quot;I&apos;m parent!&quot; + this.name);
    }
    function SubClass(name, age) {
      //若是要多个参数可以用apply 结合 ...解构
      ParentClass.call(this, name);
      this.age = age;
    }
    SubClass.prototype = Object.create(ParentClass.prototype);
    SubClass.prototype.constructor = SubClass;
    SubClass.prototype.sayChildHello = function (name) {
      console.log(&quot;I&apos;m child &quot; + this.name)
    }

    let testA = new SubClass(&apos;CRPER&apos;)

    // Object.create()的polyfill
    /*
    function pureObject(o){
        //定义了一个临时构造函数
         function F() {}
         //将这个临时构造函数的原型指向了传入进来的对象。
         F.prototype = obj;
         //返回这个构造函数的一个实例。该实例拥有obj的所有属性和方法。
         //因为该实例的原型是obj对象。
         return new F();
    }
    */

复制代码
</code></pre><ul>
<li><p>ES6: 其实就是ES5的语法糖,不过可读性很强..</p>
<pre><code>class ParentClass {
  constructor(name) {
    this.name = name;
  }
  sayHello() {
    console.log(&quot;I&apos;m parent!&quot; + this.name);
  }
}

class SubClass extends ParentClass {
  constructor(name) {
    super(name);
  }
  sayChildHello() {
    console.log(&quot;I&apos;m child &quot; + this.name)
  }
  // 重新声明父类同名方法会覆写,ES5的话就是直接操作自己的原型链上
  sayHello(){
    console.log(&quot;override parent method !,I&apos;m sayHello Method&quot;)
  }
}

let testA = new SubClass(&apos;CRPER&apos;)
</code></pre><p>复制代码</p>
</li>
</ul>
<hr>
<h3 id="Q-ES6-你熟悉么-用过哪些特性"><a href="#Q-ES6-你熟悉么-用过哪些特性" class="headerlink" title="Q: ES6+你熟悉么,用过哪些特性?"></a>Q: ES6+你熟悉么,用过哪些特性?</h3><ul>
<li>箭头函数</li>
<li>类及引入导出和继承( <code>class</code>/<code>import</code>/<code>export</code>/<code>extends</code>)</li>
<li>字符串模板</li>
<li>Promise</li>
<li><code>let</code>,<code>const</code></li>
<li><code>async</code>/<code>await</code></li>
<li>默认参数/参数或变量解构装饰器</li>
<li><code>Array.inclueds</code>/<code>String.padStart|String.padEnd</code>/<code>Object.assign</code></li>
</ul>
<h4 id="Q-let-和-const-有啥差异"><a href="#Q-let-和-const-有啥差异" class="headerlink" title="Q: let 和 const 有啥差异?"></a>Q: let 和 const 有啥差异?</h4><ul>
<li><code>let</code> 会产生块级作用域,不会造成变量提升,无法重新声明(但可以重新赋值);</li>
<li><code>const</code><ul>
<li>是常量,若是基本数据类型,具有不变性(无法重新赋值改动)</li>
<li>引用值可以调整内部值(可能设计的时候没有考虑周全!</li>
</ul>
</li>
</ul>
<h4 id="Q-async和await的用途"><a href="#Q-async和await的用途" class="headerlink" title="Q: async和await的用途?"></a>Q: <code>async</code>和<code>await</code>的用途?</h4><ul>
<li>让 <code>promise</code> 的异步变成同步运行成了可能,<code>await</code> 可以等到 <code>promise</code> 执行完毕</li>
</ul>
<hr>
<h3 id="Q-箭头函数的this指向谁"><a href="#Q-箭头函数的this指向谁" class="headerlink" title="Q: 箭头函数的this指向谁?"></a>Q: 箭头函数的<code>this</code>指向谁?</h3><p>肯定很多小伙伴会说指向局部方法内!!答案是错误的…</p>
<p>箭头函数所改变的并非把 this 局部化，而是完全不把 this 绑定到里面去;</p>
<p>就是 this 是取自外部的上下级作用域(但是又不是常规 <code>function</code>的语法糖)..</p>
<p>因为箭头函数里并不支持 <code>var self = this</code> 或者 <code>.bind(this)</code> 这样的写法。</p>
<hr>
<h3 id="Q-问的时候你用过静态方法-静态属性-私有变量么"><a href="#Q-问的时候你用过静态方法-静态属性-私有变量么" class="headerlink" title="Q: 问的时候你用过静态方法,静态属性,私有变量么?"></a>Q: 问的时候你用过静态方法,静态属性,私有变量么?</h3><p>静态方法是ES6之后才有这么个玩意,有这么些特点</p>
<ul>
<li>方法不能给 this引用,可以给类直接引用</li>
<li>静态不可以给实例调用,比如 <code>let a = new ParentClass =&gt; a.sayHello() 会抛出异常</code></li>
<li>父类静态方法,子类非<code>static</code>方法没法覆盖父类</li>
<li>静态方法可以给子类继承</li>
<li>静态属性可以继承也可以被修改</li>
</ul>
<p>看下面的代码..</p>
<pre><code> class ParentClass {
      constructor(name) {
        this.name = name;
      }
      static sayHello() {
        console.log(&quot;I&apos;m parent!&quot; + this.name);
      }

      static testFunc(){
        console.log(&apos;emm...Parent test static Func&apos;)
      }
    }

    class SubClass extends ParentClass {
      constructor(name) {
        super(name);
      }
      sayChildHello() {
        console.log(&quot;I&apos;m child &quot; + this.name)
      }
      static sayHello() {
        console.log(&quot;override parent method !,I&apos;m sayHello Method&quot;)
      }

      static testFunc2() {
        console.log(super.testFunc() + &apos;fsdafasdf&apos;);
      }
    }
    ParentClass.sayHello(); // success print

    let a = new ParentClass(&apos;test&apos;);
    a.sayHello() // throw error

    SubClass.sayHello(); // 同名 static 可以继承且覆盖

    SubClass.testFunc2(); // 可以继承

    let testA = new SubClass(&apos;CRPER&apos;);

复制代码
</code></pre><p><strong>私有变量这个我没答出来,只是说了下没有<code>private</code>这个关键字和基本用下划线的人为区分</strong></p>
<p>所以回来只是找了下相关的资料,发现有一个比较好的模拟方案,就是<code>WeakMap</code>;</p>
<p><code>WeakMap</code>可以避免内存泄露,当没有被值引用的时候会自动给内存寄存器回收了.</p>
<pre><code>const _ = new WeakMap(); // 实例化,value 必须为对象,有 delete,get,has,set四个方法,看名字都知道了

class TestWeakMap {
  constructor(id, barcode) {
    _.set(this, { id,barcode });
  }
  testFunc() {
    let { id,barcode } = _.get(this); // 获取对应的值
    return { id,barcode };
  }
}

复制代码
</code></pre><p>当然你也可以用<code>Symbol</code>来实现一个私有变量,这也是一个好法子</p>
<hr>
<h3 id="Q-谈谈你对-Promise-的理解-和-ajax-有关系么"><a href="#Q-谈谈你对-Promise-的理解-和-ajax-有关系么" class="headerlink" title="Q: 谈谈你对 Promise 的理解? 和 ajax 有关系么?"></a>Q: 谈谈你对 Promise 的理解? 和 ajax 有关系么?</h3><p><code>Promise</code>和<code>ajax</code>没有半毛钱直接关系.<code>promise</code>只是为了解决”回调地狱”而诞生的;</p>
<p>平时结合 <code>ajax</code>是为了更好的梳理和控制流程…这里我们简单梳理下..</p>
<p><code>Promise</code>有三种状态,Pending/resolve()/reject();</p>
<p>一些需要注意的小点,如下</p>
<ul>
<li>在 <code>Pending</code> 转为另外两种之一的状态时候,状态不可在改变..</li>
<li><code>Promise</code>的 <code>then</code>为异步.而(<code>new Promise()</code>)构造函数内为同步</li>
<li><code>Promise</code>的<code>catch</code>不能捕获任意情况的错误(比如 <code>then</code> 里面的<code>setTimout</code>内手动抛出一个<code>Error</code>)</li>
<li><code>Promise</code>的<code>then</code>返回<code>Promise.reject()</code>会中断链式调用</li>
<li><code>Promise</code>的 <code>resolve</code>若是传入值而非函数,会发生值穿透的现象</li>
<li><code>Promise</code>的<code>catch</code>还是<code>then</code>,<code>return</code>的都是一个新的 <code>Promise</code>(在 Promise 没有被中断的情况下)</li>
</ul>
<p>Promise 还有一些自带的方法,比如<code>race</code>,<code>all</code>,前者有任一一个解析完毕就返回,后者所有解析完毕返回…</p>
<blockquote>
<p>实现一个延时的 promise 函数, 可以用<code>async</code>和<code>await</code></p>
</blockquote>
<pre><code>const delay = (time)=&gt; new Promise((resolve,reject)=&gt;{
  setTimeout(resolve,time)
})


// test

let testRun = async function(){
   console.log(1);
   await delay(2000);
   console.log(&apos;我两秒后才触发&apos;,3)
} 

// 1 =&gt; Promise = &gt; 3



复制代码
</code></pre><blockquote>
<p>这段代码的运行结果是什么?</p>
</blockquote>
<pre><code>var test = new Promise((resolve,reject)=&gt;{
   resolve();
});

test
  .then(data =&gt; {
    // promise start
    console.log(&apos;promise first then : &apos;, data);
    return Promise.resolve(1); // p1
  })
  .then(data =&gt; {
    // promise p1
    console.log(&apos;get parent(p1) resolve data : &apos;, data);
    return Promise.reject(new Error(&apos;哎呀,中断了,你能奈我何!&apos;)); // p2

  })
  .then(data =&gt; {
    // promise p2
    console.log(&apos;result of p2: &apos;, data);
    return Promise.resolve(3); // p3
  })
  .catch(err =&gt; {
    console.log(&apos;err: &apos;, err);
    return false;
  });

// promise first then :  undefined
// get parent(p1) resolve data :  1
// err:  Error: 哎呀,中断了,你能奈我何!

// 这里在 then 返回 Promise.reject()的时候已经中断了链式调用.直接给 catch捕获到



复制代码
</code></pre><blockquote>
<p>别急,假如你不管有没有捕获到错误,最后再执行一个回调函数如何实现?</p>
</blockquote>
<p>这里说的就是类似<code>try..catch..finally</code>,给<code>Promise</code>实现一个 finally;</p>
<pre><code>// finally比较好加，按照现在社区的讨论，finally的特点如下： 
// url : https://www.v2ex.com/t/205715  
//1. 不接收任何参数，原来的value或者Error在finally里是收不到的 
//2. 处理后不影响原Promise的状态，该reject还是reject，该resolve还是resolve 
//3. 不影响Promise向后传递的传，resolve状态还是传递原来的value，reject状态还是传递原来的Error 

Promise.prototype.finally = function (callback) {
  let P = this.constructor; // 这里拿到的是 Promise 的构造函数

  //不管前面的 Promise 是fulfilled还是rejected，都会执行回调函数callback。
  return this.then(
    value  =&gt; P.resolve(callback()).then(() =&gt; value),
    reason =&gt; P.resolve(callback()).then(() =&gt; { throw reason })
  );
};

// 用法很简单,就是可以传入一个回调函数..
// https://developers.google.com/web/updates/2017/10/promise-finally
// 这个 url 中说了 node 及 chrome 的哪些版本已经实现了 finally 及用法
// ES 2018已经把 finally 追加到 promise 的原型链中..


复制代码
</code></pre><ul>
<li><a href="https://link.juejin.im?target=https%3A%2F%2Fjuejin.im%2Fpost%2F5a04066351882517c416715d" target="_blank" rel="noopener">&lt;<promise 必知必会（十道题)="">&gt;</promise></a>: 有助于你更加深刻的了解 promise 的运行情况</li>
<li><a href="https://link.juejin.im?target=https%3A%2F%2Fjuejin.im%2Fpost%2F5a9600526fb9a06333155141" target="_blank" rel="noopener">关于 Promise 的 9 个提示</a></li>
<li>更多的Promise 详情可以参考<a href="https://link.juejin.im?target=http%3A%2F%2Fliubin.org%2Fpromises-book%2F" target="_blank" rel="noopener">&lt;<javascript promise迷你书（中文版）="">&gt;</javascript></a>;</li>
</ul>
<hr>
<h3 id="Q-谈谈你对-TCP-的理解"><a href="#Q-谈谈你对-TCP-的理解" class="headerlink" title="Q: 谈谈你对 TCP 的理解;"></a>Q: 谈谈你对 TCP 的理解;</h3><blockquote>
<p>Q: TCP 是在哪个OSI 的哪个层!通讯过程是全双工还是半双工(单工)?</p>
<p>A: 传输层,全双工</p>
<p>Q: TCP的通讯的过程是怎么样的!</p>
<p>A: 整个过程是三次握手,四次挥手..</p>
<p>Q: 你说的没错,说说整个过程如何?</p>
<p>A: 举个栗子,我把 TCP 比做两个人用对讲机沟通(大白话)..三次握手就是.A1(吼叫方,客户端)想要呼叫 A2(控制室的某某,服务端)..</p>
<p>A1对着对讲机说”over over ,听到请回答”(第一次,请求应答) …</p>
<p>A2收到回应”收到收到,你说”(第二次,确认应答)</p>
<p>A1开始巴拉巴拉个不停而 A2没拒绝(第三次,通讯建立)</p>
<hr>
<p>而四次挥手则是两者确认互相倾述完毕的过程..</p>
<p>A1说:”控制室,报告完毕了”(第一次挥手)</p>
<p>A2说:”知道了…那么你废话说完就好好听我指挥….巴拉巴拉..”(第二次挥手)</p>
<p>A1此时等待控制室说完毕,而控制室等回应(第三次挥手)</p>
<p>等到 A1回馈控制室确认都知道完毕了..(第四次挥手)…</p>
</blockquote>
<p><strong>以上都是瞎掰,可能有些地方描述不当,笑笑就好了</strong></p>
<p><code>TCP</code>没有百分百建立成功的,会造成链接失败的情况有很多..</p>
<p>比如长时间没应答(A1吼了半天没有反应或者 A2应答了而 A1不再鸟它)..亦或者丢包(对讲机也没了);</p>
<p><code>TCP</code> 协议相关的文章网上很多,若是要更加全面的了解该协议请自行引擎..</p>
<p>我建议阅读&lt;&lt;<strong>TCP-IP详解卷1~卷3</strong>&gt;&gt;,这个是网络圣经…很厚…我只看了一丢丢..</p>
<hr>
<h3 id="Q-TCP-你了解了-那么-OSI-七层协议和五层网络架构应该知道吧"><a href="#Q-TCP-你了解了-那么-OSI-七层协议和五层网络架构应该知道吧" class="headerlink" title="Q: TCP 你了解了,那么 OSI 七层协议和五层网络架构应该知道吧?"></a>Q: TCP 你了解了,那么 OSI 七层协议和五层网络架构应该知道吧?</h3><p>对于这类的问题我也只能大体点了下,毕竟不是专攻网络这块的…</p>
<p><code>OSI</code> 七层涵盖:物理层,数据链路层,网络层,传输层,会话层,表示层,应用层;</p>
<p>五层模型就是”会话,表示,应用层”同为一层;</p>
<p>Q: <code>DNS</code> 的大体的执行流程了解么,属于哪个层级?工作在哪个层级?</p>
<p><code>DNS</code> 属于应用层协议, 至于<code>TCP/UDP</code>哪一层上面跑,看情况 , 大体的执行流程是这样的; <strong>DNS 默认端口是53,走 UDP</strong></p>
<ol>
<li>优先读取浏览器缓存</li>
<li>其次系统的缓存</li>
<li>都没有的情况下,找本地<code>hosts</code>文件(比如你写了映射关系优先寻找)</li>
<li>再没有的情况找最近的域名解析服务器</li>
<li>再没有则扩大访问,最终找到根服务器,还是没有就失败了..</li>
</ol>
<p>DNS 的解析的几个记录类型需要了解:</p>
<ul>
<li><code>A</code>: 域名直接到 IP</li>
<li><code>CNAME</code>: 可以多个域名映射到一个主机,类似在 <code>Github Page</code>就用 <code>CNAME</code> 指向</li>
<li><code>MX</code>: 邮件交换记录,用的不多,一般搭建邮件服务器才会用到</li>
<li><code>NS</code>: 解析服务记录,可以设置权重,指定谁解析</li>
<li><code>TTL</code>: 就是生存时间(也叫缓存时间),一般的域名解析商都有默认值,也可以人为设置</li>
<li><code>TXT</code>: 一般指某个主机名或域名的说明</li>
</ul>
<p>回来我找下相关的资料,有兴趣的可以深入了解下,传送门如下:</p>
<ul>
<li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.cnblogs.com%2Fkevingrace%2Fp%2F5909719.html" target="_blank" rel="noopener">梳理Linux下OSI七层网络与TCP/IP五层网络架构</a></li>
<li><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.html5rocks.com%2Fzh%2Ftutorials%2Ffile%2Fxhr2%2F" target="_blank" rel="noopener">TCP/IP（六）应用层（DNS和HTTP协议）</a></li>
<li><a href="https://link.juejin.im?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F28305778" target="_blank" rel="noopener">DNS域名解析解剖</a></li>
</ul>
<hr>
<h3 id="Q-HTTP-和-HTTPS-有何差异-听说过-SPDY-么"><a href="#Q-HTTP-和-HTTPS-有何差异-听说过-SPDY-么" class="headerlink" title="Q: HTTP 和 HTTPS 有何差异? 听说过 SPDY 么?"></a>Q: HTTP 和 HTTPS 有何差异? 听说过 SPDY 么?</h3><p>我只是粗浅的回答了下…</p>
<p><code>HTTP</code>相对于 <code>HTTPS</code>来说,速度较快且开销较小(没有 SSL/TSL) 对接,默认是80端口;</p>
<p><code>HTTP</code>容易遭受域名劫持,而<code>HTTPS</code>相对来说就较为安全但开销较大(数据以加密的形式传递),默认端口为443..</p>
<p><code>HTTP</code>是明文跑在 <code>TCP</code> 上.而<code>HTTPS</code>跑在<code>SSL/TLS</code>应用层之下,<code>TCP</code>上的</p>
<p>Q: 那么 <code>HTTPS</code>中的<code>TLS/SSL</code>是如何保护数据的…</p>
<p>一般有两种形式,非对称加密,生成公钥和私钥,私钥丢服务器,公钥每次请求去比对验证;</p>
<p>更严谨的采用 CA(Certificate Authority),给密钥签名….</p>
<p>Q: 你说到对称加密和非对称加密,能说说整个流程如何运转的么(HTTPS)</p>
<ul>
<li>对称加密:<ul>
<li>双方都有同样的密钥,每次通讯都要生成一个唯一密钥,速度很快</li>
<li>安全性较低且密钥增长的数量极快</li>
</ul>
</li>
<li>非对称加密(一般用 RSA)<ul>
<li>安全性很高,对资源消耗很大(CPU),目前主流的加密算法(基本用于交换密钥或签名,而非所有通讯内容)</li>
</ul>
</li>
<li>CA(数字签名):<ul>
<li>这个是为了防止中间人给偷换了造成数据被窃取而诞生的</li>
<li>用一些权威机构颁布的算法来签名,权威机构做中间人,通讯过程都会跟机构核对一遍</li>
</ul>
</li>
</ul>
<blockquote>
<p>懂得真心不多,回来找了下相关资料,有兴趣可以点击看看;</p>
</blockquote>
<ul>
<li><a href="https://link.juejin.im?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F22142170" target="_blank" rel="noopener">深入揭秘HTTPS安全问题&amp;连接建立全过程</a></li>
<li><a href="https://link.juejin.im?target=https%3A%2F%2Fklionsec.github.io%2F2017%2F07%2F31%2Fhttps-learn%2F" target="_blank" rel="noopener">深入理解 https 通信加密过程:口语化</a> “ : 看了上面那篇文章来看下面,会清晰很多</li>
</ul>
<p>Q: <code>SPDY</code> 听说过么.什么来的?</p>
<p>谷歌推行一种协议(<code>HTTP</code> 之下SSL之上[TCP]),可以算是HTTP2的前身,有这么些优点</p>
<ul>
<li>压缩数据(HEADER)</li>
<li>多路复用</li>
<li>优先级(可以给请求设置优先级)</li>
</ul>
<p>而这些优点基本 HTTP2也继承下来了..</p>
<p>Q: 你对 HTTP 的状态吗了解多少…</p>
<p>这里列举一丢丢常见的..</p>
<ul>
<li>1XX: 一般用来判断协议更换或者确认服务端收到请求这些<ul>
<li>100: 服务端收到部分请求,若是没有拒绝的情况下可以继续传递后续内容</li>
<li>101: 客户端请求变换协议,服务端收到确认</li>
</ul>
</li>
<li>2xx: 请求成功,是否创建链接,请求是否接受,是否有内容这些<ul>
<li>200: (成功)服务器已成功处理了请求。</li>
<li>201: (已创建)请求成功并且服务器创建了新的资源。</li>
<li>202: (已接受)服务器已接受请求，但尚未处理。</li>
<li>204: (无内容)服务器成功处理了请求，但没有返回任何内容。</li>
</ul>
</li>
<li>3XX: 一般用来判断重定向和缓存<ul>
<li>301: 所有请求已经转移到新的 url(永久重定向),会被缓存</li>
<li>302: 临时重定向,不会被缓存</li>
<li>304: 本地资源暂未改动,优先使用本地的(根据<code>If-Modified-Since or If-Match</code>去比对服务器的资源,缓存)</li>
</ul>
</li>
<li>4XX: 一般用来确认授权信息,请求是否出错,页面是否丢失<ul>
<li>400: 请求出错</li>
<li>401: 未授权,不能读取某些资源</li>
<li>403: 阻止访问,一般也是权限问题</li>
<li>404: 页面丢失,资源没找到</li>
<li>408: 请求超时</li>
<li>415: 媒介类型不被支持，服务器不会接受请求。</li>
</ul>
</li>
<li>5XX: 基本都是服务端的错误<ul>
<li>500: 服务端错误</li>
<li>502: 网关错误</li>
<li>504: 网关超时</li>
</ul>
</li>
</ul>
<hr>
<p>Q: HTTP的请求报文是怎么样的,能大体的说下么?</p>
<p>HTTP 的请求报文 = 请求行 + 请求头 + 请求体;</p>
<ul>
<li>请求行: 这个好理解就是访问的方法+ 协议+ 访问的 URL 构成</li>
<li>请求头: 这个也好理解,比如 <code>accept</code>,<code>content-type</code>,<code>user-agent</code>这类值键对,服务端可以直接读取的</li>
<li>请求体: 比如 POST 提交的一个表单,我们编码后放在上面需要传递的</li>
</ul>
<p>想深入了解的具体引擎搜索</p>
<p>Q: 请求报文知道,那你说说<code>cookie</code>是如何跟随请求的?</p>
<p>Cookie 就是保存在 HTTP 协议的请求或者应答头部(Cookie 是由服务端生成),这样一路漂泊…</p>
<p>Q: Cookie 隔离是什么,如何做;</p>
<blockquote>
<p>cookie 隔离就是降低 <code>header</code> 的数据包含,以达到加快访问速度的目的</p>
</blockquote>
<p>方案: 静态资源丢 CDN或者非主域来加载</p>
<hr>
<h3 id="Q-浏览器缓存和服务端的缓存控制你了解多少-说说看"><a href="#Q-浏览器缓存和服务端的缓存控制你了解多少-说说看" class="headerlink" title="Q: 浏览器缓存和服务端的缓存控制你了解多少,说说看?"></a>Q: 浏览器缓存和服务端的缓存控制你了解多少,说说看?</h3><ul>
<li><code>Last-Modified</code>:<ul>
<li>第一次请求资源从服务器拉取的会自动带上该属性</li>
<li>第二次请求会跟服务端比对<code>If-Modified-Since</code>的时间,没变动则使用本地的(状态304)</li>
<li>结合<code>Expires(过期时间:缓存的载止时间)</code>,跟随请求一起发出..资源没过期拿本地,否则重新请求</li>
</ul>
</li>
<li><code>Cache-control</code> 是 <code>HTTP1.1</code>的东西,判断资源过期结合<code>max-age</code>来替代<code>Expires[http 1.0]</code></li>
<li><code>Etag</code>:<ul>
<li>第一次请求url 时候会给服务器上标记(一串字符串)</li>
<li>第二次请求时候会比对服务端的<code>If-None-Match</code>,没有改动依旧拿缓存(304)</li>
</ul>
</li>
</ul>
<hr>
<h3 id="Q-几个短而让我印象深刻的题"><a href="#Q-几个短而让我印象深刻的题" class="headerlink" title="Q: 几个短而让我印象深刻的题"></a>Q: 几个短而让我印象深刻的题</h3><pre><code>if(!(&quot;a&quot; in window)){
    var a = 10;
}
console.log(a); // undefined

// !(&quot;a&quot; i n window)  , 返回 true
// 留言小伙伴的刨析,非常感谢,还是涉及变量提升的问题
/*
 var a;
if(!(&quot;a&quot; in window)){
    a = 10;
}
*/

// 变种题
(function(){
 var  x = c =  b = {a:1}
})()

console.log(x.a); // error , x is not defined
console.log(c,b) // {a: 1} {a: 1}


复制代码

var count = 0;

console.log(typeof count === &quot;number&quot;); // true , 这个不用解释了

console.log(!!typeof count === &quot;number&quot;); // false

// 这里涉及到就是优先级和布尔值的问题
// typeof count 就是字符串&quot;number&quot;
// !!是转为布尔值(三目运算符的变种),非空字符串布尔值为 true
// 最后才=== 比较 , true === &quot;number&quot; , return false

复制代码


(function(){
  var a = b = 3;
})()

console.log(typeof a === &quot;undefined&quot;); // false
console.log(typeof b === &quot;undefined&quot;); // false

// 这里涉及的就是立即执行和闭包的问题,还有变量提升,运算符执行方向(=号自左向右)
// 那个函数可以拆成这样

(function()
  var a; /* 局部变量,外部没法访问*/
  b = 3; /* 全局变量,so . window.b === 3 , 外部可以访问到*/
  a = b;
})()

// 若是改成这样,这道题应该是对的
console.log(typeof b === &quot;number&quot; &amp;&amp; b ===3
); // true


复制代码


function foo(something){
  this.a = something;
}

var obj1 = {
  foo:foo
};

var obj2 = {};

obj1.foo(2)

console.log(obj1.a) // 2 ,此时的 this 上下文还在 obj1内,若是 obj1.foo 先保存当做引用再执行传参,则上下文为 window

obj1.foo.call(obj2,3); // 用 call 强行改变上下文为 obj2内
console.log(obj2.a); // 3

var  bar = new obj1.foo(4); // 这里产生了一个实例
console.log(obj1.a); // 2
console.log(bar.a); // 4;  new的绑定比隐式和显式绑定优先级更高


复制代码

function fn(){
 alert(a);
 var a = 200;
 alert(a);
}

fn(); // undefined / 200 ; 涉及变量提升
alert(a); // undefined
var a;
alert(a); // undefined

var a = 300;
alert(a); // 300

复制代码

var obj1= {
  name:&apos;obj1&apos;,
  fn:function(){
    console.log(this.name);
  }
};

var obj2 = {name:&apos;obj2&apos;};
var obj3 = {name:&apos;obj3&apos;};

// 这道题主要涉及的是 this 指向的问题..
obj1.fn(); // obj1

var newFn = obj1.fn;
newFn(); // undefined, this 指向 window

newFn.call(obj2);// obj2, this 指向 obj2

obj3.fn = newFn;
/*
ƒ (){
    console.log(this.name);
  }
*/

obj3.fn(); // 这里指向的是 obj3 .所以输出 obj3




复制代码


// 这道题来作为笔试题很绕,因为要回答的答案很多(脑海构思)..反正我是遇到了..
// 这道题主要考核的是对原型链继承这块的理解
function Parent(){
  this.a = 1;
  this.b = [1,2,this.a];
  this.c = {demo:5};
  this.show = function(){
   console.log(this.a + &apos;&apos; + this.c.demo + &apos;:&apos; + this.b)
  }
}

function Child(){
  this.a  = 2;
  this.change = function(){
    this.b.push(this.a);
    this.a = this.b.length;
    this.c.demo = this.a++;
  }

}

Child.prototype = new Parent();
var parent = new Parent();
var child1 = new Child();
var child2 = new Child();

child1.a = 11;
child2.a = 12;

// 这前面几个还算简单,继续看下去
parent.show(); // 15:1,2,1

// 因为 Child 自身没有 show 的方法,所以往原型链的上游找;
// 找到父类的,this 因为没更改,所以输出结果如下
child1.show(); // 115:1,2,1
child2.show(); // 125:1,2,1

child1.change();  // 改变一些数据,没有输出
child2.change();  // +1

parent.show(); // 15:1,2,1

child1.show(); // 55:1,2,1,11,12
child2.show(); // 65:1,2,1,11,12

复制代码


// 这道题也很绕,函数递归调用的


function test(a,b){
  console.log(b);
  return {
    test:function(c){
       return test(c,a);
    }
};

// 这道题的理解,拆成这样就好理解了
/*function test(a,b){
  console.log(&quot;a:&quot;+a,&quot;b:&quot;+b);
  return {
    test:function(c){
       console.log(&quot;a:&quot;+a,&quot;b:&quot;+b,&quot;c&quot;+c);
       return test(c,a);
    }
  }

}*/



var a = test(100); // undefined, 这个是不言而喻的;
a.test(200); //  100;
a.test(300); // 100;

var b =  test(101).test(201).test(301); // undefined/101/201


var c =  test(102).test(202); // undefined / 102

c.test(302); // 202


复制代码
</code></pre><hr>
<h3 id="Q-有字符串-var-test-’abc345efgabcab’-请根据提示实现对应要求"><a href="#Q-有字符串-var-test-’abc345efgabcab’-请根据提示实现对应要求" class="headerlink" title="Q:有字符串 var test=’abc345efgabcab’; 请根据提示实现对应要求"></a>Q:有字符串 var test=’abc345efgabcab’; 请根据提示实现对应要求</h3><ul>
<li>去掉字符串中的 a,b,c 字符 ,形成结果’345efg’;</li>
</ul>
<pre><code>test.replace(/[abc]/g,&apos;&apos;); // &quot;345efg&quot;

复制代码
</code></pre><ul>
<li>将字符串的数字用括号括起来, 形成结果: abc[3][4][5]efg….’</li>
</ul>
<pre><code>test.replace(/\d/g,&apos;[$&amp;]&apos;);  // &quot;abc[3][4][5]efgabcab&quot;

// 若是有分组则按照$1, $2, $3的形式进行引用，而 $&amp; 则表示的是整个正则表达式匹配的内容。

复制代码
</code></pre><ul>
<li>将字符串中的每个数字的值分别乘以2,输出:’abc6810….’</li>
</ul>
<pre><code>var temp = test.split(&apos;&apos;).map(function(item){
  return /^\d$/.test(item) ? item * 2 : item;
}).join(&apos;&apos;);

// &quot;abc6810efgabcab&quot;



复制代码
</code></pre><hr>
<h3 id="Q-使用不少于三种方式替换文本-quot-dream-quot-改成-quot-package-quot-提供字符串-quot-I-have-a-dream-quot"><a href="#Q-使用不少于三种方式替换文本-quot-dream-quot-改成-quot-package-quot-提供字符串-quot-I-have-a-dream-quot" class="headerlink" title="Q: 使用不少于三种方式替换文本&quot;dream&quot;改成&quot;package&quot;,提供字符串&quot;I have a dream&quot;;"></a>Q: 使用不少于三种方式替换文本<code>&quot;dream&quot;</code>改成<code>&quot;package&quot;</code>,提供字符串<code>&quot;I have a dream&quot;</code>;</h3><ul>
<li><p>正则替换</p>
<p>// 这是最简单的代码量了..<br>var str = “I have a dream”;<br>str.replace(/dream/g,”package”);</p>
<p>// 不用正则也可以直接字符串替换<br>str.replace(“dream”,”package”)</p>
<p>复制代码</p>
</li>
<li><p>数组遍历更改</p>
<p>// 很直白的大脑回路<br>var str = “I have a dream”;</p>
<p>str.split(“ “).map(function(item){<br> return  item === “dream” ? item = “package”:item;<br>}).join(“ “);</p>
<p>复制代码</p>
</li>
<li><p>数组查询切割法</p>
<p>var str = “I have a dream”;</p>
<p>var tempArr = str.split(“ “); // [“I”, “have”, “a”, “dream”]<br>var removeIndex = tempArr.indexOf(‘dream’); // 3</p>
<p>tempArr.splice(removeIndex,1,”package”);</p>
<p>var transStr = tempArr.join(“ “); // “I have a package”;</p>
<p>复制代码</p>
</li>
</ul>
<p><strong>这类东东弄成数组还是挺好弄的</strong></p>
<p>这个是留言区小伙伴提供的方法..大同小异,如下;</p>
<pre><code>// 源代码
// 字符串也有数组的 slice 以及 concat 的方法..思路和数组差不多
var str = &apos;I haved a dream&apos;;
str.indexOf(&apos;dream&apos;) !== -1 ? str.slice(0,str.indexOf(&apos;dream&apos;)).concat(&apos;package&apos;):str;



复制代码
</code></pre><hr>
<h3 id="Q-还有一道题目是涉及事件循环-执行优先权的"><a href="#Q-还有一道题目是涉及事件循环-执行优先权的" class="headerlink" title="Q: 还有一道题目是涉及事件循环,执行优先权的.."></a>Q: 还有一道题目是涉及事件循环,执行优先权的..</h3><p>就是 <code>macrotask</code>和<code>microtask</code> 相关的, 具体记不起来了..那时候给了答案虽然对了.</p>
<p>要说出所以然,给秀了一脸..回来找了下相关的资料;</p>
<ul>
<li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.ruanyifeng.com%2Fblog%2F2014%2F10%2Fevent-loop.html" target="_blank" rel="noopener">JavaScript 运行机制详解：再谈Event Loop</a></li>
<li><a href="https://link.juejin.im?target=https%3A%2F%2Fjuejin.im%2Fpost%2F5a2e21486fb9a0450407d370" target="_blank" rel="noopener">深入理解事件循环和异步流程控制</a></li>
<li><a href="https://link.juejin.im?target=https%3A%2F%2Fjuejin.im%2Fpost%2F5984816a518825265674c8f6" target="_blank" rel="noopener">所有你需要知道的关于完全理解 Node.js 事件循环及其度量</a></li>
</ul>
<hr>
<h3 id="Q-你对基础算法这块掌握的如何…"><a href="#Q-你对基础算法这块掌握的如何…" class="headerlink" title="Q: 你对基础算法这块掌握的如何…."></a>Q: 你对基础算法这块掌握的如何….</h3><blockquote>
<p>来,这纸给你,写个快排试试…</p>
</blockquote>
<pre><code>// 快排的大体思路是这样的,
// 找个中位值,从原数组切割出来,
// 剩下的作为两个数组,每次都去比较;
// 直到递归的结果出来, 平均复杂度O(nlog n)

function quickSort(arr) {
  //如果数组长度&lt;=1,则直接返回
  if (arr.length &lt;= 1) {
    return arr;
  }
  // 中间位(基准)取长度的一半向下取整
  var pivotIndex = Math.floor(arr.length / 2);
  //把中间位从原数组切割出来, splice 会改变原数组!!!!
  var pivot = arr.splice(pivotIndex, 1)[0];
  //定义两个空数组来存放比对后的值
  var left = [];
  var right = [];

  //比基准小的放在left，比基准大的放在right
  for (var i = 0 , j = arr.length; i &lt; j; i++) {
    if (arr[i] &lt;= pivot) {
      left.push(arr[i]);
    } else {
      right.push(arr[i]);
    }
  }
  //递归下去  arr = [ left , pivot , right]
  // 怎么个递归法,就是比对后的数组还是会重复之前的取基准再切开比较..直到最后没有可以切了
  return quickSort(left).concat([pivot], quickSort(right));
}

复制代码
</code></pre><p>Q: 写一个二分法查找</p>
<pre><code>// 二分法跟快排的思路差不多,对半比较
// 这个只用于排序好数组内的查询,高低位都知道的情况下
function binSearch(target, arr, start, end) {
  var start = start || 0; // 允许从什么位置开始,下标
  var end = end || arr.length - 1; // 什么位置结束,下标
  start &gt;= end ? -1 : &apos;&apos;; // 没有找到,直接返回-1
  var mid = Math.floor((start + end) / 2); // 中位下标
  if (target == arr[mid]) {
    return mid; // 找到直接返回下标
  } else if (target &gt; arr[mid]) {
    //目标值若是大于中位值,则下标往前走一位
    return binSearch(target, arr, start, mid - 1);
  } else {
    //若是目标值小于中位值,则下标往后退一位
    return binSearch(target, arr, mid + 1, end);
  }
}

// binSearch(5,[1,2,3,4,5,6,7,8]) =&gt; 4

// 无序的数组则需要先排序好数组,否则会堆栈溢出(死循环)

复制代码
</code></pre><p>这类的文章很多,有兴趣的可以阅读下面的一些文章</p>
<p>传送门:</p>
<ul>
<li><a href="https://link.juejin.im?target=https%3A%2F%2Fjuejin.im%2Fpost%2F57dcd394a22b9d00610c5ec8" target="_blank" rel="noopener">&lt;&lt;十大经典排序算法总结（JavaScript描述&gt;&gt;</a></li>
<li><a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fzoro-web%2Fblog%2Fissues%2F4" target="_blank" rel="noopener">JavaScript数据结构和算法</a></li>
<li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.cnblogs.com%2Fxianyulaodi%2Fp%2F6001122.html" target="_blank" rel="noopener">javascript 常见排序算法</a></li>
</ul>
<hr>
<h3 id="Q-设计模式你了解多少"><a href="#Q-设计模式你了解多少" class="headerlink" title="Q: 设计模式你了解多少?"></a>Q: 设计模式你了解多少?</h3><ul>
<li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.cnblogs.com%2Ftugenhua0707%2Fp%2F5198407.html" target="_blank" rel="noopener">Javascript常用的设计模式详解</a></li>
<li><a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FToNiQian%2Fjs-design-pattern" target="_blank" rel="noopener">js-design-pattern</a></li>
</ul>
<hr>
<h3 id="Q-思维拓展题-你有两个玻璃球-有个100米的高楼-求玻璃球在哪个楼层扔下会碎-用的次数最少"><a href="#Q-思维拓展题-你有两个玻璃球-有个100米的高楼-求玻璃球在哪个楼层扔下会碎-用的次数最少" class="headerlink" title="Q: 思维拓展题: 你有两个玻璃球,有个100米的高楼,求玻璃球在哪个楼层扔下会碎(用的次数最少);"></a>Q: 思维拓展题: 你有两个玻璃球,有个100米的高楼,求玻璃球在哪个楼层扔下会碎(用的次数最少);</h3><p>问题的要点: 玻璃球碎(有限个数) ,确定楼层数 , 最少次数 => 就是求最优的公式</p>
<p>在这道题上给秀的一脸,我的第一次的思路</p>
<blockquote>
<p>先折半,就变成[1-50][51-100], 那就是 1+50 = 51次 …</p>
</blockquote>
<p>面试大佬说,你用了快排的思路就肯定不是最优的..</p>
<blockquote>
<p>憋了许久,想到开平方 <img src="https://juejin.im/equation?tex=%5Csqrt%5B2%5D%7B100%7D" alt="\sqrt[2]{100}"> , 这样的话,最多只要20次</p>
</blockquote>
<p>然后又说给我三个球,在1000米的高楼,判断多少次…但是根据我上面的话,</p>
<blockquote>
<p>开立方, <img src="https://juejin.im/equation?tex=%5Csqrt%5B3%5D%7B1000%7D" alt="\sqrt[3]{1000}"> , 那最多不超过30次;</p>
</blockquote>
<p>至于第一次丢球的位置如何确定, 就是开平之后的值作为一个区间.</p>
<p>若 N 个球和 M 米的大厦…第一次丢球的高度区间就是这个了<img src="https://juejin.im/equation?tex=%5Cfrac%7Bm%7D%7B%5Csqrt%5Bn%5D%7Bm%7D%7D" alt="\frac{m}{\sqrt[n]{m}}"></p>
<p>面试大佬说这个还可以…那就暂且告一段落</p>
<p>…回来用万能的搜索引擎找了下..最优方案+最少次数需要考虑的东西很多,没那么简单</p>
<p>传送门: <a href="https://link.juejin.im?target=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F31855632" target="_blank" rel="noopener">知乎有人讨论了这个问题</a>;</p>
<p>但是高数还老师了..这种帖子看的一脸懵逼….抽空再好好研究下</p>
<hr>
<h3 id="Q-你对优化这块了解多少"><a href="#Q-你对优化这块了解多少" class="headerlink" title="Q: 你对优化这块了解多少?"></a>Q: 你对优化这块了解多少?</h3><p>大体常见的手段了解.</p>
<p>比如从客户端着手的:</p>
<ul>
<li>压缩代码(JS/CSS),压缩图片</li>
<li>合并一些小图片(<code>css sprite</code>)</li>
<li>若是打包的代码尽可能切割成多个 <code>chunk</code>,减少单一 <code>chunk</code>过大</li>
<li>静态文件采用 cdn 引入</li>
<li>HTTP的缓存头使用的合理</li>
<li>减小第三方库的依赖</li>
<li>对于代码应该考虑性能来编写,比如使用<code>requestAnimationFrame</code>绘制动画,尽可能减少页面重绘(DOM 改变)</li>
<li>渐进升级,引入<code>preload</code>这些预加载资源</li>
<li>看情况用<code>service worker</code>来缓存资源(比如移动端打算搞 PWA)</li>
</ul>
<p>比如从服务端着手:</p>
<ul>
<li>带宽,域名解析, 多域名解析等</li>
<li>页面做服务端渲染,减小对浏览器的依赖(不用客户端解析)</li>
<li>渐进升级,比如引入 HTTP2(多路复用,头部压缩这些可以明显加快加载速度)</li>
</ul>
<p>当然,这是这些都是很片面的点到…实际工作中去开展要复杂的多;</p>
<p>比如我们要多个维度去考虑的话,要去优化 DOM 的绘制时间,资源的加载时间,域名解析这些;</p>
<p>要全面的优化一个项目是一个大工程…</p>
<hr>
<h3 id="Q-MySQL有哪些索引类型-索引的数据结构储存方式-MySQL和-MongoDB的差异"><a href="#Q-MySQL有哪些索引类型-索引的数据结构储存方式-MySQL和-MongoDB的差异" class="headerlink" title="Q: MySQL有哪些索引类型? 索引的数据结构储存方式? MySQL和 MongoDB的差异"></a>Q: MySQL有哪些索引类型? 索引的数据结构储存方式? MySQL和 MongoDB的差异</h3><p>MySQL索引类型:</p>
<ul>
<li>普通索引: 就普通的类型</li>
<li>唯一索引: 代表索引的值唯一不重复(允许有空值),相对于上面多了个<code>UNIQUE</code></li>
<li>主键索引:(创建表的跟随创建,唯一索引，不允许有空值)</li>
<li>组合索引(就是将多个字段都建立到一个索引)</li>
</ul>
<p>索引有利有弊,用的好加快查询速度,滥用索引会造成大量磁盘空间占用,维护性也会增多; 索引不会包含<code>null</code>的列;</p>
<p>索引的数据结构储存方式,我只简单了解过<code>B-Tree</code></p>
<p>至于MySQL 和 MongoDB的差异;</p>
<p>前者是关系型数据库, 后者非关系型数据库(数据是以文档的方式储存,值为 <code>key-value</code>);</p>
<p><code>MySQL</code>应用层面很广,有事务系统这些,链表查询这些都很方便.经常作为很多系统的主力数据库</p>
<p>而<code>MongoDB</code>作为<code>NoSQL</code>,虽然有些层面不如 <code>MySQL</code>,但是应用层面也挺广, 比如结合前端做一些用户的概要信息的维护,一些缓存信息的维护.</p>
<blockquote>
<p>em….后端了解不多,也能点到即止….大学的时候学过一些..都差不多还给老师….</p>
</blockquote>
<hr>
<h3 id="Q-JS时间分段"><a href="#Q-JS时间分段" class="headerlink" title="Q: JS时间分段"></a>Q: JS时间分段</h3><blockquote>
<p>给定一个时间段和步长，枚举该时间段内步长的划分</p>
<p>例如：时间段<code>3:00-5:00</code>，步长为<code>20</code>分钟</p>
<p>那么返回的数组为</p>
<p><code>[&#39;3:00-3:20&#39;, &#39;3:20-3:40&#39;....]</code>等</p>
</blockquote>
<p>这类问题,一般都要先梳理好思路再来写;</p>
<ul>
<li>给定字符串时间段,切割,转换为分钟</li>
<li>跨日及跨时问题</li>
</ul>
<pre><code>// 这个东东我的小伙伴也写出来了.我的是在它的解答方式上加以注释和对参数的判断做了考虑
// 他的解法方案在他的 github 上 https://github.com/lyh2668/blog/issues/1 , by lyh2668
// 方便一些小伙伴的理解,以下代码包含ES6的姿势(参数默认值,剪头函数)

let inputDateRange = (date, step = 30, separator = &apos;-&apos;) =&gt; {
  let startTime, endTime; // 开始时间和结束时间

  if (Object.prototype.toString.call(date) === &apos;[object String]&apos;) {
    date = date.trim(); // 去除两边的空格
    var tempDate = &apos;&apos;;
    if (separator) {
      tempDate = date.split(separator);
    } else {
      if (date.indexOf(&apos;-&apos;) !== -1) {
        tempDate = date.split(&apos;-&apos;);
      } else if (date.indexOf(&apos;~&apos;)) {
        tempDate = date.split(&apos;~&apos;);
      } else {
        console.log(&apos;您传入的也许不是一个时间段!!!&apos;);
      }
    }
    startTime = time2min(tempDate[0]); // 传入的开始时间
    endTime = time2min(tempDate[1]); //传入的结束时间
  } else if (Object.prototype.toString.call(date) === &apos;[object Array]&apos;) {
    if (date.length === 2) {
      startTime = time2min(date[0]); // 传入的开始时间
      endTime = time2min(date[1]); //传入的结束时间
    }
  } else {
    console.log(&apos;您传入的也许不是一个时间段!!!&apos;);
  }

  // 传入的 step 是否为数字,否则截图数字部分转化
  // 为什么和 NaN 比较(自身不等性),若是传入的连正则都没法识别,那只能给默认值了
  Object.prototype.toString.call(step) === &apos;[object Number]&apos;
    ? (step = parseInt(step, 10))
    : parseInt(step.replace(/[W\s\b]/g, &apos;&apos;), 10) === NaN
      ? (step = parseInt(step.replace(/[W\s\b]/g, &apos;&apos;), 10))
      : (step = 30);

  // 若是开始时间大于结束时间则结束时间往后追加一天
  startTime &gt; endTime ? (endTime += 24 * 60) : &apos;&apos;;

  let transformDate = []; // 储存转换后的数组,时间分段

  // 开始遍历判断,用 while
  while (startTime &lt; endTime) {
    // 如果开始时间+步长大于结束时间,则这个分段结束,否则结束时间是步长递增
    let right = startTime + step &gt; endTime ? endTime : startTime + step;
    transformDate.push(`${min2time(startTime)}-${min2time(right)}`);
    startTime += step; // 步长递增
  }
  return transformDate;
};

// 时间转化为分钟
let time2min = time =&gt; {
  // 获取切割的
  time.indexOf(&apos;:&apos;) ? (time = time.trim().split(&apos;:&apos;)) : &apos;&apos;;
  return time[0] * 60 + parseInt(time[1]); // 返回转化的分钟
};

// 分钟转会字符串时间
let min2time = minutes =&gt; {
  let hour = parseInt(minutes / 60); // 返回多少小时
  let minute = minutes - hour * 60; // 扣除小时后剩余的分钟数

  hour &gt;= 24 ? (hour = hour - 24) : &apos;&apos;; // 若是大于等于24小时需要扣除一天得到所剩下的小时
  minute &lt; 10 ? (minute = &apos;0&apos; + minute) : &apos;&apos;; // 小于10的都要补零
  hour &lt; 10 ? (hour = &apos;0&apos; + hour) : &apos;&apos;; // 小于10的都要补零
  return `${hour}:${minute}`;
};


// test ,支持字符串传入时间段
inputDateRange(&apos;3:00-5:00&apos;,&apos;20d&apos;); // [&quot;03:00-03:20&quot;, &quot;03:20-03:40&quot;, &quot;03:40-04:00&quot;, &quot;04:00-04:20&quot;, &quot;04:20-04:40&quot;, &quot;04:40-05:00&quot;]

// 亦或者数组传入
inputDateRange([&apos;3:00&apos;,&apos;5:00&apos;],&apos;45df.3d&apos;); // [&quot;03:00-03:45&quot;, &quot;03:45-04:30&quot;, &quot;04:30-05:00&quot;]

// step 支持数字亦或者带特殊字符的数字
inputDateRange([&apos;6:00&apos;,&apos;8:00&apos;],&apos;55df.3d&apos;); // [&quot;06:00-06:55&quot;, &quot;06:55-07:50&quot;, &quot;07:50-08:00&quot;]

inputDateRange(&apos;3:00-5:00&apos;,60); // [&quot;03:00-04:00&quot;, &quot;04:00-05:00&quot;]


复制代码
</code></pre><ul>
<li><a href="https://link.juejin.im?target=https%3A%2F%2Fjuejin.im%2Fpost%2F598c32dcf265da3e3d12557d" target="_blank" rel="noopener">JS不靠谱系列之枚举出时间段和对应的分钟数</a></li>
</ul>
<hr>
<h3 id="Q-Vue-Router的两种模式主要依赖什么实现的"><a href="#Q-Vue-Router的两种模式主要依赖什么实现的" class="headerlink" title="Q: Vue-Router的两种模式主要依赖什么实现的"></a>Q: <code>Vue-Router</code>的两种模式主要依赖什么实现的</h3><ul>
<li><code>hash</code>主要依赖<code>location.hash</code>来改动 URL,达到不刷新跳转的效果.每次 <code>hash</code> 改变都会触发<code>hashchange</code>事件(来响应路由的变化,比如页面的更换)</li>
<li><code>history</code>主要利用了 <code>HTML5</code>的 <code>history</code>API 来实现,用<code>pushState</code>和<code>replaceState</code>来操作浏览历史记录栈</li>
</ul>
<hr>
<h3 id="Q-MVVM-和-MVC-的差异-听说过-MVP"><a href="#Q-MVVM-和-MVC-的差异-听说过-MVP" class="headerlink" title="Q: MVVM 和 MVC 的差异? 听说过 MVP?"></a>Q: MVVM 和 MVC 的差异? 听说过 MVP?</h3><p>这类的文章好多,三个开发模式的诞生都有前后,不是同时出现的.</p>
<p>传送门:</p>
<ul>
<li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.ruanyifeng.com%2Fblog%2F2015%2F02%2Fmvcmvp_mvvm.html" target="_blank" rel="noopener">MVC，MVP 和 MVVM 的图示</a></li>
<li><a href="https://link.juejin.im?target=https%3A%2F%2Fjuejin.im%2Fpost%2F593021272f301e0058273468" target="_blank" rel="noopener">浅析前端开发中的 MVC/MVP/MVVM 模式</a></li>
</ul>
<hr>
<h3 id="Q-求100-999的所有”水仙花”数-就是三位数中各数字的立方和等于自身-比如153-1-3-5-3-3-3"><a href="#Q-求100-999的所有”水仙花”数-就是三位数中各数字的立方和等于自身-比如153-1-3-5-3-3-3" class="headerlink" title="Q: 求100~999的所有”水仙花”数, 就是三位数中各数字的立方和等于自身,比如153=1^3+5^3+3^3"></a>Q: 求100~999的所有”水仙花”数, 就是三位数中各数字的立方和等于自身,比如<code>153=1^3+5^3+3^3</code></h3><ul>
<li><p>常规遍历法</p>
<p>function threeWaterFlower(rangeStart, rangeEnd) {<br>  var temp = [];<br>  rangeStart = rangeStart || 100;<br>  rangeEnd = rangeEnd || 999;<br>  for (var i = rangeStart; i &lt;= rangeEnd; i++) {</p>
<pre><code>var t = i.toString().split(&apos;&apos;);
Math.pow(t[0], 3) + Math.pow(t[1], 3) + Math.pow(t[2], 3) == i
  ? temp.push(i)
  : &apos;&apos;;
</code></pre><p>  }<br>  return temp;<br>}</p>
</li>
</ul>
<pre><code>threeWaterFlower(100,999); // [153, 370, 371, 407]

threeWaterFlower(); // [153, 370, 371, 407]


复制代码
</code></pre><ul>
<li>拓展写法,ES6版+不定花数,不折腾不舒服版本</li>
</ul>
<pre><code>let manyWaterFlower = (rangeStart = 100, rangeEnd = 999, flower = 3) =&gt; {
  let temp = [];
  for (let i = rangeStart; i &lt;= rangeEnd; i++) {
    let t = i
    .toString()
    .split(&apos;&apos;)
    .map(item =&gt; Math.pow(item, flower))
    .reduce((cur,next)=&gt; parseInt(cur)+parseInt(next));
    let transformT = parseInt(t, 10);
    transformT == i ? temp.push(i) : &apos;&apos;;
  }
  return temp;
}

manyWaterFlower(); // [153, 370, 371, 407]

manyWaterFlower(100,10000,4); // [1634, 8208, 9474]

manyWaterFlower(100,10000,5); // [4150, 4151]


复制代码
</code></pre><p>这种是穷举遍历,若是要快一点呢(考虑的周全一点呢),以及传参范围的矫正</p>
<p>相信小伙伴都看得懂,我已经尽量注释了..</p>
<pre><code>let manyWaterFlower = (flower = 3,rangeStart, rangeEnd ) =&gt; {
  let temp = [];// 缓存所有找到的花值

  // 这一段就是填充开始循环的范围,处理完毕后转为数字,推荐的开始值
  let flowerRecommandStart = Number(
    &apos;&apos;.padStart(flower, &apos;0&apos;).replace(/^(\d{1})/g, &apos;1&apos;)
  );
  let flowerRecommandEnd = Number(&apos;&apos;.padStart(flower, &apos;9&apos;));

  // 判断是否传入开始值
  if (rangeStart) {
    rangeStart &gt; flowerRecommandStart
      ? (rangeStart = flowerRecommandStart)
      : rangeStart;
  } else {
    rangeStart = flowerRecommandStart;
  }

  // 判断是否有传入结束值
  if (rangeEnd) {
    rangeEnd &gt; flowerRecommandEnd ? (rangeEnd = flowerRecommandEnd) : rangeEnd;
  } else {
    rangeEnd = flowerRecommandEnd;
  }

  // 若是初始值大于结束值
  if (rangeStart &gt; rangeEnd) {
    rangeEnd = flowerRecommandEnd;
  }

  for (let i = rangeStart; i &lt;= rangeEnd; i++) {
    let t = i
      .toString()
      .split(&apos;&apos;)
      .map(item =&gt; Math.pow(item, flower))
      .reduce((cur, next) =&gt; parseInt(cur) + parseInt(next));
    let transformT = parseInt(t, 10);
    transformT == i ? temp.push(i) : &apos;&apos;;
  }

  return temp;
};

console.time(&apos;manyWaterFlower&apos;);
manyWaterFlower(4)
console.timeEnd(&apos;manyWaterFlower&apos;);
// VM34013:4 manyWaterFlower: 8.112060546875ms ,这个是跑出来的时间

用上个例子的代码,从100到9999的,我们跑一下看看
console.time(&apos;manyWaterFlower&apos;);
manyWaterFlower(100,9999,4)
console.timeEnd(&apos;manyWaterFlower&apos;);
// VM3135:4 manyWaterFlower: 10.51904296875ms


// 我的 MBP 跑10花直接卡死...跑7花有点久...
console.time(&apos;7 flower&apos;)
manyWaterFlower(7);
console.timeEnd(&apos;7 flower&apos;)
// 7 flower: 6489.608154296875ms

// 8 花 CPU 的风扇狂叫....
console.time(&apos;8 flower&apos;)
manyWaterFlower(8);
console.timeEnd(&apos;8 flower&apos;)
// VM644:3 8 flower: 68010.26489257812ms

// 对了我们还没有考虑数值溢出的问题..因为正整数在 JS 的范围是有限的.
// 有兴趣的小伙伴可以自行完善

复制代码
</code></pre><hr>
<h3 id="Q-请使用递归算法在-TODO-注释后实现通过节点-key-数组寻找-json-对象中的对应值"><a href="#Q-请使用递归算法在-TODO-注释后实现通过节点-key-数组寻找-json-对象中的对应值" class="headerlink" title="Q: 请使用递归算法在 TODO 注释后实现通过节点 key 数组寻找 json 对象中的对应值"></a>Q: 请使用递归算法在 TODO 注释后实现通过节点 key 数组寻找 json 对象中的对应值</h3><p>比如console.log(findNode([‘a1’, ‘b2’], data)) === data.a1.b2</p>
<pre><code>// 请使用递归算法在 TODO 注释后实现通过节点 key 数组寻找 json 对象中的对应值

var data = {
  a1: {
    b1: 1,
    b2: 2,
    b3: {
      b4: 5
    }
  },
  a2: {
    b1: 3,
    b2: 4
  }
};

function findNode(inPath, inData) {
  // TODO

  // 判断传入的是否是一个数组
  if (Array.isArray(inPath)) {
    // 当长度为1的时候寻找该 key 是否有值,有则返回,无则返回-1
    if (inPath.length === 1) {
      return inData[inPath[0]] ? inData[inPath[0]]: -1;
    }else{
     return findNode(inPath.slice(1), inData[inPath[0]]);
    }
  } else{
    console.log(&apos;您传入的不是一个数组&apos;)
  }
}

console.log(findNode([&apos;a1&apos;, &apos;b2&apos;], data)); // 2
console.log(findNode([&apos;a1&apos;, &apos;b3&apos;,&apos;b4&apos;], data)); // 5


复制代码
</code></pre><ul>
<li>来个拓展版?支持字符串或数组传入;<code>findNode(&#39;a1.b2&#39;,data)</code>?</li>
</ul>
<pre><code>var data = {
  a1: {
    b1: 1,
    b2: 2,
    b3: {
      b4: 5
    }
  },
  a2: {
    b1: 3,
    b2: 4
  }
};

// 判断格式
function isType(params) {
  let type = Object.prototype.toString.call(params);
  if (type === &apos;[object String]&apos;) {
    params = params.split(&apos;.&apos;);
    return params;
  }
  if (type === &apos;[object Array]&apos;) {
    return params;
  }
}

function findNode(inPath, inData) {
  inPath = isType(inPath);
  // 判断传入的是否是一个数组
  if (Array.isArray(inPath)) {
    // 当长度为1的时候寻找该 key 是否有值,有则返回,无则返回-1
    if (inPath.length === 1) {
      return inData[inPath[0]] ? inData[inPath[0]]: -1;
    }else{
     return findNode(inPath.slice(1), inData[inPath[0]]);
    }
  } else {
    console.log(&apos;您传入的不是一个数组&apos;);
  }
}

console.log(findNode([&apos;a1&apos;, &apos;b2&apos;], data)); // 2

console.log(findNode(&apos;a1.b3.b4&apos;, data)); // 5



复制代码
</code></pre><hr>
<h3 id="Q-webpack-是什么-webpack-常见的优化手段有哪些"><a href="#Q-webpack-是什么-webpack-常见的优化手段有哪些" class="headerlink" title="Q: webpack 是什么?webpack 常见的优化手段有哪些;"></a>Q: webpack 是什么?webpack 常见的优化手段有哪些;</h3><p>webpack 是一个资源处理工具,它的出现节省了我们的人力和时间; 可以对资源打包,解析,区分开发模式等等…</p>
<p>常见的优化手段:</p>
<ul>
<li>分离第三方库(依赖),比如引入<code>dll</code></li>
<li>引入多进程编译,比如<code>happypack</code></li>
<li>提取公共的依赖模块,比如<code>commonChunkPlugin</code></li>
<li>资源混淆和压缩:比如<code>UglifyJS</code></li>
<li>分离样式这些,减小<code>bundle chunk</code>的大小,比如<code>ExtractTextPlugin</code></li>
<li>GZIP 压缩,在打包的时候对资源对齐压缩,只要部署的服务器能解析即可..减少请求的大小</li>
<li>还有按需加载这些,一般主流的框架都有对应的模块懒加载方式.</li>
<li>至于<code>tree shaking</code>目前webpack3/4已经默认集成</li>
</ul>
<hr>
<h3 id="Q-从你输入一个-URL-到页面渲染的大体过程…"><a href="#Q-从你输入一个-URL-到页面渲染的大体过程…" class="headerlink" title="Q: 从你输入一个 URL 到页面渲染的大体过程…"></a>Q: 从你输入一个 URL 到页面渲染的大体过程…</h3><p>大体过程是这样的,想了解很细致的可以自行引擎;</p>
<ol>
<li>IP-&gt;DNS(浏览器=&gt;系统缓存=&gt;DNS 服务器)-&gt;域名解析完成(这一步不用太多解析吧)</li>
<li>TCP 协议走完-&gt;HTTP(S) 协议-&gt;缓存-&gt;(分析请求头)-&gt; 回馈报文</li>
<li>请求文档下来-&gt;DOM-&gt;CSSDOM-&gt;静态资源下载-&gt;render(绘制文档)-&gt;js 解析</li>
<li>用户看到页面</li>
</ol>
<hr>
<h3 id="Q-Vue-的组件的通讯手段有哪些"><a href="#Q-Vue-的组件的通讯手段有哪些" class="headerlink" title="Q: Vue 的组件的通讯手段有哪些.."></a>Q: Vue 的组件的通讯手段有哪些..</h3><ul>
<li>父-> 子: <code>props</code></li>
<li>子-> 父: <code>on</code>+<code>emit</code></li>
<li>父&lt;&gt;子: <code>on.sync</code>(语法糖)来的</li>
<li>兄弟 : <code>event bus</code> | <code>vuex</code></li>
</ul>
<h4 id="Q-Vuex你怎么理解"><a href="#Q-Vuex你怎么理解" class="headerlink" title="Q: Vuex你怎么理解?"></a>Q: <code>Vuex</code>你怎么理解?</h4><p><code>vuex</code>是一个状态管理容器(你也可以理解为全局变量),数据的流向是是单向数据流,</p>
<p>且数据并不具有持久化的特性(默认情况下刷新就重置所有状态);</p>
<p>里面的一些数据乃至方法,可以大致理解为 vue 的一些特性,比如</p>
<p>Vuex</p>
<p>Vue</p>
<p>state</p>
<p>data</p>
<p>getter</p>
<p>computed</p>
<p>mutation/actions</p>
<p>methods</p>
<p>至于单向数据流(全局单例模式)怎么理解</p>
<p><code>state</code>只能给<code>mutation(同步操作)</code> 改动, <code>action</code>只能反馈给<code>mutation</code>,可以进行异步操作(比如和后端交互拉取数据), <code>state</code>能触发 render,<code>action</code>能用<code>dispatch</code>分发..如图</p>
<p><img src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;701&quot; height=&quot;551&quot;&gt;&lt;/svg" alt=""></p>
<hr>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>还有一些题目记不起来了,就没辙了…还有一些题目是看你个人发挥的,没法写,比如</p>
<blockquote>
<ul>
<li>Q: 让你来为公司的一个项目做技术选型,你会怎么做,为什么?</li>
<li>Q: <code>React</code>,<code>Angular</code>,<code>Vue</code>的比较?</li>
<li>Q: 说说你对 <code>VNode</code>的理解,<code>diff</code>的过程;</li>
<li>Q: <code>Vue</code>的双向绑定如何实现,用了什么模式(订阅模式),大体如何实现的..</li>
<li>Q: <code>cmd</code>/<code>amd</code>/<code>commonjs</code>的差异</li>
<li>Q: 小程序以及<code>React Native</code>的差异..等等</li>
</ul>
</blockquote>
<p>面试的过程中磕磕碰碰才能发现自身的很多不足和需要去努力的方向.</p>
<p>有不对之处请留言,会及时跟进修正,谢谢各位大佬</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://motainzhang.com/2018/07/19/vue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MotainZhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/27069108?s=460&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MotainZhang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/19/vue/" itemprop="url">当大多数人对Vue理解到炉火纯青的时候，是不是该思考一下怎么让vue页面骚气起来</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-19T15:22:38+00:00">
                2018-07-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/07/19/vue/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/07/19/vue/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="当大多数人对Vue理解到炉火纯青的时候，是不是该思考一下怎么让vue页面骚气起来"><a href="#当大多数人对Vue理解到炉火纯青的时候，是不是该思考一下怎么让vue页面骚气起来" class="headerlink" title="当大多数人对Vue理解到炉火纯青的时候，是不是该思考一下怎么让vue页面骚气起来"></a>当大多数人对Vue理解到炉火纯青的时候，是不是该思考一下怎么让vue页面骚气起来</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p><a href="https://link.juejin.im?target=https%3A%2F%2Fhongqingcao.github.io%2Fvue-portal-webUI%2F%23%2F" target="_blank" rel="noopener"><img src="https://user-gold-cdn.xitu.io/2018/8/16/1654053a58ad4ddb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></a>  </p>
<h2 id="小菜0、页面布局之五彩斑斓的类似标签栏"><a href="#小菜0、页面布局之五彩斑斓的类似标签栏" class="headerlink" title="小菜0、页面布局之五彩斑斓的类似标签栏"></a>小菜0、页面布局之五彩斑斓的类似标签栏</h2><p>先来个效果热热身</p>
<p><strong>上菜：</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/14/1653752a1e7ed890?imageslim" alt="">  </p>
<p><strong>场景需求：</strong>最近设计湿丢来这样的页面设计，要求响应式。正常老铁们看到类似标签栏的设计，作为前端要切出来估计头皮一发麻，基本上实现的话要么简单粗暴上背景图，要么几个div，作为对代码有的洁癖的我就直接上<strong>v-for表单渲染</strong>，把中间这块封装了一个公用的容器组件wapper，于是乎下面代码来了（完整代码，见本文后github链接）</p>
<pre><code>&lt;template&gt;
   &lt;div class=&quot;com-wapper&quot;&gt;
    &lt;div class=&quot;wapper&quot;&gt;
        &lt;div class=&quot;content-header&quot;&gt;
            &lt;div class=&quot;list&quot; v-for=&quot;(item,index) in colorList&quot; :style=&quot;{ background: item }&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;content&quot;&gt;
           &lt;slot&gt;&lt;/slot&gt;
        &lt;/div&gt;
       &lt;/div&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: &apos;wapper&apos;,
  data(){
      return{
          colorList: [&apos;#ea4035&apos;,&apos;#fbac46&apos;,&apos;#2eb472&apos;,&apos;#f7ec31&apos;,&apos;#1b72b4&apos;,&apos;#90268b&apos;]
      }
  }
}
&lt;/script&gt;复制代码
</code></pre><p><strong>原理：</strong>v-for去遍历数组，把颜色加在背景上，样式部分就不贴代码了，原理就是css3的计算属性calc分成6等分，然后各种阴影、圆角之类的一上效果杠杠的。</p>
<p>[题外话：至于性能方面没有做过多的思考，<strong>v-for表单渲染与其他实现方式的性能对比，</strong>这里也不做过多讲，这样看起来代码是优雅的]</p>
<h2 id="小菜1、爱心点赞，七夕特别贡献"><a href="#小菜1、爱心点赞，七夕特别贡献" class="headerlink" title="小菜1、爱心点赞，七夕特别贡献"></a>小菜1、爱心点赞，七夕特别贡献</h2><p>点赞场景，七夕了给相爱的ta一个赞吧</p>
<p><strong>上菜：</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/15/1653ca6eeab674da?imageslim" alt="">  </p>
<p><strong>场景需求：</strong>七夕马上就要到了，开始估计又要虐狗了，根据喜欢程度可以进行多次点击，从因为人群中偶然的一个回眸，平常到like,到love,再到love+,在到平常（点击通过爱心颜色和文字提示表示亲密度），项目中也常常出现，比如评论点赞，图书推荐点赞等场景，这里我把爱心抽离出一个heart组件，上核心代码：</p>
<pre><code>&lt;template&gt;
    &lt;a href=&quot;javascript:void(0)&quot;
       @click=&quot;handleHeart()&quot; 
       :class=&quot;{ 
        &apos;like&apos; : heart.level === 1, 
        &apos;love&apos; : heart.level === 2, 
        &apos;stalker&apos; : heart.level === 3 
       }&quot; 
       class=&quot;heart&quot;&gt;
        &lt;i&gt;♥&lt;/i&gt;
  &lt;/a&gt;
&lt;/template&gt;
复制代码

 methods: {
        handleHeart: function() {
            var heart = this.heart;
            var level = heart.level;
            switch (level) {
                case 0:
                    heart.level = 1;
                    break;
                case 1:
                    heart.level = 2;
                    break;
                case 2:
                    heart.level = 3;
                    break;
                case 3:
                    heart.level = 0;
                    break;
            }

           // this.updateDB();   //写入数据库操作
        },
        updateDB() {
        }
    },
    created() {
        if (!this.existing) {
            this.heart.level = 0;
        } else {
            this.heart.level = this.existing;
        }

    }
复制代码
</code></pre><p><strong>原理：</strong>点赞功能究竟是怎么实现的呢，其实我在前一篇文章<a href="https://link.juejin.im?target=https%3A%2F%2Fjuejin.im%2Fpost%2F5b6d0c5cf265da0f504a837f" target="_blank" rel="noopener">《从青铜到王者10个css3伪类使用技巧和运用，了解一哈》</a>已经提到了，其实就是用伪类实现鼠标经过提示，点击修改循环heart.level，切换class来修改提示（伪类透明度），和爱心颜色（完整代码，见本文后github链接）</p>
<p>[题外话：以上数据都是mock模拟，其实请求的是github里面的数据，github提供的api可以看到很多数据，感兴趣的同学可以拿取githubapi里自己的数据做一个关于自己的’大数据分析页面’，很赞哦]  </p>
<h2 id="小菜2、让新闻选项卡动起来"><a href="#小菜2、让新闻选项卡动起来" class="headerlink" title="小菜2、让新闻选项卡动起来"></a>小菜2、让新闻选项卡动起来</h2><p>新闻选项卡，门户网站出现概率贼高，告别枯燥无味翻动新闻选项卡，鼠标经过动起来</p>
<p><strong>上菜：</strong><img src="https://user-gold-cdn.xitu.io/2018/8/15/1653c6ac9575e2bf?imageslim" alt=""></p>
<p><strong>场景需求：</strong>选项卡标题鼠标经过，对应切换新闻内容列表。jq深度患者，通常看到类似滚动推动效果的效果，肯定在想操作DOM啊，so easy。还是那句话，代码强迫症，es6和vue相结合，让你尽可能告别DOM操作，下面贴上代码（完整代码，本文后github链接）</p>
<pre><code> &lt;div class=&quot;news-wrapper&quot; v-cloak&gt;
      &lt;ul class=&quot;news-list&quot;&gt;
      &lt;li v-for=&quot;(item,index) in list&quot; :class=&quot; {&apos;active&apos;:index===activeTab}&quot; @mouseenter=&quot;tebHover(index)&quot;&gt;&lt;a href=&quot;javascript://&quot;&gt;{{item.newstitle}}&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
     &lt;div class=&quot;news-box&quot;&gt;
        &lt;div class=&quot;news-listbox&quot; :style=&quot;{&apos;margin-left&apos;: marginleft+&apos;%&apos;}&quot;&gt;
          &lt;ul v-for=&quot;(item,index) in list&quot;&gt;
                 &lt;li class=&quot;clearFix&quot; v-for=&quot;(news, index) in item.datalist&quot; v-if=&quot;index &lt; 6&quot;&gt;
                     &lt;a&gt;
                         &lt;div class=&quot;news-date&quot;&gt;
                              &lt;div class=&quot;date-day&quot;&gt;{{news.date.split("-")[2]}}&lt;/div&gt;
                              &lt;div class=&quot;date-year&quot;&gt;{{news.date.split("-")[0]}}-{{news.date.split("-")[1]}}&lt;/div&gt;
                          &lt;/div&gt;
                          &lt;div class=&quot;main-news&quot;&gt;
                               &lt;div class=&quot;newstxt-title&quot;&gt;{{news.title}}&lt;/div&gt;
                                &lt;div class=&quot;news-text&quot;&gt;
                                      {{news.content}}
                                &lt;/div&gt;
                            &lt;/div&gt;
                            &lt;div class=&quot;time&quot;&gt;{{news.date}}&lt;/div&gt;
                        &lt;/a&gt;
                     &lt;/li&gt;
                    &lt;li class=&quot;more&quot;  v-if=&quot;item.datalist.length &gt;= 6&quot;&gt;&lt;a&gt;更多&gt;&gt;&lt;/a&gt;&lt;/li&gt;
               &lt;/ul&gt;
         &lt;/div&gt;
     &lt;/div&gt;
&lt;/div&gt;复制代码

  tebHover(index){
        this.activeTab = index;
        //计算margin-left的百分比
        this.marginleft = -1*(this.activeTab)*100
   }复制代码
</code></pre><p><strong>原理：</strong>让新闻内容区news-listbox的宽度300%（因为有三个选项），超出部分隐藏，这边标题选项只需要鼠标经过的时候带上index，计算margin-left多少，配合css3动画，寥寥几行ES6就实现了以上效果！</p>
<p>[题外话：以上数据都是mock模拟，里面其实很多值得大家可以看的亮点，比如怎么样让新闻第一条数据是和其他li有区别，时间截取、li超出部分显示更多按钮，等等都可下载源码看看]</p>
<h2 id="小菜3、让新闻卡片图片点击放大"><a href="#小菜3、让新闻卡片图片点击放大" class="headerlink" title="小菜3、让新闻卡片图片点击放大"></a>小菜3、让新闻卡片图片点击放大</h2><p>新闻卡片，点击图片平滑过渡放大，关闭缩小</p>
<p><strong>上菜：</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/8/15/1653c8c731ecb343?imageslim" alt="">  </p>
<p><strong>场景需求</strong>：其实就是一个查看点击查看大图插件</p>
<pre><code>&lt;template&gt;
    &lt;div class=&quot;image-dialog&quot;&gt;
        &lt;button class=&quot;image-dialog-trigger&quot; type=&quot;button&quot; @click=&quot;showDialog&quot;&gt;&lt;img class=&quot;image-dialog-thumb&quot; ref=&quot;thumb&quot; :src=&quot;thumb&quot; /&gt;
        &lt;/button&gt;
        &lt;transition name=&quot;dialog&quot; @enter=&quot;enter&quot; @leave=&quot;leave&quot;&gt;
            &lt;div class=&quot;image-dialog-background&quot; v-show=&quot;appearedDialog&quot; ref=&quot;dialog&quot;&gt;
                &lt;button class=&quot;image-dialog-close&quot; type=&quot;button&quot; @click=&quot;hideDialog&quot; aria-label=&quot;Close&quot;&gt;&lt;/button&gt;
                &lt;img class=&quot;image-dialog-animate&quot; ref=&quot;animate&quot; :class=&quot;{ loading: !loaded }&quot; :src=&quot;loaded ? full : thumb&quot; /&gt;
                &lt;img class=&quot;image-dialog-full&quot; ref=&quot;full&quot; :src=&quot;appearedDialog &amp;amp;&amp;amp; full&quot; :width=&quot;fullWidth&quot; :height=&quot;fullHeight&quot;
                @load=&quot;onLoadFull&quot; /&gt;
            &lt;/div&gt;
        &lt;/transition&gt;
    &lt;/div&gt;
&lt;/template&gt;
复制代码
</code></pre><p><strong>原理：</strong>通过transform:属性scale实现图片缩放，其中图片是两张图小大图切换，目前只是实现了功能，有待优化，所以不贴代码了（完整代码，本文后github链接）  </p>
<h2 id="小菜4、轮播图"><a href="#小菜4、轮播图" class="headerlink" title="小菜4、轮播图"></a>小菜4、轮播图</h2><p>轮播图，现在基于vue的开源的很多优秀的轮播图插件,比如vue-awesome-swiper，这个功能就不多讲， 这边的话我自己写的：1、支持浏览器任意放缩，兼容移动端，2、支持自动切换，鼠标经过停止切换，分页/任意页点击切换，左右切换，3、支持文字介绍（超过一行自动省略）</p>
<p><strong>上菜：</strong></p>
<p><img src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;498&quot; height=&quot;274&quot;&gt;&lt;/svg" alt="">  </p>
<p>值得一提的是：如果加载轮播图组件（其他组件有这种报错可能）在加载的过程中出现“Error in render: “TypeError: Cannot read property ‘url’ of undefined”</p>
<p><img src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1233&quot; height=&quot;533&quot;&gt;&lt;/svg" alt="">  </p>
<p>这是由于axios请求和组件渲染顺序的问题引起的，这时候，你只需要在axios请求到数据后，再去加载组件，这里我推荐用v-if，判断当数据的长度大于0，表示请求出来了数据，再去加载轮播组件，如此就不会报错了。</p>
<pre><code>&lt;div class=&quot;slider-wapper&quot;&gt;
&lt;slider :slides=&quot;slides&quot; :inv=&quot;invTime&quot; v-if=&quot;slides.length &gt; 0&quot;&gt;&lt;/slider&gt;
&lt;/div&gt;
复制代码
</code></pre><p>对应轮播组件，感兴趣的同学可以看我之前发的文章<a href="https://link.juejin.im?target=https%3A%2F%2Fjuejin.im%2Fpost%2F5afb87ec51882567105feae5" target="_blank" rel="noopener">《从开发到发布一款基于Vue2x的响应式自适应轮播组件插件VueSliderShow》</a></p>
<h2 id="小菜5、即时检索"><a href="#小菜5、即时检索" class="headerlink" title="小菜5、即时检索"></a>小菜5、即时检索</h2><p><strong>上菜：</strong>  </p>
<p><img src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;799&quot; height=&quot;474&quot;&gt;&lt;/svg" alt="">  </p>
<p><strong>场景需求</strong>：通过输入即时检索列表里面的内容，列表的检索过滤，直接上代码（完整代码，本文后github链接）  </p>
<pre><code> &lt;div class=&quot;search-box&quot;&gt;
    &lt;div class=&quot;search-wrapper&quot;&gt;
          &lt;input type=&quot;text&quot; v-model=&quot;keyword&quot; placeholder=&quot;Search title...&quot; /&gt;
           &lt;label&gt;Search Title&lt;/label&gt;
     &lt;/div&gt;
     &lt;div class=&quot;wrapper&quot;&gt;
         &lt;div class=&quot;card&quot; v-for=&quot;post in filteredList&quot;&gt;
            &lt;a v-bind:href=&quot;post.link&quot; target=&quot;_blank&quot;&gt;
                 &lt;img v-bind:src=&quot;post.img&quot; /&gt;
                  &lt;small&gt;Posted by: {{ post.author }}&lt;/small&gt; {{ post.title }}
            &lt;/a&gt;
         &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
复制代码

  methods:{
    toggleOnOff() {
            this.onOff = !this.onOff;
        }
  },
  computed: {
    filteredList() {
        return this.postList.filter((post) =&gt; {
            return post.title.toLowerCase().includes(this.keyword.toLowerCase());
        });
    }
  }
复制代码
</code></pre><p><strong>原理：</strong>通过computed计算input框的内容，然后再展示内容  </p>
<h3 id="最后：（未完待续）"><a href="#最后：（未完待续）" class="headerlink" title="最后：（未完待续）"></a>最后：（未完待续）</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://motainzhang.com/2018/07/19/charles/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MotainZhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/27069108?s=460&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MotainZhang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/19/charles/" itemprop="url">charles</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-19T15:14:47+00:00">
                2018-07-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/工具/" itemprop="url" rel="index">
                    <span itemprop="name">工具</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/07/19/charles/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/07/19/charles/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <article data-v-13f76525="" itemscope="itemscope" itemtype="http://schema.org/Article" class="article" data-v-3f216172=""><meta itemprop="url" content="https://juejin.im/post/5b4f005ae51d45191c7e534a"><meta itemprop="headline" content="Charles抓包工具二三谈"><meta itemprop="keywords" content="Node.js,Java,百度,Charles"><meta itemprop="datePublished" content="2018-07-18T09:03:51.151Z"><meta itemprop="image" content="https://user-gold-cdn.xitu.io/2018/7/18/164aca09d3137b4e?w=900&amp;h=700&amp;f=png&amp;s=273867"><div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="杭城小刘"><meta itemprop="url" content="https://juejin.im/user/57c108b8a633bd005d67e4a6"></div><div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"><div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://b-gold-cdn.xitu.io/icon/icon-white-180.png"><meta itemprop="width" content="180"><meta itemprop="height" content="180"></div></div><div data-v-13f76525="" class="author-info-block"><a href="/user/57c108b8a633bd005d67e4a6"><div data-v-b2db8566="" data-v-1b9df826="" data-v-13f76525="" data-src="https://user-gold-cdn.xitu.io/2018/6/13/163f9d3d25f8b421?imageView2/1/w/100/h/100/q/85/format/webp/interlace/1" class="lazy avatar avatar loaded" title="" style="background-image: url(&quot;https://user-gold-cdn.xitu.io/2018/6/13/163f9d3d25f8b421?imageView2/1/w/100/h/100/q/85/format/webp/interlace/1&quot;);"></div></a><div data-v-13f76525="" class="author-info-box"><a href="/user/57c108b8a633bd005d67e4a6">杭城小刘</a><div data-v-13f76525="" class="meta-box"><time data-v-13f76525="" datetime="2018-07-18T09:03:51.151Z" title="Wed Jul 18 2018 17:03:51 GMT+0800 (中国标准时间)" class="time">2018年07月18日</time><span data-v-13f76525="" class="views-count">阅读 1003</span><!----></div></div></div><div data-v-b2db8566="" data-v-009ea7bb="" data-v-13f76525="" data-src="https://user-gold-cdn.xitu.io/2018/7/18/164aca09d3137b4e?imageView2/1/w/1304/h/734/q/85/format/webp/interlace/1" class="lazy thumb article-hero loaded" style="background-image: url(&quot;https://user-gold-cdn.xitu.io/2018/7/18/164aca09d3137b4e?imageView2/1/w/1304/h/734/q/85/format/webp/interlace/1&quot;); background-size: cover;"></div><br><br># Charles抓包工具二三谈<br><div data-v-13f76525="" itemprop="articleBody" class="article-content"><br><br>### 一、 下载地址<br><br>Charles的下载地址：<a href="https://link.juejin.im?target=https%3A%2F%2Fpan.baidu.com%2Fs%2F1fkeKeIz1Yvz2HRFjk3P-0g" target="_blank" rel="noopener">charles</a><br>因为Charles只有30天的试用期，所以在这里给一个破解版的包：<a href="https://link.juejin.im?target=https%3A%2F%2Fpan.baidu.com%2Fs%2F1QqSiEwMGIFrxwyKYg_6Kdw" target="_blank" rel="noopener"><br>破解包</a><br><br>### 二、破解方法<br><br><em>   像正常安装应用一样，点击安装，之后将应用包拖到Application目录中。
</em>   右击Charles.app，显示包内容，然后将第二个链接下载下来的破解包复制黏贴到此目录下替换。<br><br>### 三、使用教程<br><br><em>   Charles上的设置。<br><br>    在Charles的菜单栏上选择”Proxy” -&gt; “Proxy Settings”,填入代理端口8888，并且勾选”Enable transparent HTTP proxying”,就完成了Charles上的设置，如下图所示：<br><br>    <figure><img src="https://user-gold-cdn.xitu.io/2018/7/18/164ac9aa738ccd2a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="步骤1"><figcaption></figcaption></figure><br><figure><img src="https://user-gold-cdn.xitu.io/2018/7/18/164ac9a9bf3ea1ac?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="步骤2"><figcaption></figcaption></figure>

</em>   在电脑“系统偏好设置”中心打开网络查看本机ip地址，打开手机“设置”-&gt;“无线局域网”，进入选中的网络，HTTP代理选中“手动”。服务器处填写电脑ip地址，端口写8888。设置好后，我们打开iPhone上的任意需要网络通讯的程序，就可以看到Charles弹出请求的确认菜单，单击”Allow”按钮，即可完成设置。<br><figure><img src="https://user-gold-cdn.xitu.io/2018/7/18/164ac9a9b90f9dcc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="手机设置"><figcaption></figcaption></figure><br><br>### 四、使用 Charles mock 接口数据<br><br>发现有些时候我们需要对一个接口进行黑盒测试，我们可以通过 Charles 进行模拟，或者对某些 App 查看判断业务逻辑也可以用此方法。<br><br><em>   选中 Charles 的具体某个接口，右击选择 “Map Local”。<br><figure><img src="https://user-gold-cdn.xitu.io/2018/7/18/164ac9fb5d5c214f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""><figcaption></figcaption></figure>
</em>   在弹出的对话框中，点击红色圈出来的按钮，然后选择本地准备好的 JSON 文件<br><figure><img src="https://user-gold-cdn.xitu.io/2018/7/18/164ac9a9a68f71a8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""><figcaption></figcaption></figure><br>这2个步骤做完后就可以 mock 接口数据了，每次要做操作，只需要修改本地的 JSON 文件即可<br>当然，这是对于简单的调试，最好还是会写一些接口开发，比如 Node.js 、PHP、Java、Python等等<br><br>### 五、抓取 HTTPS 数据<br><br><em>   在电脑端 Charles 上菜单栏 Help -&gt; SSl Proxying -&gt; Install Charles Root Certificate<br><figure><img src="https://user-gold-cdn.xitu.io/2018/7/18/164ac9aa40822368?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""><figcaption></figcaption></figure>
</em>   在 keychain 处将新安装的证书设置为永久信任<br><figure><img src="https://user-gold-cdn.xitu.io/2018/7/18/164ac9aab5332151?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""><figcaption></figcaption></figure><br><em>   在 Charles 菜单栏 Proxy -&gt; SSL Proxying Setting -&gt; 点击 Add 按钮 -&gt; 在弹出的对对话框设置需要监听的 HTTPS 域（</em>:代表通配符）<br><figure><img src="https://user-gold-cdn.xitu.io/2018/7/18/164ac9aaad2c0ff8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""><figcaption></figcaption></figure><br><em>   在手机上链接好电脑对应的 ip 和端口
</em>   在手机浏览器访问 Chls.pro/ssl 安装证书，并信任<br><figure><img src="https://user-gold-cdn.xitu.io/2018/7/18/164ac9a99ea05b2e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""><figcaption></figcaption></figure><br><em>   iPhone 打开设置 -&gt; 通用 -&gt; 关于本机 -&gt; 证书信任设置 -&gt; 开启开关<br><figure><img src="https://user-gold-cdn.xitu.io/2018/7/18/164ac9a9ca26c907?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""><figcaption></figcaption></figure><br>尽情玩乐吧<br><figure><img src="https://user-gold-cdn.xitu.io/2018/7/18/164ac9a9a966fafe?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="抓取京东HTTPS数据"><figcaption></figcaption></figure>

</em> <em> </em><br><br>看到下方评论说“手机如果有vpn的话，需要现将vpn关闭才能成功”。如果各位在手机开着 VPN 的情况下无法抓包，那么尝试关闭 VPN。（具体未尝试）<br><br></div></article>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://motainzhang.com/2018/06/14/Spring-MVC的Controller的几种常用返回类型（含请求转发、重定向）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MotainZhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/27069108?s=460&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MotainZhang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/14/Spring-MVC的Controller的几种常用返回类型（含请求转发、重定向）/" itemprop="url">Spring MVC的Controller的几种常用返回类型（含请求转发、重定向）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-14T23:35:50+00:00">
                2018-06-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java-Web/" itemprop="url" rel="index">
                    <span itemprop="name">Java Web</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java-Web/Spring-MVC/" itemprop="url" rel="index">
                    <span itemprop="name">Spring MVC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/14/Spring-MVC的Controller的几种常用返回类型（含请求转发、重定向）/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/06/14/Spring-MVC的Controller的几种常用返回类型（含请求转发、重定向）/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="返回ModelAndView"><a href="#返回ModelAndView" class="headerlink" title="返回ModelAndView"></a>返回ModelAndView</h2><p>返回ModelAndView时最常见的一种返回结果。需要在方法结束的时候定义一个ModelAndView对象，并对Model和View分别进行设置。</p>
<h2 id="返回String"><a href="#返回String" class="headerlink" title="返回String"></a>返回String</h2><h3 id="字符串代表逻辑视图名"><a href="#字符串代表逻辑视图名" class="headerlink" title="字符串代表逻辑视图名"></a>字符串代表逻辑视图名</h3><p>真实的访问路径=“前缀”+逻辑视图名+“后缀”</p>
<p>注意：如果返回的String代表逻辑视图名的话，那么Model的返回方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public String testController(Model model)&#123;</span><br><span class="line">    model.addAttribute(attrName,attrValue);//相当于ModelAndView的addObject方法</span><br><span class="line">    return &quot;逻辑视图名&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="代表redirect重定向"><a href="#代表redirect重定向" class="headerlink" title="代表redirect重定向"></a>代表redirect重定向</h3><p>redirect的特点和servlet一样，使用redirect进行重定向那么地址栏中的URL会发生变化，同时不会携带上一次的request</p>
<p>案例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public String testController(Model model)&#123;</span><br><span class="line">    return &quot;redirect:path&quot;;//path代表重定向的地址</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="代表forward转发"><a href="#代表forward转发" class="headerlink" title="代表forward转发"></a>代表forward转发</h3><p>通过forward进行转发，地址栏中的URL不会发生改变，同时会将上一次的request携带到写一次请求中去</p>
<p>案例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public String testController(Model model)&#123;</span><br><span class="line">    return &quot;forward:path&quot;;//path代表转发的地址</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="返回void"><a href="#返回void" class="headerlink" title="返回void"></a>返回void</h2><p>返回这种结果的时候可以在Controller方法的形参中定义HTTPServletRequest和HTTPServletResponse对象进行请求的接收和响应</p>
<h3 id="使用request转发页面"><a href="#使用request转发页面" class="headerlink" title="使用request转发页面"></a>使用<code>request</code>转发页面</h3><p>  <code>request.getRequestDispatcher(&quot;转发路径&quot;).forward(request,response);</code></p>
<h3 id="使用response进行页面重定向"><a href="#使用response进行页面重定向" class="headerlink" title="使用response进行页面重定向"></a>使用<code>response</code>进行页面重定向</h3><p>  <code>response.sendRedirect(&quot;重定向路径&quot;);</code></p>
<h3 id="也可以使用response指定响应结果"><a href="#也可以使用response指定响应结果" class="headerlink" title="也可以使用response指定响应结果"></a>也可以使用<code>response</code>指定响应结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">response.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">response.setContentType(&quot;application/json;charset=utf-8&quot;);</span><br><span class="line">response.getWriter.write(&quot;json串&quot;);</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://motainzhang.com/2018/06/14/根据请求的具体扩展名、请求头不同，返回不同格式的相同内容/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MotainZhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/27069108?s=460&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MotainZhang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/14/根据请求的具体扩展名、请求头不同，返回不同格式的相同内容/" itemprop="url">根据请求的具体扩展名、请求头不同，返回不同格式的相同内容</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-14T22:48:32+00:00">
                2018-06-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java-Web/" itemprop="url" rel="index">
                    <span itemprop="name">Java Web</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java-Web/Spring-MVC框架/" itemprop="url" rel="index">
                    <span itemprop="name">Spring MVC框架</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java-Web/Spring-MVC框架/视图/" itemprop="url" rel="index">
                    <span itemprop="name">视图</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/14/根据请求的具体扩展名、请求头不同，返回不同格式的相同内容/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/06/14/根据请求的具体扩展名、请求头不同，返回不同格式的相同内容/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="内容协商多视图"><a href="#内容协商多视图" class="headerlink" title="内容协商多视图"></a>内容协商多视图</h2><p><a href="https://blog.csdn.net/yu412346928/article/details/20637439" target="_blank" rel="noopener">SpringMVC配置多视图-内容协商原理</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=&quot;org.springframework.web.servlet.view.ContentNegotiatingViewResolver&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;contentNegotiationManager&quot; ref=&quot;contentNegotiationManager&quot;/&gt;</span><br><span class="line">   ...</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p><a href="https://junq.io/spring-mvc%E5%AE%9E%E7%8E%B0http%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86-content-negotiation.html" target="_blank" rel="noopener">Spring MVC三种方式实现HTTP内容协商(Content Negotiation)</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://motainzhang.com/2018/06/14/服务端返回JSON数据，实现客户端的无关性/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MotainZhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/27069108?s=460&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MotainZhang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/14/服务端返回JSON数据，实现客户端的无关性/" itemprop="url">服务端返回JSON数据，实现客户端的无关性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-14T18:56:48+00:00">
                2018-06-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java-Web/" itemprop="url" rel="index">
                    <span itemprop="name">Java Web</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java-Web/Spring-MVC框架，视图/" itemprop="url" rel="index">
                    <span itemprop="name">Spring MVC框架，视图</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/14/服务端返回JSON数据，实现客户端的无关性/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/06/14/服务端返回JSON数据，实现客户端的无关性/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://motainzhang.com/2018/06/14/批量执行与SqlSessionTemplate/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="MotainZhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars1.githubusercontent.com/u/27069108?s=460&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MotainZhang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/14/批量执行与SqlSessionTemplate/" itemprop="url">批量执行与SqlSessionTemplate</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-14T12:21:46+00:00">
                2018-06-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java-Web/" itemprop="url" rel="index">
                    <span itemprop="name">Java Web</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java-Web/测试/" itemprop="url" rel="index">
                    <span itemprop="name">测试</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/14/批量执行与SqlSessionTemplate/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/06/14/批量执行与SqlSessionTemplate/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://avatars1.githubusercontent.com/u/27069108?s=460&v=4"
                alt="MotainZhang" />
            
              <p class="site-author-name" itemprop="name">MotainZhang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">52</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">62</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/MotainZhang" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="sw20026@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://plus.google.com/jszhang" target="_blank" title="Google">
                      
                        <i class="fa fa-fw fa-google"></i>Google</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.v2ex.com/" title="V2EX" target="_blank">V2EX</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://e.xitu.io/" title="JueJin" target="_blank">JueJin</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.alloyteam.com/nav/" title="Web前端导航" target="_blank">Web前端导航</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.chuangzaoshi.com/code" title="Web创造狮导航" target="_blank">Web创造狮导航</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">MotainZhang</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'VITR9FskbbXnDcpwBdyTT15i-gzGzoHsz',
        appKey: 'acgrONeHircp8V2jHpsppXdm',
        placeholder: '说点什么吧',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  
  
  <link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css">

  
  
  <script src="/lib/needsharebutton/needsharebutton.js"></script>

  <script>
    
      pbOptions = {};
      
          pbOptions.iconStyle = "box";
      
          pbOptions.boxForm = "horizontal";
      
          pbOptions.position = "bottomCenter";
      
          pbOptions.networks = "Weibo,Wechat,Douban,QQZone,Twitter,Facebook";
      
      new needShareButton('#needsharebutton-postbottom', pbOptions);
    
    
  </script>

  

  

  

  

<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/haruto.model.json"},"display":{"position":"right","width":100,"height":200},"mobile":{"show":true},"react":{"opacityDefault":1,"opacityOnHover":0.2},"log":false});</script></body>
</html>
