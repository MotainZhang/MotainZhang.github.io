<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MotainZhang</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://motainzhang.com/"/>
  <updated>2019-10-18T03:34:00.262Z</updated>
  <id>https://motainzhang.com/</id>
  
  <author>
    <name>MotainZhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>pom.xml配置详解</title>
    <link href="https://motainzhang.com/2019/10/18/pom.xml%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"/>
    <id>https://motainzhang.com/2019/10/18/pom.xml配置详解/</id>
    <published>2019-10-18T03:34:00.262Z</published>
    <updated>2019-10-18T03:34:00.262Z</updated>
    
    <content type="html"><![CDATA[<h2 id="pom-xml的作用"><a href="#pom-xml的作用" class="headerlink" title="pom.xml的作用"></a>pom.xml的作用</h2><p>描述项目。<br><img src="https://github.com/Hunter1023/blogSource/raw/master/source/image/pom.xml%E7%9A%84%E9%83%A8%E5%88%86%E9%85%8D%E7%BD%AE.png" alt="pom.xml的简单介绍"></p><h2 id="groupId、artifactId和version构成项目的唯一标识（坐标），不能重复。"><a href="#groupId、artifactId和version构成项目的唯一标识（坐标），不能重复。" class="headerlink" title="groupId、artifactId和version构成项目的唯一标识（坐标），不能重复。"></a><code>groupId</code>、<code>artifactId</code>和<code>version</code>构成项目的唯一标识（坐标），不能重复。</h2><h2 id="lt-properties-gt-属性元素"><a href="#lt-properties-gt-属性元素" class="headerlink" title="&lt;properties&gt;属性元素"></a><code>&lt;properties&gt;</code>属性元素</h2><p><strong>自定义一些常量</strong>，比如版本号，字符编码，可以让之后一些依赖的版本直接从这里引用，便于后期修改及管理。</p><p><img src="https://github.com/Hunter1023/blogSource/raw/master/source/image/pom.xml%E4%B8%ADproperties%E7%9A%84%E9%85%8D%E7%BD%AE.png" alt=""></p><h2 id="lt-dependencies-gt-放置依赖，从远程仓库下载依赖的Jar包"><a href="#lt-dependencies-gt-放置依赖，从远程仓库下载依赖的Jar包" class="headerlink" title="&lt;dependencies&gt;放置依赖，从远程仓库下载依赖的Jar包"></a><code>&lt;dependencies&gt;</code>放置依赖，从远程仓库下载依赖的Jar包</h2><ul><li>依赖需要填写坐标：<code>groupId</code>、<code>artifactId</code>和<code>version</code></li><li>scope:依赖作用的范围：<ul><li>compile(<strong>默认</strong>) 编译时需要，打包时也将该依赖打包</li><li>provided 编译时需要，打包时不用</li></ul></li></ul><p>　　<strong>父pom中可以通过<code>&lt;dependencyManagement&gt;</code>放置<code>&lt;dependencies&gt;</code>,用于继承</strong>。</p><h3 id="如果访问Maven官方的中心仓库很慢（下载依赖耗时，浪费时间），可以更改为使用阿里云提供的镜像仓库："><a href="#如果访问Maven官方的中心仓库很慢（下载依赖耗时，浪费时间），可以更改为使用阿里云提供的镜像仓库：" class="headerlink" title="如果访问Maven官方的中心仓库很慢（下载依赖耗时，浪费时间），可以更改为使用阿里云提供的镜像仓库："></a>如果访问Maven官方的中心仓库很慢（<strong>下载依赖耗时，浪费时间</strong>），可以更改为使用阿里云提供的镜像仓库：</h3><ul><li>方式一： 修改<code>%M2_HOME%/conf/settings.xml</code>文件<br>　　在<code>&lt;mirrors&gt;</code>元素中添加一个<code>&lt;mirror&gt;</code>配置如下:<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>centeral<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun mirror<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>　　在<code>&lt;profiles&gt;</code>中添加一个<code>&lt;profile&gt;</code>配置如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure></p><ul><li>方式二： 修改本地仓库所在目录下的<code>setting.xml</code>文件内容如上。本地仓库一般位于<code>当前用户/.m2</code>目录下。</li></ul><h2 id="lt-build-gt-构建配置"><a href="#lt-build-gt-构建配置" class="headerlink" title="&lt;build&gt;构建配置"></a><code>&lt;build&gt;</code>构建配置</h2><ul><li><code>&lt;plugins&gt;</code>插件，比如compiler<br>  <strong>父pom中可以通过<code>&lt;pluginManagement&gt;</code>放置<code>&lt;plugins&gt;</code>,用于继承</strong>。</li></ul><h2 id="lt-parent-gt-多项目继承"><a href="#lt-parent-gt-多项目继承" class="headerlink" title="&lt;parent&gt;多项目继承"></a><code>&lt;parent&gt;</code>多项目继承</h2><p>参考：<a href="https://blog.csdn.net/ithomer/article/details/9332071" target="_blank" rel="noopener">Maven pom.xml配置详解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;pom-xml的作用&quot;&gt;&lt;a href=&quot;#pom-xml的作用&quot; class=&quot;headerlink&quot; title=&quot;pom.xml的作用&quot;&gt;&lt;/a&gt;pom.xml的作用&lt;/h2&gt;&lt;p&gt;描述项目。&lt;br&gt;&lt;img src=&quot;https://github.com/
      
    
    </summary>
    
      <category term="Java Web" scheme="https://motainzhang.com/categories/Java-Web/"/>
    
      <category term="Maven" scheme="https://motainzhang.com/categories/Java-Web/Maven/"/>
    
    
      <category term="Maven" scheme="https://motainzhang.com/tags/Maven/"/>
    
      <category term="依赖管理" scheme="https://motainzhang.com/tags/%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/"/>
    
      <category term="pom.xml" scheme="https://motainzhang.com/tags/pom-xml/"/>
    
  </entry>
  
  <entry>
    <title>vue权限路由总结</title>
    <link href="https://motainzhang.com/2019/10/18/vue%E6%9D%83%E9%99%90%E8%B7%AF%E7%94%B1%E6%80%BB%E7%BB%93/"/>
    <id>https://motainzhang.com/2019/10/18/vue权限路由总结/</id>
    <published>2019-10-18T03:34:00.262Z</published>
    <updated>2019-10-18T03:34:00.262Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="vue权限路由总结"><a href="#vue权限路由总结" class="headerlink" title="vue权限路由总结"></a>vue权限路由总结</h1><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>前端定义好路由，并且在路由上标记相应的权限信息</p><pre><code>const routerMap = [  {    path: &apos;/permission&apos;,    component: Layout,    redirect: &apos;/permission/index&apos;,    alwaysShow: true, // will always show the root menu    meta: {      title: &apos;permission&apos;,      icon: &apos;lock&apos;,      roles: [&apos;admin&apos;, &apos;editor&apos;] // you can set roles in root nav    },    children: [{      path: &apos;page&apos;,      component: () =&gt; import(&apos;@/views/permission/page&apos;),      name: &apos;pagePermission&apos;,      meta: {        title: &apos;pagePermission&apos;,        roles: [&apos;admin&apos;] // or you can only set roles in sub nav      }    }, {      path: &apos;directive&apos;,      component: () =&gt; import(&apos;@/views/permission/directive&apos;),      name: &apos;directivePermission&apos;,      meta: {        title: &apos;directivePermission&apos;        // if do not set roles, means: this page does not require permission      }    }]  }]复制代码</code></pre><p>全局路由守卫每次都判断用户是否已经登录，没有登录则跳到登录页。已经登录(已经取得后台返回的用户的权限信息(角色之类的))，则判断当前要跳转的路由，用户是否有权限访问(根据路由名称到全部路由里找到对应的路由，判断用户是否具备路由上标注的权限信息(比如上面的<code>roles: [&#39;admin&#39;, &#39;editor&#39;]</code>))。没有权限则跳到事先定义好的界面(403,404之类的)。</p><p>这种方式，菜单可以直接用路由生成(用户没有权限的菜单也会显示，点击跳转的时候才做权限判断)，也可以在用户登录后根据用户权限把路由过滤一遍生成菜单(菜单需要保存在vuex里)。</p><blockquote><p>目前<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fiview%2Fiview-admin%2Fblob%2Fdev%2Fsrc%2Frouter%2Findex.js" target="_blank" rel="noopener">iview-admin</a>还是用的这种方式</p></blockquote><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li><p>加载所有的路由，如果路由很多，而用户并不是所有的路由都有权限访问，对性能会有影响。</p></li><li><p>全局路由守卫里，每次路由跳转都要做权限判断。</p></li><li><p>菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译</p></li><li><p>菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识</p></li></ul><h2 id="登录页与主应用分离"><a href="#登录页与主应用分离" class="headerlink" title="登录页与主应用分离"></a>登录页与主应用分离</h2><p>针对前一种实现方式的缺点，可以将登录页与主应用放到不同的页面(不在同一个vue应用实例里)。</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>登录成功后，进行页面跳转(真正的页面跳转，不是路由跳转)，并将用户权限传递到主应用所在页面，主应用初始化之前，根据用户权限筛选路由，筛选后的路由作为vue的实例化参数，而不是像前一种方式所有的路由都传递进去，也不需要在全局路由守卫里做权限判断了。</p><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul><li>需要做页面跳转，不是纯粹的单页应用</li><li>菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译</li><li>菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识</li></ul><h2 id="使用addRoutes动态挂载路由"><a href="#使用addRoutes动态挂载路由" class="headerlink" title="使用addRoutes动态挂载路由"></a>使用<code>addRoutes</code>动态挂载路由</h2><p><code>addRoutes</code>允许在应用初始化之后，动态的挂载路由。有了这个新姿势，就不用像前一种方式那样要在应用初始化之要对路由进行筛选。</p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>应用初始化的时候先挂载不需要权限控制的路由，比如登录页，404等错误页。</p><p>有个问题，<code>addRoutes</code>应该何时调用，在哪里调用</p><p>登录后，获取用户的权限信息，然后筛选有权限访问的路由，再调用<code>addRoutes</code>添加路由。这个方法是可行的。但是不可能每次进入应用都需要登录，用户刷新浏览器又要登陆一次。</p><p>所以<code>addRoutes</code>还是要在全局路由守卫里进行调用</p><pre><code>import router from &apos;./router&apos;import store from &apos;./store&apos;import { Message } from &apos;element-ui&apos;import NProgress from &apos;nprogress&apos; // progress barimport &apos;nprogress/nprogress.css&apos;// progress bar styleimport { getToken } from &apos;@/utils/auth&apos; // getToken from cookieNProgress.configure({ showSpinner: false })// NProgress Configuration// permission judge functionfunction hasPermission(roles, permissionRoles) {  if (roles.indexOf(&apos;admin&apos;) &gt;= 0) return true // admin permission passed directly  if (!permissionRoles) return true  return roles.some(role =&gt; permissionRoles.indexOf(role) &gt;= 0)}const whiteList = [&apos;/login&apos;, &apos;/authredirect&apos;]// no redirect whitelistrouter.beforeEach((to, from, next) =&gt; {  NProgress.start() // start progress bar  if (getToken()) { // determine if there has token    /* has token*/    if (to.path === &apos;/login&apos;) {      next({ path: &apos;/&apos; })      NProgress.done() // if current page is dashboard will not trigger    afterEach hook, so manually handle it    } else {      if (store.getters.roles.length === 0) { // 判断当前用户是否已拉取完user_info信息        store.dispatch(&apos;GetUserInfo&apos;).then(res =&gt; { // 拉取user_info          const roles = res.data.roles // note: roles must be a array! such as: [&apos;editor&apos;,&apos;develop&apos;]          store.dispatch(&apos;GenerateRoutes&apos;, { roles }).then(() =&gt; { // 根据roles权限生成可访问的路由表            router.addRoutes(store.getters.addRouters) // 动态添加可访问路由表            next({ ...to, replace: true }) // hack方法 确保addRoutes已完成 ,set the replace: true so the navigation will not leave a history record          })        }).catch((err) =&gt; {          store.dispatch(&apos;FedLogOut&apos;).then(() =&gt; {            Message.error(err || &apos;Verification failed, please login again&apos;)            next({ path: &apos;/&apos; })          })        })      } else {        // 没有动态改变权限的需求可直接next() 删除下方权限判断 ↓        if (hasPermission(store.getters.roles, to.meta.roles)) {          next()//        } else {          next({ path: &apos;/401&apos;, replace: true, query: { noGoBack: true }})        }        // 可删 ↑      }    }  } else {    /* has no token*/    if (whiteList.indexOf(to.path) !== -1) { // 在免登录白名单，直接进入      next()    } else {      next(&apos;/login&apos;) // 否则全部重定向到登录页      NProgress.done() // if current page is login will not trigger afterEach hook, so manually handle it    }  }})router.afterEach(() =&gt; {  NProgress.done() // finish progress bar})复制代码</code></pre><p>关键的代码如下</p><pre><code>if (store.getters.roles.length === 0) { // 判断当前用户是否已拉取完user_info信息        store.dispatch(&apos;GetUserInfo&apos;).then(res =&gt; { // 拉取user_info          const roles = res.data.roles // note: roles must be a array! such as: [&apos;editor&apos;,&apos;develop&apos;]          store.dispatch(&apos;GenerateRoutes&apos;, { roles }).then(() =&gt; { // 根据roles权限生成可访问的路由表            router.addRoutes(store.getters.addRouters) // 动态添加可访问路由表            next({ ...to, replace: true }) // hack方法 确保addRoutes已完成 ,set the replace: true so the navigation will not leave a history record          })        }).catch((err) =&gt; {          store.dispatch(&apos;FedLogOut&apos;).then(() =&gt; {            Message.error(err || &apos;Verification failed, please login again&apos;)            next({ path: &apos;/&apos; })          })        })复制代码</code></pre><blockquote><p>上面的代码就是<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FPanJiaChen%2Fvue-element-admin" target="_blank" rel="noopener">vue-element-admin</a>的实现</p></blockquote><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ul><li>全局路由守卫里，每次路由跳转都要做判断</li><li>菜单信息写死在前端，要改个显示文字或权限信息，需要重新编译</li><li>菜单跟路由耦合在一起，定义路由的时候还有添加菜单显示标题，图标之类的信息，而且路由不一定作为菜单显示，还要多加字段进行标识</li></ul><h2 id="菜单与路由分离，菜单由后端返回"><a href="#菜单与路由分离，菜单由后端返回" class="headerlink" title="菜单与路由分离，菜单由后端返回"></a>菜单与路由分离，菜单由后端返回</h2><p>菜单的显示标题，图片等需要随时更改，要对菜单做管理功能。</p><p>后端直接根据用户权限返回可访问的菜单。</p><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><p>前端定义路由信息(标准的路由定义，不需要加其他标记字段)。</p><pre><code>{    name: &quot;login&quot;,    path: &quot;/login&quot;,    component: () =&gt; import(&quot;@/pages/Login.vue&quot;)}复制代码</code></pre><p>name字段都不为空，需要根据此字段与后端返回菜单做关联。</p><p>做菜单管理功能的时候，一定要有个字段与前端的路由的name字段对应上(也可以是其他字段，只要菜单能找到对应的路由或者路由能找到对应的菜单就行)，并且做唯一性校验。菜单上还需要定义权限字段，可以是一个或多个。其他信息，比如显示标题，图标，排序，锁定之类的，可以根据实际需求进行设计。</p><p><img src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1280&quot; height=&quot;655&quot;&gt;&lt;/svg" alt=""></p><p>还是在全局路由守卫里做判断</p><pre><code>function hasPermission(router, accessMenu) {  if (whiteList.indexOf(router.path) !== -1) {    return true;  }  let menu = Util.getMenuByName(router.name, accessMenu);  if (menu.name) {    return true;  }  return false;}Router.beforeEach(async (to, from, next) =&gt; {  if (getToken()) {    let userInfo = store.state.user.userInfo;    if (!userInfo.name) {      try {        await store.dispatch(&quot;GetUserInfo&quot;)        await store.dispatch(&apos;updateAccessMenu&apos;)        if (to.path === &apos;/login&apos;) {          next({ name: &apos;home_index&apos; })        } else {          //Util.toDefaultPage([...routers], to.name, router, next);          next({ ...to, replace: true })//菜单权限更新完成,重新进一次当前路由        }      }        catch (e) {        if (whiteList.indexOf(to.path) !== -1) { // 在免登录白名单，直接进入          next()        } else {          next(&apos;/login&apos;)        }      }    } else {      if (to.path === &apos;/login&apos;) {        next({ name: &apos;home_index&apos; })      } else {        if (hasPermission(to, store.getters.accessMenu)) {          Util.toDefaultPage(store.getters.accessMenu,to, routes, next);        } else {          next({ path: &apos;/403&apos;,replace:true })        }      }    }  } else {    if (whiteList.indexOf(to.path) !== -1) { // 在免登录白名单，直接进入      next()    } else {      next(&apos;/login&apos;)    }  }  let menu = Util.getMenuByName(to.name, store.getters.accessMenu);  Util.title(menu.title);});Router.afterEach((to) =&gt; {  window.scrollTo(0, 0);});复制代码</code></pre><p>上面代码是<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fwjkang%2Fvue-quasar-admin" target="_blank" rel="noopener">vue-quasar-admin</a>的实现。因为没有使用<code>addRoutes</code>,每次路由跳转的时候都要判断权限，这里的判断也很简单，因为菜单的name与路由的name是一一对应的,而后端返回的菜单就已经是经过权限过滤的，所以如果根据路由name找不到对应的菜单，就表示用户有没权限访问。</p><p>如果路由很多，可以在应用初始化的时候，只挂载不需要权限控制的路由。取得后端返回的菜单后，根据菜单与路由的对应关系，筛选出可访问的路由，通过<code>addRoutes</code>动态挂载。</p><h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3><ul><li>菜单需要与路由做一一对应，前端添加了新功能，需要通过菜单管理功能添加新的菜单，如果菜单配置的不对会导致应用不能正常使用</li><li>全局路由守卫里，每次路由跳转都要做判断</li></ul><h2 id="菜单与路由完全由后端返回"><a href="#菜单与路由完全由后端返回" class="headerlink" title="菜单与路由完全由后端返回"></a>菜单与路由完全由后端返回</h2><p>菜单由后端返回是可行的，但是路由由后端返回呢？看一下路由的定义</p><pre><code>{    name: &quot;login&quot;,    path: &quot;/login&quot;,    component: () =&gt; import(&quot;@/pages/Login.vue&quot;)}复制代码</code></pre><p>后端如果直接返回</p><pre><code>{    &quot;name&quot;: &quot;login&quot;,    &quot;path&quot;: &quot;/login&quot;,    &quot;component&quot;: &quot;() =&gt; import(&apos;@/pages/Login.vue&apos;)&quot;}复制代码</code></pre><p>这是什么鬼，明显不行。<code>() =&gt; import(&#39;@/pages/Login.vue&#39;)</code>这代码如果没出现在前端，webpack不会对<code>Login.vue</code>进行编译打包</p><h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><p>前端统一定义路由组件，比如</p><pre><code>const Home = () =&gt; import(&quot;../pages/Home.vue&quot;);const UserInfo = () =&gt; import(&quot;../pages/UserInfo.vue&quot;);export default {  home: Home,  userInfo: UserInfo};复制代码</code></pre><p>将路由组件定义为这种key-value的结构。</p><p>后端返回格式</p><pre><code>[      {        name: &quot;home&quot;,        path: &quot;/&quot;,        component: &quot;home&quot;      },      {        name: &quot;home&quot;,        path: &quot;/userinfo&quot;,        component: &quot;userInfo&quot;      }]复制代码</code></pre><p>在将后端返回路由通过<code>addRoutes</code>动态挂载之间，需要将数据处理一下，将component字段换为真正的组件。</p><p>至于菜单与路由是否还要分离，怎么对应，可以根据实际需求进行处理。</p><p>如果有嵌套路由，后端功能设计的时候，要注意添加相应的字段。前端拿到数据也要做相应的处理。</p><h3 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h3><ul><li>全局路由守卫里，每次路由跳转都要做判断</li><li>前后端的配合要求更高</li></ul><h2 id="不使用全局路由守卫"><a href="#不使用全局路由守卫" class="headerlink" title="不使用全局路由守卫"></a>不使用全局路由守卫</h2><p>前面几种方式，除了<code>登录页与主应用分离</code>,每次路由跳转，都在全局路由守卫里做了判断。</p><h3 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h3><p>应用初始化的时候只挂载不需要权限控制的路由</p><pre><code>const constRouterMap = [  {    name: &quot;login&quot;,    path: &quot;/login&quot;,    component: () =&gt; import(&quot;@/pages/Login.vue&quot;)  },  {    path: &quot;/404&quot;,    component: () =&gt; import(&quot;@/pages/Page404.vue&quot;)  },  {    path: &quot;/init&quot;,    component: () =&gt; import(&quot;@/pages/Init.vue&quot;)  },  {    path: &quot;*&quot;,    redirect: &quot;/404&quot;  }];export default constRouterMap;复制代码import Vue from &quot;vue&quot;;import Router from &quot;vue-router&quot;;import ConstantRouterMap from &quot;./routers&quot;;Vue.use(Router);export default new Router({  // mode: &apos;history&apos;, // require service support  scrollBehavior: () =&gt; ({ y: 0 }),  routes: ConstantRouterMap});复制代码</code></pre><p>登录成功后跳到<code>/</code>路由</p><pre><code>submitForm(formName) {      let _this=this;      this.$refs[formName].validate(valid =&gt; {        if (valid) {          _this.$store.dispatch(&quot;loginByUserName&quot;,{            name:_this.ruleForm2.name,            pass:_this.ruleForm2.pass          }).then(()=&gt;{            _this.$router.push({              path:&apos;/&apos;            })          })        } else {          return false;        }      });    }复制代码</code></pre><p>因为当前没有<code>/</code>路由，会跳到<code>/404</code></p><pre><code>&lt;template&gt;  &lt;h1&gt;404&lt;/h1&gt;&lt;/template&gt;&lt;script&gt;export default {  name:&apos;page404&apos;,  mounted(){    if(!this.$store.state.isLogin){      this.$router.replace({ path: &apos;/login&apos; });      return;    }    if(!this.$store.state.initedApp){       this.$router.replace({ path: &apos;/init&apos; });       return    }  }}&lt;/script&gt;复制代码</code></pre><p>404组件里判断已经登录，接着判断应用是否已经初始化(用户权限信息，可访问菜单，路由等是否已经从后端取得)。没有初始化则跳转到<code>/init</code>路由</p><pre><code>&lt;template&gt;  &lt;div&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { getAccessMenuList } from &quot;../mock/menus&quot;;import components from &quot;../router/routerComponents.js&quot;;export default {  async mounted() {    if (!this.$store.state.isLogin) {      this.$router.push({ path: &quot;/login&quot; });      return;    }    if (!this.$store.state.initedApp) {      const loading = this.$loading({        lock: true,        text: &quot;初始化中&quot;,        spinner: &quot;el-icon-loading&quot;,        background: &quot;rgba(0, 0, 0, 0.7)&quot;      });      let menus = await getAccessMenuList(); //模拟从后端获取      var routers = [...menus];      for (let router of routers) {        let component = components[router.component];        router.component = component;      }      this.$router.addRoutes(routers);      this.$store.dispatch(&quot;setAccessMenuList&quot;, menus).then(() =&gt; {        loading.close();        this.$router.replace({          path: &quot;/&quot;        });      });      return;    } else {      this.$router.replace({        path: &quot;/&quot;      });    }  }};&lt;/script&gt;复制代码</code></pre><p>init组件里判断应用是否已经初始化(避免初始化后，直接从地址栏输入地址再次进入当前组件)。</p><p>如果已经初始化，跳转<code>/</code>路由(如果后端返回的路由里没有定义次路由，则会跳转404)。</p><p>没有初始化，则调用远程接口获取菜单和路由等，然后处理后端返回的路由，将component赋值为真正 的组件，接着调用<code>addRoutes</code>挂载新路由，最后跳转<code>/</code>路由即可。菜单的处理也是在此处，看实际 需求。</p><blockquote><p><a href="https://link.juejin.im?target=https%3A%2F%2Fcodesandbox.io%2Fs%2Fr02zvvlpno" target="_blank" rel="noopener">实现例子</a></p></blockquote><h3 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h3><ul><li>在404页面做了判断，感觉比较怪异</li><li>多引入了一个init页面组件</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>比较推荐后面两种实现方式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h1 id=&quot;vue权限路由总结&quot;&gt;&lt;a href=&quot;#vue权限路由总结&quot; class=&quot;headerlink&quot; title=&quot;vue权限路由总结&quot;&gt;&lt;/a&gt;vue权限路由总结&lt;/h1&gt;&lt;h3 id=&quot;实现&quot;&gt;&lt;a href=&quot;#实现&quot; class=&quot;headerl
      
    
    </summary>
    
      <category term="前端" scheme="https://motainzhang.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>洞察 video 超能力系列——玩转 mp4</title>
    <link href="https://motainzhang.com/2019/10/18/%E8%A5%BF%E7%93%9C%E6%92%AD%E6%94%BE%E5%99%A8/"/>
    <id>https://motainzhang.com/2019/10/18/西瓜播放器/</id>
    <published>2019-10-18T03:34:00.262Z</published>
    <updated>2019-10-18T03:34:00.262Z</updated>
    
    <content type="html"><![CDATA[<h1 id="洞察-video-超能力系列——玩转-mp4"><a href="#洞察-video-超能力系列——玩转-mp4" class="headerlink" title="洞察 video 超能力系列——玩转 mp4"></a>洞察 video 超能力系列——玩转 mp4</h1><p><em>用技术提升美好事物发生的概率</em></p><p><em>Technologically, for greater probability to be happy.</em></p><p><img src="https://user-gold-cdn.xitu.io/2018/7/6/1646f98cbbb5a15b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>只要在 HTML5 中使用过视频播放的同学对 video 标签一定不会陌生，不过很多同学只使用了 video 的基础功能，实际上 video 拥有强大潜能的，只要姿势正确就能让其拥有超能力。不妨从下面几个场景来逐渐了解下video 未曾被发掘的神秘空间：</p><ul><li><p>清晰度无缝切换</p></li><li><p>节省视频流量</p></li></ul><h2 id="清晰度无缝切换"><a href="#清晰度无缝切换" class="headerlink" title="清晰度无缝切换"></a>清晰度无缝切换</h2><p>点播领域里 mp4 是最普遍、兼容性最好的视频容器，不过 mp4 也有它的局限性，比如常见的清晰度切换，我们是无法像youtube那样做到无缝切换的。我们可以看下普通的mp4播放的网络请求和youtube视频播放的网络请求的区别。</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/6/1646f98cbbcec4ef?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><p>图1.1 普通mp4的下载请求过程</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/6/1646f98cd48a0884?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="">  </p><p>图1.2 Youtube视频下载请求过程  </p><p>这两张图不难看出，在默认情况下 mp4 使用一次 http 请求所有的视频数据，Youtube 则分次请求。当然这个描述很不专业，但确实形象。造成这种差异的是 video 不支持流式的视频数据，Youtube 采用的是流式的视频容器 webm，而 mp4 是非流式的。那如何解释清楚流式的视频数据呢，从专业的角度三言两语很难说清楚，但用大白话翻译过来就是流式的视频数据支持分段独立播放，非流式的不可以。换句话说一个10M的视频文件，流式的视频可以把0~1M的数据请求回来单独播放，但是非流式的不可以。  </p><p>上面我们描述了视频格式的不同，接下来我们要说的是第一张图中的视频加载是浏览器来控制的，通过给 video 的 src 属性配置视频地址，触发播放之后浏览器就会开始下载了，JS干涉不了。而 Youtube 的视频加载是通过JS来控制的，各位可以再次看下第二张图的网络请求类型：xhr，足以证明这一点。</p><p>上面两点搞清楚之后我们就该说下清晰度切换的事情了。这个需求大家都不陌生，但是直接使用 mp4 格式做无缝清晰度切换，难度还挺大的。先解释下“无缝清晰度切换”的概念：从播放一个分辨率的视频到另一个分辨率且保证画面、声音不停顿的平滑切换过程。了解了这个概念，大家应该知道了用 video 无缝切换 mp4 有多难。一方面，video 是不支持流式的视频格式的，一方面，video 的加载是不受JS控制的。通过切换 video 的 src 属性，必然会导致画面中断、重新请求视频数据等。有的同学想到说利用两个 video 再结合 z-index 来搞，但是当你生成另一个video去加载视频的时候，无法保证两个画面是严格一致的，即使将原来的画面暂停到一个时刻，用另一个视频通过 currentTime 属性与之同步，切换仍然看到画面闪烁，基本无法和 Youtube 无缝切换的体验匹敌。而且还会造成更多流量的浪费，背后的原因大家可以研究下 mp4 容器和 webm 容器的异同，也可以看下视频解码相关的文章。</p><p>还有一种方法就是将 mp4 格式统统转码到流式的视频格式比如 hls、webm 等。不过这种看上去可行的方式实际上会带来很大的成本开销，如将大量视频做转码会消耗高昂的机器资源、双倍存储的费用、CDN的双倍费用等等。其实我们也是在这种背景下研究出来新的技术问题解决清晰度无缝切换的。</p><p>首先，我们改变对 mp4 视频的播放流程，不再直接使用 video 的 src 来播放，因为我们没有任何可以操作的空间。video不仅支持 src 属性还支持 Blob 对象，我们就是利用后者。播放的流程如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/6/1646f98cd46f50ae?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><p>图1.3 mp4 视频新播放流程</p><ol><li><p>来请求 mp4 视频数据，这样可以结合视频 Range 服务，做到精确加载。</p></li><li><p>编写解析器将加载回来的部分 mp4 视频数据进行解复用</p></li><li><p>将解复用的视频数据转成 fmp4 格式并传递给 MediaSource</p></li><li><p>使用 video 进行解码完成播放</p></li></ol><p>然后在做清晰度切换的时候流程如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/6/1646f98cd4990b8e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><p>图1.4 mp4视频清晰度切换原理示意图  </p><ol><li><p>播放视频A，过程同上</p></li><li><p>在某个时刻，用户切换到播放视频B，首先解析B的索引文件（moov），反向计算mp4的range区间</p></li><li><p>加载B的视频区间数据</p></li><li><p>解复用</p></li><li><p>把数据转换成fmp4格式并传递给MediaSource</p></li><li><p>删除A的部分Buffer</p></li><li><p>在下一个关键帧自动完成画质的切换</p></li></ol><p><img src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1080&quot; height=&quot;551&quot;&gt;&lt;/svg" alt=""></p><p>图1.5 mp4视频清晰度切换流程示意图</p><p>这个过程看上去比较繁琐，但是所有的操作都是在浏览器端完成，也就是说都是JS来实现的。这样之前说的所有成本问题都不存在，还能做到youtube相同体验的无缝切换。如果大家也想使用这个功能不需要自己再去实现一遍上述流程，可以使用如下代码：</p><p><img src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1080&quot; height=&quot;468&quot;&gt;&lt;/svg" alt=""></p><p>如果对这段代码有什么疑惑，或者想深入了解下它背后是如何实现的，可以参考<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fbytedance%2Fxgplayer" target="_blank" rel="noopener">github.com/bytedance/x…</a></p><p>长按识别二维码 ⬇️</p><p><img src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;136&quot; height=&quot;136&quot;&gt;&lt;/svg" alt=""></p><h2 id="节省视频流量"><a href="#节省视频流量" class="headerlink" title="节省视频流量"></a>节省视频流量</h2><p>使用 video 的同学基本上都是这样用的，如下：</p><ol><li>利用src属性</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/7/6/1646f98ced13fa47?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><p>  2. 利用source标签</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/6/1646f98cf079b8bd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><p>这样就可以播放视频了，不过前面我们讲过这样使用 video ，视频的加载是受浏览器控制的，可以看下浏览器在视频刚开始播放的时候下载了多少数据：</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/6/1646f98cf4a14e2c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><p>图2.1 video默认下载截图</p><p>我随便找了个视频，大家看下视频总长度是 02:08,在播放到 00:05 的时候，浏览器已经下载到 01:30 了，如果用户终止观看，下载的视频就这样被浪费掉了。当然，如果不断的 seek 也会造成较多的流量浪费。按照我们之前的统计在短视频领域，用户 seek 的频率在 80%，所以这部分流量是可以节省掉的。具体原理如下:</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/6/1646f98cfcfa6bc3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><p>图2.2 播放器加载视频原理</p><ol><li><p>设置每次加载的数据包大小</p></li><li><p>设置预加载时长</p></li><li><p>开启加载队列，完成第一次数据包下载，判断缓冲时间和预加载时长是否满足，不满足请求下一个数据包</p></li></ol><p>具体实现代码如下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/7/6/1646f98cfdee42eb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><p>这样就实现了视频在播放过程中永远只预加载10秒的数据，进而保证节省流量。</p><p>了解超能力西瓜播放器是如何炼成的： <a href="https://link.juejin.im?target=http%3A%2F%2Fh5player.bytedance.com" target="_blank" rel="noopener">h5player.bytedance.com</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;洞察-video-超能力系列——玩转-mp4&quot;&gt;&lt;a href=&quot;#洞察-video-超能力系列——玩转-mp4&quot; class=&quot;headerlink&quot; title=&quot;洞察 video 超能力系列——玩转 mp4&quot;&gt;&lt;/a&gt;洞察 video 超能力系列——玩转 m
      
    
    </summary>
    
      <category term="前端" scheme="https://motainzhang.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="后端" scheme="https://motainzhang.com/categories/%E5%89%8D%E7%AB%AF/%E5%90%8E%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>2018春招前端面试</title>
    <link href="https://motainzhang.com/2019/10/18/%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95nodejs/"/>
    <id>https://motainzhang.com/2019/10/18/春招面试nodejs/</id>
    <published>2019-10-18T03:34:00.262Z</published>
    <updated>2019-10-18T03:34:00.262Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="2018春招前端面试-闯关记-精排精校"><a href="#2018春招前端面试-闯关记-精排精校" class="headerlink" title="2018春招前端面试: 闯关记(精排精校)"></a>2018春招前端面试: 闯关记(精排精校)</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>去年年末研发组解散失业, so选择回去学车了,也顺利拿到了<strong>驾照</strong></p><p>最近回归大深圳….开始踏上漫漫的找工作之路;</p><p>“拉勾上吊一百年不匹配!!!”,”BOSS直聘日夜没反应!!!”</p><p>题目范围涵盖我最近遇到的笔试题和面谈的(CSS/JS/HTTP/Node/Hybrid/Vue/NG/React)</p><p>emm…..这里不列举哪些公司了, 若是你完整的阅读一遍,相信你有不少的收获,谢谢阅读</p></blockquote><ul><li>截止目前(2018/3/23)总共汇总了140个问题(我去面的创业,中大型皆有)…</li><li>期间死在各种一面/二面/三面/四面皆有之,也拿到部分和推掉部分<code>offer</code>,还有一些后续不清楚的</li></ul><hr><h1 id="问题汇总-想到就写…"><a href="#问题汇总-想到就写…" class="headerlink" title="问题汇总,想到就写…."></a>问题汇总,想到就写….</h1><h3 id="Q-CSS-有哪些样式可以给子元素继承"><a href="#Q-CSS-有哪些样式可以给子元素继承" class="headerlink" title="Q: CSS 有哪些样式可以给子元素继承!"></a>Q: CSS 有哪些样式可以给子元素继承!</h3><ul><li>可继承的:<code>font-size</code>,<code>font-weight</code>,<code>line-height</code>,<code>color</code>,<code>cursor</code>等</li><li>不可继承的一般是会改变盒子模型的:<code>display</code>,<code>margin</code>、<code>border</code>、<code>padding</code>、<code>height</code>等</li></ul><p>更加全面的可以到引擎找</p><hr><h3 id="Q-行内元素有哪些？块级元素有哪些？-空-void-元素有那些？"><a href="#Q-行内元素有哪些？块级元素有哪些？-空-void-元素有那些？" class="headerlink" title="Q: 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？"></a>Q: 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？</h3><ul><li>行内: <code>input</code>,<code>span</code>,<code>a</code>,<code>img</code>以及<code>display:inline</code>的元素</li><li>块级: <code>p</code>,<code>div</code>,<code>header</code>,<code>footer</code>,<code>aside</code>,<code>article</code>,<code>ul</code>以及<code>display:block</code>这些</li><li>void: <code>br</code>,<code>hr</code></li></ul><hr><h3 id="Q-CSS3实现一个扇形"><a href="#Q-CSS3实现一个扇形" class="headerlink" title="Q: CSS3实现一个扇形"></a>Q: CSS3实现一个扇形</h3><ul><li><p>思路跟画实体三角形一个道理,只不过多了一个圆角属性</p><p>&lt;!DOCTYPE html&gt;</p><html lang="en"><br><br><head><meta name="generator" content="Hexo 3.8.0"><br>  <meta charset="UTF-8"><br>  <meta name="viewport" content="width=device-width, initial-scale=1.0"><br>  <meta http-equiv="X-UA-Compatible" content="ie=edge"><br>  <title>扇形</title><br>  <style><br>    .sector {<br>      width: 0;<br>      height: 0;<br>      border-width: 50px;<br>      border-style: solid;<br>      border-color: #f00 transparent transparent;<br>      border-radius: 50px;<br>    }<br>  </style><br></head><br><body><br>  <div class="sector"></div><br><script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/haruto.model.json"},"display":{"position":"right","width":100,"height":200},"mobile":{"show":true},"react":{"opacityDefault":1,"opacityOnHover":0.2},"log":false});</script></body><br><br></html><p>复制代码</p></li></ul><hr><h3 id="Q-box-sizing常用的属性有哪些-分别有啥作用"><a href="#Q-box-sizing常用的属性有哪些-分别有啥作用" class="headerlink" title="Q: box-sizing常用的属性有哪些? 分别有啥作用?"></a>Q: <code>box-sizing</code>常用的属性有哪些? 分别有啥作用?</h3><p><code>box-sizing</code>有两个值:<code>content-box(W3C标准盒模型)</code>,<code>border-box(怪异模型)</code>,</p><p>这个css 主要是改变盒子模型大小的计算形式</p><p>可能有人会问<code>padding-box</code>,这个之前只有 Firefox 标准实现了,目前50+的版本已经废除;</p><p>用一个栗子来距离,一个<code>div</code>的宽高分别<code>100px</code>,<code>border</code>为<code>5px</code>,<code>padding</code>为<code>5px</code></p><pre><code>  &lt;style&gt;    .test {      box-sizing: content-box;      border: 5px solid #f00;      padding:5px;      width: 100px;      height: 100px;    }  &lt;/style&gt;  &lt;div class=&quot;test&quot;&gt;&lt;/div&gt;&lt;!--content-box的计算公式会把宽高的定义指向 content,border和 padding 另外计算,也就是说 content + padding + border = 120px(盒子实际大小)而border-box的计算公式是总的大小涵盖这三者, content 会缩小,来让给另外两者content(80px) + padding(5*2px) + border(5*2px) = 100px--&gt;复制代码</code></pre><hr><h3 id="Q-清除浮动的方式有哪些-比较好的是哪一种"><a href="#Q-清除浮动的方式有哪些-比较好的是哪一种" class="headerlink" title="Q: 清除浮动的方式有哪些?比较好的是哪一种?"></a>Q: 清除浮动的方式有哪些?比较好的是哪一种?</h3><p>常用的一般为三种<code>.clearfix</code>, <code>clear:both</code>,<code>overflow:hidden</code>;</p><p>比较好是 <code>.clearfix</code>,伪元素万金油版本…后两者有局限性..等会再扯</p><pre><code>    .clearfix:after {      visibility: hidden;      display: block;      font-size: 0;      content: &quot; &quot;;      clear: both;      height: 0;    }&lt;!--为毛没有 zoom ,_height 这些...IE6,7这类需要 csshack 不再我们考虑之内了.clearfix 还有另外一种写法...--&gt;.clearfix:before, .clearfix:after {    content:&quot;&quot;;    display:table;}.clearfix:after{    clear:both;    overflow:hidden;}.clearfix{    zoom:1;}&lt;!--用display:table 是为了避免外边距margin重叠导致的margin塌陷,内部元素默认会成为 table-cell 单元格的形式--&gt;复制代码</code></pre><p><code>clear:both</code>:若是用在同一个容器内相邻元素上,那是贼好的…有时候在容器外就有些问题了, 比如相邻容器的包裹层元素塌陷</p><p><code>overflow:hidden</code>:这种若是用在同个容器内,可以形成 <code>BFC</code>避免浮动造成的元素塌陷</p><hr><h3 id="Q-CSS-中transition和animate有何区别-animate-如何停留在最后一帧"><a href="#Q-CSS-中transition和animate有何区别-animate-如何停留在最后一帧" class="headerlink" title="Q: CSS 中transition和animate有何区别? animate 如何停留在最后一帧!"></a>Q: CSS 中<code>transition</code>和<code>animate</code>有何区别? <code>animate</code> 如何停留在最后一帧!</h3><p>这种问题见仁见智,我的回答大体是这样的..待我捋捋.</p><p><code>transition</code>一般用来做过渡的, 没时间轴的概念, 通过事件触发(一次),没中间状态(只有开始和结束)</p><p>而<code>animate</code>则是做动效,有时间轴的概念(帧可控),可以重复触发和有中间状态;</p><p>过渡的开销比动效小,前者一般用于交互居多,后者用于活动页居多;</p><p>至于如何让<code>animate</code>停留在最后一帧也好办,就它自身参数的一个值就可以了</p><pre><code>animation-fill-mode: forwards;  &lt;!--backwards则停留在首帧,both是轮流--&gt;复制代码</code></pre><p>让我们来举个栗子….自己新建一个 html 跑一下….</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;  &lt;title&gt;Box-sizing&lt;/title&gt;  &lt;style&gt;    .test {      box-sizing: border-box;      border: 5px solid #f00;      padding: 5px;      width: 100px;      height: 100px;      position:absolute;      /*      简写的姿势排序      @keyframes name : 动画名      duration 持续时间      timing-function 动画频率      delay 延迟多久开始      iteration-count 循环次数      direction 动画方式,往返还是正向      fill-mode  一般用来处理停留在某一帧      play-state running 开始,paused 暂停 ....       更多的参数去查文档吧..我就不一一列举了      */      animation: moveChangeColor  ease-in 2.5s 1  forwards running;    }    @keyframes moveChangeColor {       from {         top:0%;         left:5%;         background-color:#f00       }       to{         top:0%;         left:50%;         background-color:#ced;       }    }  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;div class=&quot;test&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;复制代码</code></pre><hr><h3 id="Q-块级元素水平垂直居中的方法"><a href="#Q-块级元素水平垂直居中的方法" class="headerlink" title="Q: 块级元素水平垂直居中的方法"></a>Q: 块级元素水平垂直居中的方法</h3><p>我们要考虑两种情况,定宽高和不定宽高的;</p><p>方案 N 多种,我记得我很早写过这类的笔记</p><p>传送门:<a href="https://link.juejin.im?target=http%3A%2F%2Fblog.csdn.net%2Fcolumn%2Fdetails%2Fcenter-layout.html" target="_blank" rel="noopener">网页元素居中攻略记</a></p><hr><h3 id="Q-说说样式权重的优先级"><a href="#Q-说说样式权重的优先级" class="headerlink" title="Q: 说说样式权重的优先级;"></a>Q: 说说样式权重的优先级;</h3><p><code>!important</code> &gt; 行内样式 > <code>id</code> > <code>class</code> > <code>tag</code></p><p>样式权重可以叠加, 比如 <code>id&gt;class</code></p><hr><h3 id="Q-对HTML语义化的理解"><a href="#Q-对HTML语义化的理解" class="headerlink" title="Q: 对HTML语义化的理解"></a>Q: 对HTML语义化的理解</h3><p>简言之:就是不滥用标签(比如 DIV)/随意嵌套(比如 span&gt;div) ,</p><p>类的命名要合理, 利于浏览器解析乃至引擎收录,也利于团队协作和维护</p><hr><h3 id="Q-JS有几种数据类型-其中基本数据类型有哪些"><a href="#Q-JS有几种数据类型-其中基本数据类型有哪些" class="headerlink" title="Q: JS有几种数据类型,其中基本数据类型有哪些!"></a>Q: JS有几种数据类型,其中基本数据类型有哪些!</h3><p><strong>七种数据类型</strong></p><ul><li>Boolean</li><li>Null</li><li>Undefined</li><li>Number</li><li>String</li><li>Symbol (ECMAScript 6 新定义)</li><li>Object</li></ul><p>(ES6之前)其中5种为基本类型:<code>string</code>,<code>number</code>,<code>boolean</code>,<code>null</code>,<code>undefined</code>,</p><p>ES6出来的<code>Symbol</code>也是原始数据类型 ，表示独一无二的值</p><p><code>Object</code> 为引用类型(范围挺大),也包括数组、函数,</p><hr><h3 id="Q-null和undefined的差异"><a href="#Q-null和undefined的差异" class="headerlink" title="Q: null和undefined的差异"></a>Q: <code>null</code>和<code>undefined</code>的差异</h3><p>大体说一下,想要知其所以然请引擎搜索</p><p>相同点:</p><ul><li>在 <code>if</code>判断语句中,值都默认为 <code>false</code></li><li>大体上两者都是代表<strong>无</strong>,具体看差异</li></ul><p>差异:</p><ul><li><code>null</code>转为数字类型值为0,而<code>undefined</code>转为数字类型为 <code>NaN(Not a Number)</code></li><li><code>undefined</code>是代表调用一个值而该值却没有赋值,这时候默认则为<code>undefined</code></li><li><code>null</code>是一个很特殊的对象,最为常见的一个用法就是作为参数传入(说明该参数不是对象)</li><li>设置为<code>null</code>的变量或者对象会被内存收集器回收</li></ul><hr><h3 id="Q-JS-的DOM-操作-Node节点获取及增删查改"><a href="#Q-JS-的DOM-操作-Node节点获取及增删查改" class="headerlink" title="Q: JS 的DOM 操作(Node节点获取及增删查改);"></a>Q: JS 的DOM 操作(Node节点获取及增删查改);</h3><ul><li>获取(太多了,有<code>document.getElementById/ClassName/Name/TagName 等,或者 querySelector</code>)</li></ul><pre><code>// example// get Nodevar element = document.querySelector(&apos;#test&apos;);// 追加element.appendChild(Node);// 删除element.removeChild(Node);// 查找element.nextSibling // 获取元素之后的兄弟节点 , 会拿到注释文本,空白符这些element.nextElementSibling  // 等同, 获取标签(不会拿到注释文本这些)element.previousSibling // 和上面同理,往前找兄弟节点element.previousElementSibling// 改动,比如 属性这些element.setAttribute(name, value); // 增加属性element.removeAttribute(attrName); //删除属性// 来一个简易的练习题,随便一个网页追加插入一块DOM(非覆盖:不能 innerHTML);/*&lt;div id=&quot;test&quot;&gt;   &lt;span&gt;Hello, World&lt;/span&gt;&lt;/div&gt;*/// 以上面的例子为例var test = document.createElement(&apos;div&apos;);  // 创建一个块级元素test.setAttribute(&quot;id&quot;,&quot;test&quot;); // 设置其id 属性var span = document.createElement(&apos;span&apos;); // 创建一个 spanspan.innerText = &quot;Hello,world&quot;; // 插入 span 的文本内容test.appendChild(span); // 组合节点element.appendChild(test); //追加到某个节点区域复制代码</code></pre><hr><h3 id="Q-给一个-DOM添加捕获和冒泡的两种写法的事件点击-谁先执行"><a href="#Q-给一个-DOM添加捕获和冒泡的两种写法的事件点击-谁先执行" class="headerlink" title="Q: 给一个 DOM添加捕获和冒泡的两种写法的事件点击,谁先执行?"></a>Q: 给一个 <code>DOM</code>添加捕获和冒泡的两种写法的事件点击,谁先执行?</h3><p>分情况分析:</p><ul><li>有拿到节点的,优先捕获,没有才往上冒泡寻找</li><li>若是通过<code>node.addEventListener(&#39;event&#39;,callback,bubble or capture)</code>; 谁先调用谁先执行</li></ul><p><strong>stackoverflow 有相关的探讨</strong>:</p><ul><li><a href="https://link.juejin.im?target=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F11841330%2Fevent-listeners-registered-for-capturing-phase-not-triggered-before-bubbling-w" target="_blank" rel="noopener">Event listeners registered for capturing phase not triggered before bubbling - why?</a></li></ul><hr><h3 id="Q-谈谈你对ajax-的理解-以及用原生-JS-实现有哪些要点需要注意"><a href="#Q-谈谈你对ajax-的理解-以及用原生-JS-实现有哪些要点需要注意" class="headerlink" title="Q: 谈谈你对ajax 的理解,以及用原生 JS 实现有哪些要点需要注意;"></a>Q: 谈谈你对ajax 的理解,以及用原生 JS 实现有哪些要点需要注意;</h3><p><code>ajax</code>全称是<code>异步 javascript 和 XML</code>,用来和服务端进行数据交互的,让无刷新替换页面数据成了可能;</p><p>至于有哪些要要点,来一个简短的<code>ajax</code>请求</p><pre><code>var xhr = new XMLHttpRequest(); // 声明一个请求对象xhr.onreadystatechange = function(){    if(xhr.readyState === 4){  // readyState 4 代表已向服务器发送请求        if(xhr.status === OK){ // // status 200 代表服务器返回成功            console.log(xhr.responseText); // 这是返回的文本        } else{            console.log(&quot;Error: &quot;+ xhr.status); // 连接失败的时候抛出错误        }    }}xhr.open(&apos;GET&apos;, &apos;xxxx&apos;);// 如何设置请求头? xhr.setRequestHeader(header, value);xhr.setRequestHeader(&apos;Content-Type&apos;, &apos;application/json&apos;);xhr.send(null); // get方法 send null(亦或者不传,则直接是传递 header) ,post 的 send 则是传递值复制代码</code></pre><p>更为详细的可以阅读此处;</p><ul><li><a href="https://link.juejin.im?target=http%3A%2F%2Fjavascript.ruanyifeng.com%2Fbom%2Fajax.html%23toc19" target="_blank" rel="noopener">&lt;<ajax 概念="" by="" 阮一峰="">&gt;</ajax></a></li><li><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.html5rocks.com%2Fzh%2Ftutorials%2Ffile%2Fxhr2%2F" target="_blank" rel="noopener">&lt;<xmlhttprequest2 用法指南="">&gt;</xmlhttprequest2></a></li></ul><hr><h3 id="Q-JS-实现一个闭包函数-每次调用都自增1"><a href="#Q-JS-实现一个闭包函数-每次调用都自增1" class="headerlink" title="Q: JS 实现一个闭包函数,每次调用都自增1;"></a>Q: JS 实现一个闭包函数,每次调用都自增1;</h3><p>这里主要考察了闭包,函数表达式以及 IIFE(立即执行表达式)</p><pre><code>var add = (function() {  // 声明一变量,由于下面 return所以变量只会声明一次  var count = 0;   return function() {    return console.log(count++);  };})();add(); // 0add(); // 1add(); // 2复制代码</code></pre><hr><h3 id="Q-‘1’-’2’-’3’-map-parseInt-输出什么-为什么"><a href="#Q-‘1’-’2’-’3’-map-parseInt-输出什么-为什么" class="headerlink" title="Q: [‘1’,’2’,’3’].map(parseInt) 输出什么,为什么?"></a>Q: [‘1’,’2’,’3’].map(parseInt) 输出什么,为什么?</h3><pre><code>[&apos;1&apos;,&apos;2&apos;,&apos;3&apos;].map(parseInt); // [1,NaN,NaN]// 刨析// map有三个参数:数组元素，元素索引，原数组本身// parseInt有两个参数,元素本身以及进制// 理清了这两个就好办了...// [&apos;1&apos;,&apos;2&apos;,&apos;3&apos;].map(parseInt); 等于如下[&apos;1&apos;,&apos;2&apos;,&apos;3&apos;].map(function(item,index,array){    return parseInt(item,index); // 是不是一目了然});// parseInt(&quot;1&quot;,0); =&gt; 1// parseInt(&quot;2&quot;,1); =&gt; NaN// parseInt(&quot;3&quot;,2); =&gt; NaN复制代码</code></pre><hr><h3 id="Q-对数组-‘2018-03-05’-‘2013-06-12’-’2019-03-12’-’2018-03-05’-’2014-02-22’-去重且排序"><a href="#Q-对数组-‘2018-03-05’-‘2013-06-12’-’2019-03-12’-’2018-03-05’-’2014-02-22’-去重且排序" class="headerlink" title="Q: 对数组 [‘2018-03-05’, ‘2013-06-12’,’2019-03-12’,’2018-03-05’,’2014-02-22’] 去重且排序"></a>Q: 对数组 [‘2018-03-05’, ‘2013-06-12’,’2019-03-12’,’2018-03-05’,’2014-02-22’] 去重且排序</h3><p>我这里用的是结合 <code>ES6</code>的,代码量很短</p><pre><code>//很好理解, Set 具有值唯一性(但不是所有值,等会我抛出我的另外一篇文章)// 结合...解构,可以把可迭代(比如 arguments/nodelist 等)的转为数组// sort 里面传入 两个值比较,返回-1和1是因为1代表这个数大排后(相对),-1代表小(相对),0为相等let arr = [...new Set([&apos;2018-03-05&apos;, &apos;2013-06-12&apos;,&apos;2019-03-12&apos;,&apos;2018-03-05&apos;,&apos;2014-02-22&apos;])].sort(function(a,b){  return a&lt;b ? -1:1; // 这里返回的是升序的,降序改下返回值就好了.所以是相对})// [&quot;2013-06-12&quot;, &quot;2014-02-22&quot;, &quot;2018-03-05&quot;, &quot;2019-03-12&quot;]复制代码</code></pre><p>对于数组去重的,有兴趣的可以看下我这篇水文:</p><ul><li><a href="https://link.juejin.im?target=https%3A%2F%2Fjuejin.im%2Fpost%2F5913e038570c350069235fbe" target="_blank" rel="noopener">JS数组去重!!!一篇不怎么靠谱的”深度”水文</a></li></ul><hr><h3 id="Q-对数组-1-2-3-4-5-39-6-39-7-39-8-39-39-a-39-39-b-39-39-z-39-进行乱序"><a href="#Q-对数组-1-2-3-4-5-39-6-39-7-39-8-39-39-a-39-39-b-39-39-z-39-进行乱序" class="headerlink" title="Q: 对数组[1,2,3,4,5,&#39;6&#39;,7,&#39;8&#39;,&#39;a&#39;,&#39;b&#39;,&#39;z&#39;]进行乱序"></a>Q: 对数组<code>[1,2,3,4,5,&#39;6&#39;,7,&#39;8&#39;,&#39;a&#39;,&#39;b&#39;,&#39;z&#39;]</code>进行乱序</h3><pre><code>// 我们依旧可以用上面的 sort 的原理实现乱序let tempArr = [1,2,3,4,5,&apos;6&apos;,7,&apos;8&apos;,&apos;a&apos;,&apos;b&apos;,&apos;z&apos;].sort(function(){  return Math.random() &gt; 0.5 ? -1 : 1;})// 因为里面有随机数,所以答案没有标准答案,我这边跑了一次是输出这个//[&quot;6&quot;, &quot;z&quot;, 3, &quot;b&quot;, 5, 2, 7, &quot;8&quot;, &quot;a&quot;, 1, 4]复制代码</code></pre><p><strong>上面和这道题逗涉及到数组顺序的问题,想了解下为什么 <code>a-b</code>,<code>a&gt;b</code>这类可以更改排序</strong></p><p>可以看看知乎对于这块的探讨: <a href="https://link.juejin.im?target=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F22781233" target="_blank" rel="noopener">传送门:javascript排序return a-b?</a></p><hr><h3 id="Q-求-1-10-11-1-39-5-39-12-13-14-15-2-3-4-7-8-9-内最大值与最小值之差"><a href="#Q-求-1-10-11-1-39-5-39-12-13-14-15-2-3-4-7-8-9-内最大值与最小值之差" class="headerlink" title="Q: 求[1, 10, 11, -1,&#39;-5&#39;,12, 13, 14, 15, 2, 3, 4, 7, 8, 9]内最大值与最小值之差"></a>Q: 求<code>[1, 10, 11, -1,&#39;-5&#39;,12, 13, 14, 15, 2, 3, 4, 7, 8, 9]</code>内最大值与最小值之差</h3><pre><code>// 来一个很粗糙的版本,只当传入是数组且可以隐性转为数字的function MaxMinPlus(arr) {  // 返回最大值与最小值之差  return Array.isArray(arr) ? Math.max.apply(Math, arr) - Math.min.apply(Math, arr) : console.log(&apos;传入的不是数组亦或者未能解决的错误&apos;)}// 结果是 20// 若是要完善的话,要考虑传入的是非数组,//传入字符串的时候要判断,然后切割为数组..// 都要考虑进去代码量不短复制代码</code></pre><hr><h3 id="Q-请给Array实现一个方法-去重后返回重复的字符-新数组"><a href="#Q-请给Array实现一个方法-去重后返回重复的字符-新数组" class="headerlink" title="Q: 请给Array实现一个方法,去重后返回重复的字符(新数组)"></a>Q: 请给<code>Array</code>实现一个方法,去重后返回重复的字符(新数组)</h3><pre><code>  var testArr = [1,6,8,3,7,9,2,7,2,4,4,3,3,1,5,3];  Array.prototype.extraChar = function(){      var cacheExtraChar = []; // 缓存重复出现的字符      var that = this; // 缓存 this;      this.map(function(item,index){          // 怎么理解这段代码呢?          // 就是向前往后查找一遍和从后往前查找一遍,不等就是没有重复          // 为什么还要判断一遍缓存,是过滤缓存数组内多次写入          (that.indexOf(item) !== that.lastIndexOf(item)) &amp;&amp; cacheExtraChar.indexOf(item) === -1 ? cacheExtraChar.push(item) : -1;      });      return cacheExtraChar;  }testArr.extraChar(); // [1, 3, 7, 2, 4]// 若是还需要排序就再排序下[1,6,8,3,7,9,2,7,2,4,4,3,3,1,5,3].extraChar().sort(function(a,b){return a-b}) // [1, 2, 3, 4, 7]复制代码</code></pre><hr><h3 id="Q-一个数组中-par中存放了多个人员的信息-每个人员的信息由-name-和-age-构成-name-39-张三-39-age-15-请用-JS-实现年龄从小到大的排序"><a href="#Q-一个数组中-par中存放了多个人员的信息-每个人员的信息由-name-和-age-构成-name-39-张三-39-age-15-请用-JS-实现年龄从小到大的排序" class="headerlink" title="Q: 一个数组中 par中存放了多个人员的信息,每个人员的信息由 name 和 age 构成({name:&#39;张三&#39;,age:15}).请用 JS 实现年龄从小到大的排序;"></a>Q: 一个数组中 par中存放了多个人员的信息,每个人员的信息由 <code>name</code> 和 <code>age</code> 构成(<code>{name:&#39;张三&#39;,age:15}</code>).请用 JS 实现年龄从小到大的排序;</h3><pre><code>var par = [{age:5,name:&apos;张三&apos;},{age:3,name:&apos;李四&apos;},{age:15,name:&apos;王五&apos;},{age:1,name:&apos;随便&apos;}]var parSort = par.sort(function(a,b){    return a.age - b.age;})复制代码</code></pre><hr><h3 id="Q-判断一个回文字符串和同字母异序字符串"><a href="#Q-判断一个回文字符串和同字母异序字符串" class="headerlink" title="Q: 判断一个回文字符串和同字母异序字符串"></a>Q: 判断一个回文字符串和同字母异序字符串</h3><ul><li>回文字符串就是正序倒序都是一样的;</li><li>同字母异序字符串则是字符串都一样,但是位置可能不一定一样,比如<code>abcefd</code>和<code>dceabf</code>=&gt;<code>return true</code></li></ul><p>后者的思路就是用排序把异序扭正..</p><p><strong>普通版</strong></p><pre><code>// 回文判断 , 比如用 abcbavar isPalindromes = function(params){  params = params.toString().toLowerCase()  return params === params.split(&apos;&apos;).reverse().join(&apos;&apos;);}// 同字母异序判定,比如`abcefd`和`dceabf`var isAnagram = function(str1, str2)  {  str1 = str1.toString().toLowerCase();  str2 = str2.toString().toLowerCase();  return str1.split(&apos;&apos;).sort().join(&apos;&apos;) === str2.split(&apos;&apos;).sort().join(&apos;&apos;)}复制代码</code></pre><p><strong>进阶版:多一些特殊字符</strong></p><p>若是我们要去除所有非字母数字的字符,则需要用到正则</p><pre><code>// 进阶版: isPalindromes(&apos;abc_ &amp;b #@a&apos;)var isPalindromes = function(params){  // 传入参数先转为字符串且全部转为小写,最后去除多余字符比较  params = params.toString().toLowerCase().replace(/[\W_\s]/g,&apos;&apos;);  console.log(params)  return params === params.split(&apos;&apos;).reverse().join(&apos;&apos;);}// 进阶版同字母异序: isAnagram(&apos;ab *&amp;cef#d&apos;,&apos;!d@ce^abf&apos;)var isAnagram = function(str1, str2)  {  str1 = str1.toString().toLowerCase().replace(/[\W_\s]/g,&apos;&apos;);  str2 = str2.toString().toLowerCase().replace(/[\W_\s]/g,&apos;&apos;);  return str1.split(&apos;&apos;).sort().join(&apos;&apos;) === str2.split(&apos;&apos;).sort().join(&apos;&apos;)}复制代码</code></pre><hr><h3 id="Q-JS-实现String-trim-方法"><a href="#Q-JS-实现String-trim-方法" class="headerlink" title="Q: JS 实现String.trim()方法;"></a>Q: JS 实现<code>String.trim()</code>方法;</h3><pre><code>// 原生是有 trim()方法的.我们要模拟一个;String.prototype.emuTrim = function(){    // 这条正则很好理解,就是把头部尾部多余的空格字符去除    return this.replace(/(^\s*)|(\s*$)/g,&apos;&apos;);}&apos;  fsaf fsdaf f safl lllll    &apos;.emuTrim();  //&quot;fsaf fsdaf f safl lllll&quot; 复制代码</code></pre><hr><h3 id="Q-JS-实现函数运行一秒后打印输出0-9-给定如下代码"><a href="#Q-JS-实现函数运行一秒后打印输出0-9-给定如下代码" class="headerlink" title="Q: JS 实现函数运行一秒后打印输出0-9;给定如下代码"></a>Q: JS 实现函数运行一秒后打印输出0-9;给定如下代码</h3><pre><code>for(var i=0;i&lt;10;i++){  // TODO}复制代码</code></pre><ul><li>解法</li></ul><pre><code>// 这道题涉及到作用域for(var i=0;i&lt;10;i++){  setTimeout((function(i){   return function(){       console.log(i);   }  })(i),1000);}复制代码</code></pre><p>若是用到 ES6…那简直不能再简便了</p><pre><code>for(let i=0;i&lt;10;i++){  setTimeout(function(){       console.log(i);  },1000);}复制代码</code></pre><hr><h3 id="Q-实现对一个数组或者对象的浅拷贝和”深度”拷贝"><a href="#Q-实现对一个数组或者对象的浅拷贝和”深度”拷贝" class="headerlink" title="Q: 实现对一个数组或者对象的浅拷贝和”深度”拷贝"></a>Q: 实现对一个数组或者对象的浅拷贝和”深度”拷贝</h3><p>浅拷贝就是把属于源对象的值都复制一遍到新的对象,不会开辟两者独立的内存区域;</p><p>深度拷贝则是完完全全两个独立的内存区域,互不干扰</p><ul><li>浅拷贝</li></ul><pre><code>// 这个 ES5的function shallowClone(sourceObj) {  // 先判断传入的是否为对象类型  if (!sourceObj || typeof sourceObj !== &apos;object&apos;) {    console.log(&apos;您传入的不是对象!!&apos;)  }  // 判断传入的 Obj是类型,然后给予对应的赋值  var targetObj = sourceObj.constructor === Array ? [] : {};  // 遍历所有 key  for (var keys in sourceObj) {    // 判断所有属于自身原型链上的 key,而非继承(上游 )那些    if (sourceObj.hasOwnProperty(keys)) {      // 一一复制过来      targetObj[keys] = sourceObj[keys];    }  }  return targetObj;} // ES6 可以用 Object.assign(targeObj, source1,source2,source3) 来实现对象浅拷贝复制代码</code></pre><ul><li>深度拷贝</li></ul><pre><code>// 就是把需要赋值的类型转为基本类型(字符串这些)而非引用类型来实现// JOSN对象中的stringify可以把一个js对象序列化为一个JSON字符串，parse可以把JSON字符串反序列化为一个js对象var deepClone = function(sourceObj) {  if (!sourceObj || typeof sourceObj !== &apos;object&apos;) {    console.log(&apos;您传入的不是对象!!&apos;);    return;  }  // 转-&gt;解析-&gt;返回一步到位  return window.JSON    ? JSON.parse(JSON.stringify(sourceObj))    : console.log(&apos;您的浏览器不支持 JSON API&apos;);};复制代码</code></pre><ul><li><a href="https://link.juejin.im?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F33489557" target="_blank" rel="noopener">深拷贝的考虑点实际上要复杂的多,详情看看知乎怎么说</a></li></ul><hr><h3 id="Q-this对象的理解"><a href="#Q-this对象的理解" class="headerlink" title="Q: this对象的理解"></a>Q: this对象的理解</h3><p>简言之:谁调用指向谁,运行时的上下文确定,而非定义的时候就确定;</p><p>强行绑定 <code>this</code>的话,可以用 <code>call</code>,<code>apply</code>,<code>bind</code>,箭头函数….来修改<code>this</code>的指向</p><p>这类的文章太多,自行搜索吧….</p><p>Q: 看到你说到 <code>bind</code>,能用 JS简单的模拟个么?</p><pre><code>Function.prototype.emulateBind =  function (context) {    var self = this;    return function () {        return self.apply(context);    }}复制代码</code></pre><p>这个实现很粗糙…更为详细全面,考虑周全的(比如参数的处理什么的)…自行谷歌.</p><hr><h3 id="Q-JS-的作用域是什么-有什么特别之处么"><a href="#Q-JS-的作用域是什么-有什么特别之处么" class="headerlink" title="Q:JS 的作用域是什么?有什么特别之处么?"></a>Q:JS 的作用域是什么?有什么特别之处么?</h3><p>作用域就是有它自身的上下文区域(比如函数内),内部会有变量声明提升,函数声明提升这些;</p><p>函数声明提升优于变量声明提升..</p><p>作用域有全局作用域和块级作用域(局部,比如用 let 或者单纯花括号的);</p><p>作用域会影响<code>this</code>的指向</p><blockquote><p>坐等补充,我回答的时候,面试大佬只是 嗯..恩…恩…也不知道具体如何</p></blockquote><hr><h3 id="Q-怎么解决跨域问题-有哪些方法…"><a href="#Q-怎么解决跨域问题-有哪些方法…" class="headerlink" title="Q: 怎么解决跨域问题,有哪些方法…"></a>Q: 怎么解决跨域问题,有哪些方法…</h3><p>我一般用这三种,<code>cors</code>,<code>nginx反向代理</code>,<code>jsonp</code></p><ul><li><code>jsonp</code> : 单纯的 get 一些数据,局限性很大…就是利用script标签的src属性来实现跨域。</li><li><code>nginx 反向代理</code>: 主要就是用了<code>nginx.conf</code>内的<code>proxy_pass http://xxx.xxx.xxx</code>,会把所有请求代理到那个域名,有利也有弊吧..</li><li><code>cors</code>的话,可控性较强,需要前后端都设置,兼容性 IE10+ ,比如<ul><li>Access-Control-Allow-Origin: <a href="http://foo.example" target="_blank" rel="noopener">http://foo.example</a> // 子域乃至整个域名或所有域名是否允许访问</li><li>Access-Control-Allow-Methods: POST, GET, OPTIONS // 允许那些行为方法</li><li>Access-Control-Allow-Headers: X-PINGOTHER, Content-Type // 允许的头部字段</li><li>Access-Control-Max-Age: 86400 // 有效期</li></ul></li></ul><p>Q: 对于想携带一些鉴权信息跨域如何走起?比如<code>cookie</code>!</p><p>需要配置下 header <code>Access-Control-Allow-Credentials:true</code> ,具体用法看下面的<code>nginx</code>demo</p><p>当然<code>cros</code>的配置不仅仅这些,还有其他一些,具体引擎吧….</p><p>若是我们要用 <code>nginx</code>或者 <code>express</code> 配置<code>cors</code>应该怎么搞起? 来个简易版本的</p><ul><li><p>nginx</p><p>location / {</p><h1 id="检查域名后缀"><a href="#检查域名后缀" class="headerlink" title="检查域名后缀"></a>检查域名后缀</h1><pre><code>add_header Access-Control-Allow-Origin xx.xx.com;add_header Access-Control-Allow-Methods GET,POST,OPTIONS;add_header Access-Control-Allow-Credentials true;add_header Access-Control-Allow-Headers DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type;add_header Access-Control-Max-Age 86400;</code></pre><p>} </p><p>复制代码</p></li><li><p>express, 当然这货也有一些别人封装好的 <code>cors</code>中间件,操作性更强…</p><p>let express = require(‘express’);<br>let app = express();  </p><p>//设置所有请求的头部<br>app.all(‘*’, (req, res, next) =&gt;  {  </p><pre><code>res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;xx.xx.com&quot;);  res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type&quot;);  res.header(&quot;Access-Control-Allow-Credentials&quot;,&quot;true&quot;)res.header(&quot;Access-Control-Allow-Methods&quot;,&quot;PUT,POST,GET,DELETE,OPTIONS&quot;);  next();  </code></pre><p>});  </p><p>复制代码</p></li></ul><p>有些还会跟你死磕,,除了这些还有其他姿势么…我说了一个HTML5的<code>postMessage</code>….</p><p>..因为真心没用过,只是以前查阅的时候了解了下..只能大体点下</p><p>这货用于<code>iframe</code> 传递消息居多, 大体有这么两步步</p><ul><li><code>window</code>打开一个实例,传递一个消息到一个x域名</li><li>x 域名下监听<code>message</code>事件,获取传递的消息</li></ul><p>这货的兼容性没那么好,而且没考虑周全下容易遭受 <code>CSRF</code> 攻击</p><hr><h3 id="Q-对于XSS-和-CSRF-如何防范"><a href="#Q-对于XSS-和-CSRF-如何防范" class="headerlink" title="Q: 对于XSS 和 CSRF 如何防范"></a>Q: 对于<code>XSS</code> 和 <code>CSRF</code> 如何防范</h3><p>这里就不说概念性的东西了</p><ul><li><p>XSS的防范</p><ul><li>我能想到的就是转义<code>&lt;&gt;</code>这些造成代码直接运行的的标签..轮询或者正则替换<ul><li>而面试官说这种的效率最低下,我回来仔细找了找相关资料好像没有更优方案…有的留言…</li></ul></li><li>若是有用到 <code>cookie</code>,设置为<code>http-only</code>,避免客户端的篡改</li></ul></li><li><p>CSRF的防范一般这几种</p><ul><li>验证码,用户体验虽然不好,,但是很多场合下可以防范大多数攻击</li><li>验证 HTTP Referer 字段,判断请求来源</li><li>token加密解密,这种是目前很常用的手段了…</li></ul></li></ul><p>任何防范都有代价的,比如验证码造成的体验不好,<code>token</code>滥用造成的性能问题,轮询替换造成的响应时间等</p><hr><h3 id="Q-描述下cookie-sessionStorage-localStorage的差异"><a href="#Q-描述下cookie-sessionStorage-localStorage的差异" class="headerlink" title="Q: 描述下cookie,sessionStorage,localStorage的差异.."></a>Q: 描述下<code>cookie</code>,<code>sessionStorage</code>,<code>localStorage</code>的差异..</h3><ul><li><code>cookie</code> : 大小4KB 左右,跟随请求(请求头),会占用带宽资源,但是若是用来判断用户是否在线这些挺方便</li><li><code>sessionStorage</code>和<code>localStorage</code>大同小异,大小看浏览器支持,一般为5MB,数据只保留在本地,不参与服务端交互.<ul><li><code>sessionStorage</code>的生存周期只限于会话中,关闭了储存的数据就没了.</li><li><code>localStorage</code>则保留在本地,没有人为清除会一直保留</li></ul></li></ul><hr><h3 id="Q-javascript的原型链你怎么理解"><a href="#Q-javascript的原型链你怎么理解" class="headerlink" title="Q: javascript的原型链你怎么理解?"></a>Q: <code>javascript</code>的原型链你怎么理解?</h3><p>原型链算是 JS 内一种独有的机制,</p><p>所有对象都有一个内置<code>[[proto]]</code>指向创建它的原型对象(<code>prototype</code>)</p><p>原型链的基本用来实现继承用的</p><hr><h3 id="Q-javascript里面的继承怎么实现，如何避免原型链上面的对象共享"><a href="#Q-javascript里面的继承怎么实现，如何避免原型链上面的对象共享" class="headerlink" title="Q: javascript里面的继承怎么实现，如何避免原型链上面的对象共享"></a>Q: <code>javascript</code>里面的继承怎么实现，如何避免原型链上面的对象共享</h3><p>我在写的时候,用了两种,一个是 ES5和 ES6的方案</p><ul><li>ES5:寄生组合式继承:通过借用构造函数来继承属性和原型链来实现子继承父。</li></ul><pre><code>    function ParentClass(name) {      this.name = name;    }    ParentClass.prototype.sayHello = function () {      console.log(&quot;I&apos;m parent!&quot; + this.name);    }    function SubClass(name, age) {      //若是要多个参数可以用apply 结合 ...解构      ParentClass.call(this, name);      this.age = age;    }    SubClass.prototype = Object.create(ParentClass.prototype);    SubClass.prototype.constructor = SubClass;    SubClass.prototype.sayChildHello = function (name) {      console.log(&quot;I&apos;m child &quot; + this.name)    }    let testA = new SubClass(&apos;CRPER&apos;)    // Object.create()的polyfill    /*    function pureObject(o){        //定义了一个临时构造函数         function F() {}         //将这个临时构造函数的原型指向了传入进来的对象。         F.prototype = obj;         //返回这个构造函数的一个实例。该实例拥有obj的所有属性和方法。         //因为该实例的原型是obj对象。         return new F();    }    */复制代码</code></pre><ul><li><p>ES6: 其实就是ES5的语法糖,不过可读性很强..</p><pre><code>class ParentClass {  constructor(name) {    this.name = name;  }  sayHello() {    console.log(&quot;I&apos;m parent!&quot; + this.name);  }}class SubClass extends ParentClass {  constructor(name) {    super(name);  }  sayChildHello() {    console.log(&quot;I&apos;m child &quot; + this.name)  }  // 重新声明父类同名方法会覆写,ES5的话就是直接操作自己的原型链上  sayHello(){    console.log(&quot;override parent method !,I&apos;m sayHello Method&quot;)  }}let testA = new SubClass(&apos;CRPER&apos;)</code></pre><p>复制代码</p></li></ul><hr><h3 id="Q-ES6-你熟悉么-用过哪些特性"><a href="#Q-ES6-你熟悉么-用过哪些特性" class="headerlink" title="Q: ES6+你熟悉么,用过哪些特性?"></a>Q: ES6+你熟悉么,用过哪些特性?</h3><ul><li>箭头函数</li><li>类及引入导出和继承( <code>class</code>/<code>import</code>/<code>export</code>/<code>extends</code>)</li><li>字符串模板</li><li>Promise</li><li><code>let</code>,<code>const</code></li><li><code>async</code>/<code>await</code></li><li>默认参数/参数或变量解构装饰器</li><li><code>Array.inclueds</code>/<code>String.padStart|String.padEnd</code>/<code>Object.assign</code></li></ul><h4 id="Q-let-和-const-有啥差异"><a href="#Q-let-和-const-有啥差异" class="headerlink" title="Q: let 和 const 有啥差异?"></a>Q: let 和 const 有啥差异?</h4><ul><li><code>let</code> 会产生块级作用域,不会造成变量提升,无法重新声明(但可以重新赋值);</li><li><code>const</code><ul><li>是常量,若是基本数据类型,具有不变性(无法重新赋值改动)</li><li>引用值可以调整内部值(可能设计的时候没有考虑周全!</li></ul></li></ul><h4 id="Q-async和await的用途"><a href="#Q-async和await的用途" class="headerlink" title="Q: async和await的用途?"></a>Q: <code>async</code>和<code>await</code>的用途?</h4><ul><li>让 <code>promise</code> 的异步变成同步运行成了可能,<code>await</code> 可以等到 <code>promise</code> 执行完毕</li></ul><hr><h3 id="Q-箭头函数的this指向谁"><a href="#Q-箭头函数的this指向谁" class="headerlink" title="Q: 箭头函数的this指向谁?"></a>Q: 箭头函数的<code>this</code>指向谁?</h3><p>肯定很多小伙伴会说指向局部方法内!!答案是错误的…</p><p>箭头函数所改变的并非把 this 局部化，而是完全不把 this 绑定到里面去;</p><p>就是 this 是取自外部的上下级作用域(但是又不是常规 <code>function</code>的语法糖)..</p><p>因为箭头函数里并不支持 <code>var self = this</code> 或者 <code>.bind(this)</code> 这样的写法。</p><hr><h3 id="Q-问的时候你用过静态方法-静态属性-私有变量么"><a href="#Q-问的时候你用过静态方法-静态属性-私有变量么" class="headerlink" title="Q: 问的时候你用过静态方法,静态属性,私有变量么?"></a>Q: 问的时候你用过静态方法,静态属性,私有变量么?</h3><p>静态方法是ES6之后才有这么个玩意,有这么些特点</p><ul><li>方法不能给 this引用,可以给类直接引用</li><li>静态不可以给实例调用,比如 <code>let a = new ParentClass =&gt; a.sayHello() 会抛出异常</code></li><li>父类静态方法,子类非<code>static</code>方法没法覆盖父类</li><li>静态方法可以给子类继承</li><li>静态属性可以继承也可以被修改</li></ul><p>看下面的代码..</p><pre><code> class ParentClass {      constructor(name) {        this.name = name;      }      static sayHello() {        console.log(&quot;I&apos;m parent!&quot; + this.name);      }      static testFunc(){        console.log(&apos;emm...Parent test static Func&apos;)      }    }    class SubClass extends ParentClass {      constructor(name) {        super(name);      }      sayChildHello() {        console.log(&quot;I&apos;m child &quot; + this.name)      }      static sayHello() {        console.log(&quot;override parent method !,I&apos;m sayHello Method&quot;)      }      static testFunc2() {        console.log(super.testFunc() + &apos;fsdafasdf&apos;);      }    }    ParentClass.sayHello(); // success print    let a = new ParentClass(&apos;test&apos;);    a.sayHello() // throw error    SubClass.sayHello(); // 同名 static 可以继承且覆盖    SubClass.testFunc2(); // 可以继承    let testA = new SubClass(&apos;CRPER&apos;);复制代码</code></pre><p><strong>私有变量这个我没答出来,只是说了下没有<code>private</code>这个关键字和基本用下划线的人为区分</strong></p><p>所以回来只是找了下相关的资料,发现有一个比较好的模拟方案,就是<code>WeakMap</code>;</p><p><code>WeakMap</code>可以避免内存泄露,当没有被值引用的时候会自动给内存寄存器回收了.</p><pre><code>const _ = new WeakMap(); // 实例化,value 必须为对象,有 delete,get,has,set四个方法,看名字都知道了class TestWeakMap {  constructor(id, barcode) {    _.set(this, { id,barcode });  }  testFunc() {    let { id,barcode } = _.get(this); // 获取对应的值    return { id,barcode };  }}复制代码</code></pre><p>当然你也可以用<code>Symbol</code>来实现一个私有变量,这也是一个好法子</p><hr><h3 id="Q-谈谈你对-Promise-的理解-和-ajax-有关系么"><a href="#Q-谈谈你对-Promise-的理解-和-ajax-有关系么" class="headerlink" title="Q: 谈谈你对 Promise 的理解? 和 ajax 有关系么?"></a>Q: 谈谈你对 Promise 的理解? 和 ajax 有关系么?</h3><p><code>Promise</code>和<code>ajax</code>没有半毛钱直接关系.<code>promise</code>只是为了解决”回调地狱”而诞生的;</p><p>平时结合 <code>ajax</code>是为了更好的梳理和控制流程…这里我们简单梳理下..</p><p><code>Promise</code>有三种状态,Pending/resolve()/reject();</p><p>一些需要注意的小点,如下</p><ul><li>在 <code>Pending</code> 转为另外两种之一的状态时候,状态不可在改变..</li><li><code>Promise</code>的 <code>then</code>为异步.而(<code>new Promise()</code>)构造函数内为同步</li><li><code>Promise</code>的<code>catch</code>不能捕获任意情况的错误(比如 <code>then</code> 里面的<code>setTimout</code>内手动抛出一个<code>Error</code>)</li><li><code>Promise</code>的<code>then</code>返回<code>Promise.reject()</code>会中断链式调用</li><li><code>Promise</code>的 <code>resolve</code>若是传入值而非函数,会发生值穿透的现象</li><li><code>Promise</code>的<code>catch</code>还是<code>then</code>,<code>return</code>的都是一个新的 <code>Promise</code>(在 Promise 没有被中断的情况下)</li></ul><p>Promise 还有一些自带的方法,比如<code>race</code>,<code>all</code>,前者有任一一个解析完毕就返回,后者所有解析完毕返回…</p><blockquote><p>实现一个延时的 promise 函数, 可以用<code>async</code>和<code>await</code></p></blockquote><pre><code>const delay = (time)=&gt; new Promise((resolve,reject)=&gt;{  setTimeout(resolve,time)})// testlet testRun = async function(){   console.log(1);   await delay(2000);   console.log(&apos;我两秒后才触发&apos;,3)} // 1 =&gt; Promise = &gt; 3复制代码</code></pre><blockquote><p>这段代码的运行结果是什么?</p></blockquote><pre><code>var test = new Promise((resolve,reject)=&gt;{   resolve();});test  .then(data =&gt; {    // promise start    console.log(&apos;promise first then : &apos;, data);    return Promise.resolve(1); // p1  })  .then(data =&gt; {    // promise p1    console.log(&apos;get parent(p1) resolve data : &apos;, data);    return Promise.reject(new Error(&apos;哎呀,中断了,你能奈我何!&apos;)); // p2  })  .then(data =&gt; {    // promise p2    console.log(&apos;result of p2: &apos;, data);    return Promise.resolve(3); // p3  })  .catch(err =&gt; {    console.log(&apos;err: &apos;, err);    return false;  });// promise first then :  undefined// get parent(p1) resolve data :  1// err:  Error: 哎呀,中断了,你能奈我何!// 这里在 then 返回 Promise.reject()的时候已经中断了链式调用.直接给 catch捕获到复制代码</code></pre><blockquote><p>别急,假如你不管有没有捕获到错误,最后再执行一个回调函数如何实现?</p></blockquote><p>这里说的就是类似<code>try..catch..finally</code>,给<code>Promise</code>实现一个 finally;</p><pre><code>// finally比较好加，按照现在社区的讨论，finally的特点如下： // url : https://www.v2ex.com/t/205715  //1. 不接收任何参数，原来的value或者Error在finally里是收不到的 //2. 处理后不影响原Promise的状态，该reject还是reject，该resolve还是resolve //3. 不影响Promise向后传递的传，resolve状态还是传递原来的value，reject状态还是传递原来的Error Promise.prototype.finally = function (callback) {  let P = this.constructor; // 这里拿到的是 Promise 的构造函数  //不管前面的 Promise 是fulfilled还是rejected，都会执行回调函数callback。  return this.then(    value  =&gt; P.resolve(callback()).then(() =&gt; value),    reason =&gt; P.resolve(callback()).then(() =&gt; { throw reason })  );};// 用法很简单,就是可以传入一个回调函数..// https://developers.google.com/web/updates/2017/10/promise-finally// 这个 url 中说了 node 及 chrome 的哪些版本已经实现了 finally 及用法// ES 2018已经把 finally 追加到 promise 的原型链中..复制代码</code></pre><ul><li><a href="https://link.juejin.im?target=https%3A%2F%2Fjuejin.im%2Fpost%2F5a04066351882517c416715d" target="_blank" rel="noopener">&lt;<promise 必知必会（十道题)="">&gt;</promise></a>: 有助于你更加深刻的了解 promise 的运行情况</li><li><a href="https://link.juejin.im?target=https%3A%2F%2Fjuejin.im%2Fpost%2F5a9600526fb9a06333155141" target="_blank" rel="noopener">关于 Promise 的 9 个提示</a></li><li>更多的Promise 详情可以参考<a href="https://link.juejin.im?target=http%3A%2F%2Fliubin.org%2Fpromises-book%2F" target="_blank" rel="noopener">&lt;<javascript promise迷你书（中文版）="">&gt;</javascript></a>;</li></ul><hr><h3 id="Q-谈谈你对-TCP-的理解"><a href="#Q-谈谈你对-TCP-的理解" class="headerlink" title="Q: 谈谈你对 TCP 的理解;"></a>Q: 谈谈你对 TCP 的理解;</h3><blockquote><p>Q: TCP 是在哪个OSI 的哪个层!通讯过程是全双工还是半双工(单工)?</p><p>A: 传输层,全双工</p><p>Q: TCP的通讯的过程是怎么样的!</p><p>A: 整个过程是三次握手,四次挥手..</p><p>Q: 你说的没错,说说整个过程如何?</p><p>A: 举个栗子,我把 TCP 比做两个人用对讲机沟通(大白话)..三次握手就是.A1(吼叫方,客户端)想要呼叫 A2(控制室的某某,服务端)..</p><p>A1对着对讲机说”over over ,听到请回答”(第一次,请求应答) …</p><p>A2收到回应”收到收到,你说”(第二次,确认应答)</p><p>A1开始巴拉巴拉个不停而 A2没拒绝(第三次,通讯建立)</p><hr><p>而四次挥手则是两者确认互相倾述完毕的过程..</p><p>A1说:”控制室,报告完毕了”(第一次挥手)</p><p>A2说:”知道了…那么你废话说完就好好听我指挥….巴拉巴拉..”(第二次挥手)</p><p>A1此时等待控制室说完毕,而控制室等回应(第三次挥手)</p><p>等到 A1回馈控制室确认都知道完毕了..(第四次挥手)…</p></blockquote><p><strong>以上都是瞎掰,可能有些地方描述不当,笑笑就好了</strong></p><p><code>TCP</code>没有百分百建立成功的,会造成链接失败的情况有很多..</p><p>比如长时间没应答(A1吼了半天没有反应或者 A2应答了而 A1不再鸟它)..亦或者丢包(对讲机也没了);</p><p><code>TCP</code> 协议相关的文章网上很多,若是要更加全面的了解该协议请自行引擎..</p><p>我建议阅读&lt;&lt;<strong>TCP-IP详解卷1~卷3</strong>&gt;&gt;,这个是网络圣经…很厚…我只看了一丢丢..</p><hr><h3 id="Q-TCP-你了解了-那么-OSI-七层协议和五层网络架构应该知道吧"><a href="#Q-TCP-你了解了-那么-OSI-七层协议和五层网络架构应该知道吧" class="headerlink" title="Q: TCP 你了解了,那么 OSI 七层协议和五层网络架构应该知道吧?"></a>Q: TCP 你了解了,那么 OSI 七层协议和五层网络架构应该知道吧?</h3><p>对于这类的问题我也只能大体点了下,毕竟不是专攻网络这块的…</p><p><code>OSI</code> 七层涵盖:物理层,数据链路层,网络层,传输层,会话层,表示层,应用层;</p><p>五层模型就是”会话,表示,应用层”同为一层;</p><p>Q: <code>DNS</code> 的大体的执行流程了解么,属于哪个层级?工作在哪个层级?</p><p><code>DNS</code> 属于应用层协议, 至于<code>TCP/UDP</code>哪一层上面跑,看情况 , 大体的执行流程是这样的; <strong>DNS 默认端口是53,走 UDP</strong></p><ol><li>优先读取浏览器缓存</li><li>其次系统的缓存</li><li>都没有的情况下,找本地<code>hosts</code>文件(比如你写了映射关系优先寻找)</li><li>再没有的情况找最近的域名解析服务器</li><li>再没有则扩大访问,最终找到根服务器,还是没有就失败了..</li></ol><p>DNS 的解析的几个记录类型需要了解:</p><ul><li><code>A</code>: 域名直接到 IP</li><li><code>CNAME</code>: 可以多个域名映射到一个主机,类似在 <code>Github Page</code>就用 <code>CNAME</code> 指向</li><li><code>MX</code>: 邮件交换记录,用的不多,一般搭建邮件服务器才会用到</li><li><code>NS</code>: 解析服务记录,可以设置权重,指定谁解析</li><li><code>TTL</code>: 就是生存时间(也叫缓存时间),一般的域名解析商都有默认值,也可以人为设置</li><li><code>TXT</code>: 一般指某个主机名或域名的说明</li></ul><p>回来我找下相关的资料,有兴趣的可以深入了解下,传送门如下:</p><ul><li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.cnblogs.com%2Fkevingrace%2Fp%2F5909719.html" target="_blank" rel="noopener">梳理Linux下OSI七层网络与TCP/IP五层网络架构</a></li><li><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.html5rocks.com%2Fzh%2Ftutorials%2Ffile%2Fxhr2%2F" target="_blank" rel="noopener">TCP/IP（六）应用层（DNS和HTTP协议）</a></li><li><a href="https://link.juejin.im?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F28305778" target="_blank" rel="noopener">DNS域名解析解剖</a></li></ul><hr><h3 id="Q-HTTP-和-HTTPS-有何差异-听说过-SPDY-么"><a href="#Q-HTTP-和-HTTPS-有何差异-听说过-SPDY-么" class="headerlink" title="Q: HTTP 和 HTTPS 有何差异? 听说过 SPDY 么?"></a>Q: HTTP 和 HTTPS 有何差异? 听说过 SPDY 么?</h3><p>我只是粗浅的回答了下…</p><p><code>HTTP</code>相对于 <code>HTTPS</code>来说,速度较快且开销较小(没有 SSL/TSL) 对接,默认是80端口;</p><p><code>HTTP</code>容易遭受域名劫持,而<code>HTTPS</code>相对来说就较为安全但开销较大(数据以加密的形式传递),默认端口为443..</p><p><code>HTTP</code>是明文跑在 <code>TCP</code> 上.而<code>HTTPS</code>跑在<code>SSL/TLS</code>应用层之下,<code>TCP</code>上的</p><p>Q: 那么 <code>HTTPS</code>中的<code>TLS/SSL</code>是如何保护数据的…</p><p>一般有两种形式,非对称加密,生成公钥和私钥,私钥丢服务器,公钥每次请求去比对验证;</p><p>更严谨的采用 CA(Certificate Authority),给密钥签名….</p><p>Q: 你说到对称加密和非对称加密,能说说整个流程如何运转的么(HTTPS)</p><ul><li>对称加密:<ul><li>双方都有同样的密钥,每次通讯都要生成一个唯一密钥,速度很快</li><li>安全性较低且密钥增长的数量极快</li></ul></li><li>非对称加密(一般用 RSA)<ul><li>安全性很高,对资源消耗很大(CPU),目前主流的加密算法(基本用于交换密钥或签名,而非所有通讯内容)</li></ul></li><li>CA(数字签名):<ul><li>这个是为了防止中间人给偷换了造成数据被窃取而诞生的</li><li>用一些权威机构颁布的算法来签名,权威机构做中间人,通讯过程都会跟机构核对一遍</li></ul></li></ul><blockquote><p>懂得真心不多,回来找了下相关资料,有兴趣可以点击看看;</p></blockquote><ul><li><a href="https://link.juejin.im?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F22142170" target="_blank" rel="noopener">深入揭秘HTTPS安全问题&amp;连接建立全过程</a></li><li><a href="https://link.juejin.im?target=https%3A%2F%2Fklionsec.github.io%2F2017%2F07%2F31%2Fhttps-learn%2F" target="_blank" rel="noopener">深入理解 https 通信加密过程:口语化</a> “ : 看了上面那篇文章来看下面,会清晰很多</li></ul><p>Q: <code>SPDY</code> 听说过么.什么来的?</p><p>谷歌推行一种协议(<code>HTTP</code> 之下SSL之上[TCP]),可以算是HTTP2的前身,有这么些优点</p><ul><li>压缩数据(HEADER)</li><li>多路复用</li><li>优先级(可以给请求设置优先级)</li></ul><p>而这些优点基本 HTTP2也继承下来了..</p><p>Q: 你对 HTTP 的状态吗了解多少…</p><p>这里列举一丢丢常见的..</p><ul><li>1XX: 一般用来判断协议更换或者确认服务端收到请求这些<ul><li>100: 服务端收到部分请求,若是没有拒绝的情况下可以继续传递后续内容</li><li>101: 客户端请求变换协议,服务端收到确认</li></ul></li><li>2xx: 请求成功,是否创建链接,请求是否接受,是否有内容这些<ul><li>200: (成功)服务器已成功处理了请求。</li><li>201: (已创建)请求成功并且服务器创建了新的资源。</li><li>202: (已接受)服务器已接受请求，但尚未处理。</li><li>204: (无内容)服务器成功处理了请求，但没有返回任何内容。</li></ul></li><li>3XX: 一般用来判断重定向和缓存<ul><li>301: 所有请求已经转移到新的 url(永久重定向),会被缓存</li><li>302: 临时重定向,不会被缓存</li><li>304: 本地资源暂未改动,优先使用本地的(根据<code>If-Modified-Since or If-Match</code>去比对服务器的资源,缓存)</li></ul></li><li>4XX: 一般用来确认授权信息,请求是否出错,页面是否丢失<ul><li>400: 请求出错</li><li>401: 未授权,不能读取某些资源</li><li>403: 阻止访问,一般也是权限问题</li><li>404: 页面丢失,资源没找到</li><li>408: 请求超时</li><li>415: 媒介类型不被支持，服务器不会接受请求。</li></ul></li><li>5XX: 基本都是服务端的错误<ul><li>500: 服务端错误</li><li>502: 网关错误</li><li>504: 网关超时</li></ul></li></ul><hr><p>Q: HTTP的请求报文是怎么样的,能大体的说下么?</p><p>HTTP 的请求报文 = 请求行 + 请求头 + 请求体;</p><ul><li>请求行: 这个好理解就是访问的方法+ 协议+ 访问的 URL 构成</li><li>请求头: 这个也好理解,比如 <code>accept</code>,<code>content-type</code>,<code>user-agent</code>这类值键对,服务端可以直接读取的</li><li>请求体: 比如 POST 提交的一个表单,我们编码后放在上面需要传递的</li></ul><p>想深入了解的具体引擎搜索</p><p>Q: 请求报文知道,那你说说<code>cookie</code>是如何跟随请求的?</p><p>Cookie 就是保存在 HTTP 协议的请求或者应答头部(Cookie 是由服务端生成),这样一路漂泊…</p><p>Q: Cookie 隔离是什么,如何做;</p><blockquote><p>cookie 隔离就是降低 <code>header</code> 的数据包含,以达到加快访问速度的目的</p></blockquote><p>方案: 静态资源丢 CDN或者非主域来加载</p><hr><h3 id="Q-浏览器缓存和服务端的缓存控制你了解多少-说说看"><a href="#Q-浏览器缓存和服务端的缓存控制你了解多少-说说看" class="headerlink" title="Q: 浏览器缓存和服务端的缓存控制你了解多少,说说看?"></a>Q: 浏览器缓存和服务端的缓存控制你了解多少,说说看?</h3><ul><li><code>Last-Modified</code>:<ul><li>第一次请求资源从服务器拉取的会自动带上该属性</li><li>第二次请求会跟服务端比对<code>If-Modified-Since</code>的时间,没变动则使用本地的(状态304)</li><li>结合<code>Expires(过期时间:缓存的载止时间)</code>,跟随请求一起发出..资源没过期拿本地,否则重新请求</li></ul></li><li><code>Cache-control</code> 是 <code>HTTP1.1</code>的东西,判断资源过期结合<code>max-age</code>来替代<code>Expires[http 1.0]</code></li><li><code>Etag</code>:<ul><li>第一次请求url 时候会给服务器上标记(一串字符串)</li><li>第二次请求时候会比对服务端的<code>If-None-Match</code>,没有改动依旧拿缓存(304)</li></ul></li></ul><hr><h3 id="Q-几个短而让我印象深刻的题"><a href="#Q-几个短而让我印象深刻的题" class="headerlink" title="Q: 几个短而让我印象深刻的题"></a>Q: 几个短而让我印象深刻的题</h3><pre><code>if(!(&quot;a&quot; in window)){    var a = 10;}console.log(a); // undefined// !(&quot;a&quot; i n window)  , 返回 true// 留言小伙伴的刨析,非常感谢,还是涉及变量提升的问题/* var a;if(!(&quot;a&quot; in window)){    a = 10;}*/// 变种题(function(){ var  x = c =  b = {a:1}})()console.log(x.a); // error , x is not definedconsole.log(c,b) // {a: 1} {a: 1}复制代码var count = 0;console.log(typeof count === &quot;number&quot;); // true , 这个不用解释了console.log(!!typeof count === &quot;number&quot;); // false// 这里涉及到就是优先级和布尔值的问题// typeof count 就是字符串&quot;number&quot;// !!是转为布尔值(三目运算符的变种),非空字符串布尔值为 true// 最后才=== 比较 , true === &quot;number&quot; , return false复制代码(function(){  var a = b = 3;})()console.log(typeof a === &quot;undefined&quot;); // falseconsole.log(typeof b === &quot;undefined&quot;); // false// 这里涉及的就是立即执行和闭包的问题,还有变量提升,运算符执行方向(=号自左向右)// 那个函数可以拆成这样(function()  var a; /* 局部变量,外部没法访问*/  b = 3; /* 全局变量,so . window.b === 3 , 外部可以访问到*/  a = b;})()// 若是改成这样,这道题应该是对的console.log(typeof b === &quot;number&quot; &amp;&amp; b ===3); // true复制代码function foo(something){  this.a = something;}var obj1 = {  foo:foo};var obj2 = {};obj1.foo(2)console.log(obj1.a) // 2 ,此时的 this 上下文还在 obj1内,若是 obj1.foo 先保存当做引用再执行传参,则上下文为 windowobj1.foo.call(obj2,3); // 用 call 强行改变上下文为 obj2内console.log(obj2.a); // 3var  bar = new obj1.foo(4); // 这里产生了一个实例console.log(obj1.a); // 2console.log(bar.a); // 4;  new的绑定比隐式和显式绑定优先级更高复制代码function fn(){ alert(a); var a = 200; alert(a);}fn(); // undefined / 200 ; 涉及变量提升alert(a); // undefinedvar a;alert(a); // undefinedvar a = 300;alert(a); // 300复制代码var obj1= {  name:&apos;obj1&apos;,  fn:function(){    console.log(this.name);  }};var obj2 = {name:&apos;obj2&apos;};var obj3 = {name:&apos;obj3&apos;};// 这道题主要涉及的是 this 指向的问题..obj1.fn(); // obj1var newFn = obj1.fn;newFn(); // undefined, this 指向 windownewFn.call(obj2);// obj2, this 指向 obj2obj3.fn = newFn;/*ƒ (){    console.log(this.name);  }*/obj3.fn(); // 这里指向的是 obj3 .所以输出 obj3复制代码// 这道题来作为笔试题很绕,因为要回答的答案很多(脑海构思)..反正我是遇到了..// 这道题主要考核的是对原型链继承这块的理解function Parent(){  this.a = 1;  this.b = [1,2,this.a];  this.c = {demo:5};  this.show = function(){   console.log(this.a + &apos;&apos; + this.c.demo + &apos;:&apos; + this.b)  }}function Child(){  this.a  = 2;  this.change = function(){    this.b.push(this.a);    this.a = this.b.length;    this.c.demo = this.a++;  }}Child.prototype = new Parent();var parent = new Parent();var child1 = new Child();var child2 = new Child();child1.a = 11;child2.a = 12;// 这前面几个还算简单,继续看下去parent.show(); // 15:1,2,1// 因为 Child 自身没有 show 的方法,所以往原型链的上游找;// 找到父类的,this 因为没更改,所以输出结果如下child1.show(); // 115:1,2,1child2.show(); // 125:1,2,1child1.change();  // 改变一些数据,没有输出child2.change();  // +1parent.show(); // 15:1,2,1child1.show(); // 55:1,2,1,11,12child2.show(); // 65:1,2,1,11,12复制代码// 这道题也很绕,函数递归调用的function test(a,b){  console.log(b);  return {    test:function(c){       return test(c,a);    }};// 这道题的理解,拆成这样就好理解了/*function test(a,b){  console.log(&quot;a:&quot;+a,&quot;b:&quot;+b);  return {    test:function(c){       console.log(&quot;a:&quot;+a,&quot;b:&quot;+b,&quot;c&quot;+c);       return test(c,a);    }  }}*/var a = test(100); // undefined, 这个是不言而喻的;a.test(200); //  100;a.test(300); // 100;var b =  test(101).test(201).test(301); // undefined/101/201var c =  test(102).test(202); // undefined / 102c.test(302); // 202复制代码</code></pre><hr><h3 id="Q-有字符串-var-test-’abc345efgabcab’-请根据提示实现对应要求"><a href="#Q-有字符串-var-test-’abc345efgabcab’-请根据提示实现对应要求" class="headerlink" title="Q:有字符串 var test=’abc345efgabcab’; 请根据提示实现对应要求"></a>Q:有字符串 var test=’abc345efgabcab’; 请根据提示实现对应要求</h3><ul><li>去掉字符串中的 a,b,c 字符 ,形成结果’345efg’;</li></ul><pre><code>test.replace(/[abc]/g,&apos;&apos;); // &quot;345efg&quot;复制代码</code></pre><ul><li>将字符串的数字用括号括起来, 形成结果: abc[3][4][5]efg….’</li></ul><pre><code>test.replace(/\d/g,&apos;[$&amp;]&apos;);  // &quot;abc[3][4][5]efgabcab&quot;// 若是有分组则按照$1, $2, $3的形式进行引用，而 $&amp; 则表示的是整个正则表达式匹配的内容。复制代码</code></pre><ul><li>将字符串中的每个数字的值分别乘以2,输出:’abc6810….’</li></ul><pre><code>var temp = test.split(&apos;&apos;).map(function(item){  return /^\d$/.test(item) ? item * 2 : item;}).join(&apos;&apos;);// &quot;abc6810efgabcab&quot;复制代码</code></pre><hr><h3 id="Q-使用不少于三种方式替换文本-quot-dream-quot-改成-quot-package-quot-提供字符串-quot-I-have-a-dream-quot"><a href="#Q-使用不少于三种方式替换文本-quot-dream-quot-改成-quot-package-quot-提供字符串-quot-I-have-a-dream-quot" class="headerlink" title="Q: 使用不少于三种方式替换文本&quot;dream&quot;改成&quot;package&quot;,提供字符串&quot;I have a dream&quot;;"></a>Q: 使用不少于三种方式替换文本<code>&quot;dream&quot;</code>改成<code>&quot;package&quot;</code>,提供字符串<code>&quot;I have a dream&quot;</code>;</h3><ul><li><p>正则替换</p><p>// 这是最简单的代码量了..<br>var str = “I have a dream”;<br>str.replace(/dream/g,”package”);</p><p>// 不用正则也可以直接字符串替换<br>str.replace(“dream”,”package”)</p><p>复制代码</p></li><li><p>数组遍历更改</p><p>// 很直白的大脑回路<br>var str = “I have a dream”;</p><p>str.split(“ “).map(function(item){<br> return  item === “dream” ? item = “package”:item;<br>}).join(“ “);</p><p>复制代码</p></li><li><p>数组查询切割法</p><p>var str = “I have a dream”;</p><p>var tempArr = str.split(“ “); // [“I”, “have”, “a”, “dream”]<br>var removeIndex = tempArr.indexOf(‘dream’); // 3</p><p>tempArr.splice(removeIndex,1,”package”);</p><p>var transStr = tempArr.join(“ “); // “I have a package”;</p><p>复制代码</p></li></ul><p><strong>这类东东弄成数组还是挺好弄的</strong></p><p>这个是留言区小伙伴提供的方法..大同小异,如下;</p><pre><code>// 源代码// 字符串也有数组的 slice 以及 concat 的方法..思路和数组差不多var str = &apos;I haved a dream&apos;;str.indexOf(&apos;dream&apos;) !== -1 ? str.slice(0,str.indexOf(&apos;dream&apos;)).concat(&apos;package&apos;):str;复制代码</code></pre><hr><h3 id="Q-还有一道题目是涉及事件循环-执行优先权的"><a href="#Q-还有一道题目是涉及事件循环-执行优先权的" class="headerlink" title="Q: 还有一道题目是涉及事件循环,执行优先权的.."></a>Q: 还有一道题目是涉及事件循环,执行优先权的..</h3><p>就是 <code>macrotask</code>和<code>microtask</code> 相关的, 具体记不起来了..那时候给了答案虽然对了.</p><p>要说出所以然,给秀了一脸..回来找了下相关的资料;</p><ul><li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.ruanyifeng.com%2Fblog%2F2014%2F10%2Fevent-loop.html" target="_blank" rel="noopener">JavaScript 运行机制详解：再谈Event Loop</a></li><li><a href="https://link.juejin.im?target=https%3A%2F%2Fjuejin.im%2Fpost%2F5a2e21486fb9a0450407d370" target="_blank" rel="noopener">深入理解事件循环和异步流程控制</a></li><li><a href="https://link.juejin.im?target=https%3A%2F%2Fjuejin.im%2Fpost%2F5984816a518825265674c8f6" target="_blank" rel="noopener">所有你需要知道的关于完全理解 Node.js 事件循环及其度量</a></li></ul><hr><h3 id="Q-你对基础算法这块掌握的如何…"><a href="#Q-你对基础算法这块掌握的如何…" class="headerlink" title="Q: 你对基础算法这块掌握的如何…."></a>Q: 你对基础算法这块掌握的如何….</h3><blockquote><p>来,这纸给你,写个快排试试…</p></blockquote><pre><code>// 快排的大体思路是这样的,// 找个中位值,从原数组切割出来,// 剩下的作为两个数组,每次都去比较;// 直到递归的结果出来, 平均复杂度O(nlog n)function quickSort(arr) {  //如果数组长度&lt;=1,则直接返回  if (arr.length &lt;= 1) {    return arr;  }  // 中间位(基准)取长度的一半向下取整  var pivotIndex = Math.floor(arr.length / 2);  //把中间位从原数组切割出来, splice 会改变原数组!!!!  var pivot = arr.splice(pivotIndex, 1)[0];  //定义两个空数组来存放比对后的值  var left = [];  var right = [];  //比基准小的放在left，比基准大的放在right  for (var i = 0 , j = arr.length; i &lt; j; i++) {    if (arr[i] &lt;= pivot) {      left.push(arr[i]);    } else {      right.push(arr[i]);    }  }  //递归下去  arr = [ left , pivot , right]  // 怎么个递归法,就是比对后的数组还是会重复之前的取基准再切开比较..直到最后没有可以切了  return quickSort(left).concat([pivot], quickSort(right));}复制代码</code></pre><p>Q: 写一个二分法查找</p><pre><code>// 二分法跟快排的思路差不多,对半比较// 这个只用于排序好数组内的查询,高低位都知道的情况下function binSearch(target, arr, start, end) {  var start = start || 0; // 允许从什么位置开始,下标  var end = end || arr.length - 1; // 什么位置结束,下标  start &gt;= end ? -1 : &apos;&apos;; // 没有找到,直接返回-1  var mid = Math.floor((start + end) / 2); // 中位下标  if (target == arr[mid]) {    return mid; // 找到直接返回下标  } else if (target &gt; arr[mid]) {    //目标值若是大于中位值,则下标往前走一位    return binSearch(target, arr, start, mid - 1);  } else {    //若是目标值小于中位值,则下标往后退一位    return binSearch(target, arr, mid + 1, end);  }}// binSearch(5,[1,2,3,4,5,6,7,8]) =&gt; 4// 无序的数组则需要先排序好数组,否则会堆栈溢出(死循环)复制代码</code></pre><p>这类的文章很多,有兴趣的可以阅读下面的一些文章</p><p>传送门:</p><ul><li><a href="https://link.juejin.im?target=https%3A%2F%2Fjuejin.im%2Fpost%2F57dcd394a22b9d00610c5ec8" target="_blank" rel="noopener">&lt;&lt;十大经典排序算法总结（JavaScript描述&gt;&gt;</a></li><li><a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fzoro-web%2Fblog%2Fissues%2F4" target="_blank" rel="noopener">JavaScript数据结构和算法</a></li><li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.cnblogs.com%2Fxianyulaodi%2Fp%2F6001122.html" target="_blank" rel="noopener">javascript 常见排序算法</a></li></ul><hr><h3 id="Q-设计模式你了解多少"><a href="#Q-设计模式你了解多少" class="headerlink" title="Q: 设计模式你了解多少?"></a>Q: 设计模式你了解多少?</h3><ul><li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.cnblogs.com%2Ftugenhua0707%2Fp%2F5198407.html" target="_blank" rel="noopener">Javascript常用的设计模式详解</a></li><li><a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2FToNiQian%2Fjs-design-pattern" target="_blank" rel="noopener">js-design-pattern</a></li></ul><hr><h3 id="Q-思维拓展题-你有两个玻璃球-有个100米的高楼-求玻璃球在哪个楼层扔下会碎-用的次数最少"><a href="#Q-思维拓展题-你有两个玻璃球-有个100米的高楼-求玻璃球在哪个楼层扔下会碎-用的次数最少" class="headerlink" title="Q: 思维拓展题: 你有两个玻璃球,有个100米的高楼,求玻璃球在哪个楼层扔下会碎(用的次数最少);"></a>Q: 思维拓展题: 你有两个玻璃球,有个100米的高楼,求玻璃球在哪个楼层扔下会碎(用的次数最少);</h3><p>问题的要点: 玻璃球碎(有限个数) ,确定楼层数 , 最少次数 => 就是求最优的公式</p><p>在这道题上给秀的一脸,我的第一次的思路</p><blockquote><p>先折半,就变成[1-50][51-100], 那就是 1+50 = 51次 …</p></blockquote><p>面试大佬说,你用了快排的思路就肯定不是最优的..</p><blockquote><p>憋了许久,想到开平方 <img src="https://juejin.im/equation?tex=%5Csqrt%5B2%5D%7B100%7D" alt="\sqrt[2]{100}"> , 这样的话,最多只要20次</p></blockquote><p>然后又说给我三个球,在1000米的高楼,判断多少次…但是根据我上面的话,</p><blockquote><p>开立方, <img src="https://juejin.im/equation?tex=%5Csqrt%5B3%5D%7B1000%7D" alt="\sqrt[3]{1000}"> , 那最多不超过30次;</p></blockquote><p>至于第一次丢球的位置如何确定, 就是开平之后的值作为一个区间.</p><p>若 N 个球和 M 米的大厦…第一次丢球的高度区间就是这个了<img src="https://juejin.im/equation?tex=%5Cfrac%7Bm%7D%7B%5Csqrt%5Bn%5D%7Bm%7D%7D" alt="\frac{m}{\sqrt[n]{m}}"></p><p>面试大佬说这个还可以…那就暂且告一段落</p><p>…回来用万能的搜索引擎找了下..最优方案+最少次数需要考虑的东西很多,没那么简单</p><p>传送门: <a href="https://link.juejin.im?target=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F31855632" target="_blank" rel="noopener">知乎有人讨论了这个问题</a>;</p><p>但是高数还老师了..这种帖子看的一脸懵逼….抽空再好好研究下</p><hr><h3 id="Q-你对优化这块了解多少"><a href="#Q-你对优化这块了解多少" class="headerlink" title="Q: 你对优化这块了解多少?"></a>Q: 你对优化这块了解多少?</h3><p>大体常见的手段了解.</p><p>比如从客户端着手的:</p><ul><li>压缩代码(JS/CSS),压缩图片</li><li>合并一些小图片(<code>css sprite</code>)</li><li>若是打包的代码尽可能切割成多个 <code>chunk</code>,减少单一 <code>chunk</code>过大</li><li>静态文件采用 cdn 引入</li><li>HTTP的缓存头使用的合理</li><li>减小第三方库的依赖</li><li>对于代码应该考虑性能来编写,比如使用<code>requestAnimationFrame</code>绘制动画,尽可能减少页面重绘(DOM 改变)</li><li>渐进升级,引入<code>preload</code>这些预加载资源</li><li>看情况用<code>service worker</code>来缓存资源(比如移动端打算搞 PWA)</li></ul><p>比如从服务端着手:</p><ul><li>带宽,域名解析, 多域名解析等</li><li>页面做服务端渲染,减小对浏览器的依赖(不用客户端解析)</li><li>渐进升级,比如引入 HTTP2(多路复用,头部压缩这些可以明显加快加载速度)</li></ul><p>当然,这是这些都是很片面的点到…实际工作中去开展要复杂的多;</p><p>比如我们要多个维度去考虑的话,要去优化 DOM 的绘制时间,资源的加载时间,域名解析这些;</p><p>要全面的优化一个项目是一个大工程…</p><hr><h3 id="Q-MySQL有哪些索引类型-索引的数据结构储存方式-MySQL和-MongoDB的差异"><a href="#Q-MySQL有哪些索引类型-索引的数据结构储存方式-MySQL和-MongoDB的差异" class="headerlink" title="Q: MySQL有哪些索引类型? 索引的数据结构储存方式? MySQL和 MongoDB的差异"></a>Q: MySQL有哪些索引类型? 索引的数据结构储存方式? MySQL和 MongoDB的差异</h3><p>MySQL索引类型:</p><ul><li>普通索引: 就普通的类型</li><li>唯一索引: 代表索引的值唯一不重复(允许有空值),相对于上面多了个<code>UNIQUE</code></li><li>主键索引:(创建表的跟随创建,唯一索引，不允许有空值)</li><li>组合索引(就是将多个字段都建立到一个索引)</li></ul><p>索引有利有弊,用的好加快查询速度,滥用索引会造成大量磁盘空间占用,维护性也会增多; 索引不会包含<code>null</code>的列;</p><p>索引的数据结构储存方式,我只简单了解过<code>B-Tree</code></p><p>至于MySQL 和 MongoDB的差异;</p><p>前者是关系型数据库, 后者非关系型数据库(数据是以文档的方式储存,值为 <code>key-value</code>);</p><p><code>MySQL</code>应用层面很广,有事务系统这些,链表查询这些都很方便.经常作为很多系统的主力数据库</p><p>而<code>MongoDB</code>作为<code>NoSQL</code>,虽然有些层面不如 <code>MySQL</code>,但是应用层面也挺广, 比如结合前端做一些用户的概要信息的维护,一些缓存信息的维护.</p><blockquote><p>em….后端了解不多,也能点到即止….大学的时候学过一些..都差不多还给老师….</p></blockquote><hr><h3 id="Q-JS时间分段"><a href="#Q-JS时间分段" class="headerlink" title="Q: JS时间分段"></a>Q: JS时间分段</h3><blockquote><p>给定一个时间段和步长，枚举该时间段内步长的划分</p><p>例如：时间段<code>3:00-5:00</code>，步长为<code>20</code>分钟</p><p>那么返回的数组为</p><p><code>[&#39;3:00-3:20&#39;, &#39;3:20-3:40&#39;....]</code>等</p></blockquote><p>这类问题,一般都要先梳理好思路再来写;</p><ul><li>给定字符串时间段,切割,转换为分钟</li><li>跨日及跨时问题</li></ul><pre><code>// 这个东东我的小伙伴也写出来了.我的是在它的解答方式上加以注释和对参数的判断做了考虑// 他的解法方案在他的 github 上 https://github.com/lyh2668/blog/issues/1 , by lyh2668// 方便一些小伙伴的理解,以下代码包含ES6的姿势(参数默认值,剪头函数)let inputDateRange = (date, step = 30, separator = &apos;-&apos;) =&gt; {  let startTime, endTime; // 开始时间和结束时间  if (Object.prototype.toString.call(date) === &apos;[object String]&apos;) {    date = date.trim(); // 去除两边的空格    var tempDate = &apos;&apos;;    if (separator) {      tempDate = date.split(separator);    } else {      if (date.indexOf(&apos;-&apos;) !== -1) {        tempDate = date.split(&apos;-&apos;);      } else if (date.indexOf(&apos;~&apos;)) {        tempDate = date.split(&apos;~&apos;);      } else {        console.log(&apos;您传入的也许不是一个时间段!!!&apos;);      }    }    startTime = time2min(tempDate[0]); // 传入的开始时间    endTime = time2min(tempDate[1]); //传入的结束时间  } else if (Object.prototype.toString.call(date) === &apos;[object Array]&apos;) {    if (date.length === 2) {      startTime = time2min(date[0]); // 传入的开始时间      endTime = time2min(date[1]); //传入的结束时间    }  } else {    console.log(&apos;您传入的也许不是一个时间段!!!&apos;);  }  // 传入的 step 是否为数字,否则截图数字部分转化  // 为什么和 NaN 比较(自身不等性),若是传入的连正则都没法识别,那只能给默认值了  Object.prototype.toString.call(step) === &apos;[object Number]&apos;    ? (step = parseInt(step, 10))    : parseInt(step.replace(/[W\s\b]/g, &apos;&apos;), 10) === NaN      ? (step = parseInt(step.replace(/[W\s\b]/g, &apos;&apos;), 10))      : (step = 30);  // 若是开始时间大于结束时间则结束时间往后追加一天  startTime &gt; endTime ? (endTime += 24 * 60) : &apos;&apos;;  let transformDate = []; // 储存转换后的数组,时间分段  // 开始遍历判断,用 while  while (startTime &lt; endTime) {    // 如果开始时间+步长大于结束时间,则这个分段结束,否则结束时间是步长递增    let right = startTime + step &gt; endTime ? endTime : startTime + step;    transformDate.push(`${min2time(startTime)}-${min2time(right)}`);    startTime += step; // 步长递增  }  return transformDate;};// 时间转化为分钟let time2min = time =&gt; {  // 获取切割的  time.indexOf(&apos;:&apos;) ? (time = time.trim().split(&apos;:&apos;)) : &apos;&apos;;  return time[0] * 60 + parseInt(time[1]); // 返回转化的分钟};// 分钟转会字符串时间let min2time = minutes =&gt; {  let hour = parseInt(minutes / 60); // 返回多少小时  let minute = minutes - hour * 60; // 扣除小时后剩余的分钟数  hour &gt;= 24 ? (hour = hour - 24) : &apos;&apos;; // 若是大于等于24小时需要扣除一天得到所剩下的小时  minute &lt; 10 ? (minute = &apos;0&apos; + minute) : &apos;&apos;; // 小于10的都要补零  hour &lt; 10 ? (hour = &apos;0&apos; + hour) : &apos;&apos;; // 小于10的都要补零  return `${hour}:${minute}`;};// test ,支持字符串传入时间段inputDateRange(&apos;3:00-5:00&apos;,&apos;20d&apos;); // [&quot;03:00-03:20&quot;, &quot;03:20-03:40&quot;, &quot;03:40-04:00&quot;, &quot;04:00-04:20&quot;, &quot;04:20-04:40&quot;, &quot;04:40-05:00&quot;]// 亦或者数组传入inputDateRange([&apos;3:00&apos;,&apos;5:00&apos;],&apos;45df.3d&apos;); // [&quot;03:00-03:45&quot;, &quot;03:45-04:30&quot;, &quot;04:30-05:00&quot;]// step 支持数字亦或者带特殊字符的数字inputDateRange([&apos;6:00&apos;,&apos;8:00&apos;],&apos;55df.3d&apos;); // [&quot;06:00-06:55&quot;, &quot;06:55-07:50&quot;, &quot;07:50-08:00&quot;]inputDateRange(&apos;3:00-5:00&apos;,60); // [&quot;03:00-04:00&quot;, &quot;04:00-05:00&quot;]复制代码</code></pre><ul><li><a href="https://link.juejin.im?target=https%3A%2F%2Fjuejin.im%2Fpost%2F598c32dcf265da3e3d12557d" target="_blank" rel="noopener">JS不靠谱系列之枚举出时间段和对应的分钟数</a></li></ul><hr><h3 id="Q-Vue-Router的两种模式主要依赖什么实现的"><a href="#Q-Vue-Router的两种模式主要依赖什么实现的" class="headerlink" title="Q: Vue-Router的两种模式主要依赖什么实现的"></a>Q: <code>Vue-Router</code>的两种模式主要依赖什么实现的</h3><ul><li><code>hash</code>主要依赖<code>location.hash</code>来改动 URL,达到不刷新跳转的效果.每次 <code>hash</code> 改变都会触发<code>hashchange</code>事件(来响应路由的变化,比如页面的更换)</li><li><code>history</code>主要利用了 <code>HTML5</code>的 <code>history</code>API 来实现,用<code>pushState</code>和<code>replaceState</code>来操作浏览历史记录栈</li></ul><hr><h3 id="Q-MVVM-和-MVC-的差异-听说过-MVP"><a href="#Q-MVVM-和-MVC-的差异-听说过-MVP" class="headerlink" title="Q: MVVM 和 MVC 的差异? 听说过 MVP?"></a>Q: MVVM 和 MVC 的差异? 听说过 MVP?</h3><p>这类的文章好多,三个开发模式的诞生都有前后,不是同时出现的.</p><p>传送门:</p><ul><li><a href="https://link.juejin.im?target=http%3A%2F%2Fwww.ruanyifeng.com%2Fblog%2F2015%2F02%2Fmvcmvp_mvvm.html" target="_blank" rel="noopener">MVC，MVP 和 MVVM 的图示</a></li><li><a href="https://link.juejin.im?target=https%3A%2F%2Fjuejin.im%2Fpost%2F593021272f301e0058273468" target="_blank" rel="noopener">浅析前端开发中的 MVC/MVP/MVVM 模式</a></li></ul><hr><h3 id="Q-求100-999的所有”水仙花”数-就是三位数中各数字的立方和等于自身-比如153-1-3-5-3-3-3"><a href="#Q-求100-999的所有”水仙花”数-就是三位数中各数字的立方和等于自身-比如153-1-3-5-3-3-3" class="headerlink" title="Q: 求100~999的所有”水仙花”数, 就是三位数中各数字的立方和等于自身,比如153=1^3+5^3+3^3"></a>Q: 求100~999的所有”水仙花”数, 就是三位数中各数字的立方和等于自身,比如<code>153=1^3+5^3+3^3</code></h3><ul><li><p>常规遍历法</p><p>function threeWaterFlower(rangeStart, rangeEnd) {<br>  var temp = [];<br>  rangeStart = rangeStart || 100;<br>  rangeEnd = rangeEnd || 999;<br>  for (var i = rangeStart; i &lt;= rangeEnd; i++) {</p><pre><code>var t = i.toString().split(&apos;&apos;);Math.pow(t[0], 3) + Math.pow(t[1], 3) + Math.pow(t[2], 3) == i  ? temp.push(i)  : &apos;&apos;;</code></pre><p>  }<br>  return temp;<br>}</p></li></ul><pre><code>threeWaterFlower(100,999); // [153, 370, 371, 407]threeWaterFlower(); // [153, 370, 371, 407]复制代码</code></pre><ul><li>拓展写法,ES6版+不定花数,不折腾不舒服版本</li></ul><pre><code>let manyWaterFlower = (rangeStart = 100, rangeEnd = 999, flower = 3) =&gt; {  let temp = [];  for (let i = rangeStart; i &lt;= rangeEnd; i++) {    let t = i    .toString()    .split(&apos;&apos;)    .map(item =&gt; Math.pow(item, flower))    .reduce((cur,next)=&gt; parseInt(cur)+parseInt(next));    let transformT = parseInt(t, 10);    transformT == i ? temp.push(i) : &apos;&apos;;  }  return temp;}manyWaterFlower(); // [153, 370, 371, 407]manyWaterFlower(100,10000,4); // [1634, 8208, 9474]manyWaterFlower(100,10000,5); // [4150, 4151]复制代码</code></pre><p>这种是穷举遍历,若是要快一点呢(考虑的周全一点呢),以及传参范围的矫正</p><p>相信小伙伴都看得懂,我已经尽量注释了..</p><pre><code>let manyWaterFlower = (flower = 3,rangeStart, rangeEnd ) =&gt; {  let temp = [];// 缓存所有找到的花值  // 这一段就是填充开始循环的范围,处理完毕后转为数字,推荐的开始值  let flowerRecommandStart = Number(    &apos;&apos;.padStart(flower, &apos;0&apos;).replace(/^(\d{1})/g, &apos;1&apos;)  );  let flowerRecommandEnd = Number(&apos;&apos;.padStart(flower, &apos;9&apos;));  // 判断是否传入开始值  if (rangeStart) {    rangeStart &gt; flowerRecommandStart      ? (rangeStart = flowerRecommandStart)      : rangeStart;  } else {    rangeStart = flowerRecommandStart;  }  // 判断是否有传入结束值  if (rangeEnd) {    rangeEnd &gt; flowerRecommandEnd ? (rangeEnd = flowerRecommandEnd) : rangeEnd;  } else {    rangeEnd = flowerRecommandEnd;  }  // 若是初始值大于结束值  if (rangeStart &gt; rangeEnd) {    rangeEnd = flowerRecommandEnd;  }  for (let i = rangeStart; i &lt;= rangeEnd; i++) {    let t = i      .toString()      .split(&apos;&apos;)      .map(item =&gt; Math.pow(item, flower))      .reduce((cur, next) =&gt; parseInt(cur) + parseInt(next));    let transformT = parseInt(t, 10);    transformT == i ? temp.push(i) : &apos;&apos;;  }  return temp;};console.time(&apos;manyWaterFlower&apos;);manyWaterFlower(4)console.timeEnd(&apos;manyWaterFlower&apos;);// VM34013:4 manyWaterFlower: 8.112060546875ms ,这个是跑出来的时间用上个例子的代码,从100到9999的,我们跑一下看看console.time(&apos;manyWaterFlower&apos;);manyWaterFlower(100,9999,4)console.timeEnd(&apos;manyWaterFlower&apos;);// VM3135:4 manyWaterFlower: 10.51904296875ms// 我的 MBP 跑10花直接卡死...跑7花有点久...console.time(&apos;7 flower&apos;)manyWaterFlower(7);console.timeEnd(&apos;7 flower&apos;)// 7 flower: 6489.608154296875ms// 8 花 CPU 的风扇狂叫....console.time(&apos;8 flower&apos;)manyWaterFlower(8);console.timeEnd(&apos;8 flower&apos;)// VM644:3 8 flower: 68010.26489257812ms// 对了我们还没有考虑数值溢出的问题..因为正整数在 JS 的范围是有限的.// 有兴趣的小伙伴可以自行完善复制代码</code></pre><hr><h3 id="Q-请使用递归算法在-TODO-注释后实现通过节点-key-数组寻找-json-对象中的对应值"><a href="#Q-请使用递归算法在-TODO-注释后实现通过节点-key-数组寻找-json-对象中的对应值" class="headerlink" title="Q: 请使用递归算法在 TODO 注释后实现通过节点 key 数组寻找 json 对象中的对应值"></a>Q: 请使用递归算法在 TODO 注释后实现通过节点 key 数组寻找 json 对象中的对应值</h3><p>比如console.log(findNode([‘a1’, ‘b2’], data)) === data.a1.b2</p><pre><code>// 请使用递归算法在 TODO 注释后实现通过节点 key 数组寻找 json 对象中的对应值var data = {  a1: {    b1: 1,    b2: 2,    b3: {      b4: 5    }  },  a2: {    b1: 3,    b2: 4  }};function findNode(inPath, inData) {  // TODO  // 判断传入的是否是一个数组  if (Array.isArray(inPath)) {    // 当长度为1的时候寻找该 key 是否有值,有则返回,无则返回-1    if (inPath.length === 1) {      return inData[inPath[0]] ? inData[inPath[0]]: -1;    }else{     return findNode(inPath.slice(1), inData[inPath[0]]);    }  } else{    console.log(&apos;您传入的不是一个数组&apos;)  }}console.log(findNode([&apos;a1&apos;, &apos;b2&apos;], data)); // 2console.log(findNode([&apos;a1&apos;, &apos;b3&apos;,&apos;b4&apos;], data)); // 5复制代码</code></pre><ul><li>来个拓展版?支持字符串或数组传入;<code>findNode(&#39;a1.b2&#39;,data)</code>?</li></ul><pre><code>var data = {  a1: {    b1: 1,    b2: 2,    b3: {      b4: 5    }  },  a2: {    b1: 3,    b2: 4  }};// 判断格式function isType(params) {  let type = Object.prototype.toString.call(params);  if (type === &apos;[object String]&apos;) {    params = params.split(&apos;.&apos;);    return params;  }  if (type === &apos;[object Array]&apos;) {    return params;  }}function findNode(inPath, inData) {  inPath = isType(inPath);  // 判断传入的是否是一个数组  if (Array.isArray(inPath)) {    // 当长度为1的时候寻找该 key 是否有值,有则返回,无则返回-1    if (inPath.length === 1) {      return inData[inPath[0]] ? inData[inPath[0]]: -1;    }else{     return findNode(inPath.slice(1), inData[inPath[0]]);    }  } else {    console.log(&apos;您传入的不是一个数组&apos;);  }}console.log(findNode([&apos;a1&apos;, &apos;b2&apos;], data)); // 2console.log(findNode(&apos;a1.b3.b4&apos;, data)); // 5复制代码</code></pre><hr><h3 id="Q-webpack-是什么-webpack-常见的优化手段有哪些"><a href="#Q-webpack-是什么-webpack-常见的优化手段有哪些" class="headerlink" title="Q: webpack 是什么?webpack 常见的优化手段有哪些;"></a>Q: webpack 是什么?webpack 常见的优化手段有哪些;</h3><p>webpack 是一个资源处理工具,它的出现节省了我们的人力和时间; 可以对资源打包,解析,区分开发模式等等…</p><p>常见的优化手段:</p><ul><li>分离第三方库(依赖),比如引入<code>dll</code></li><li>引入多进程编译,比如<code>happypack</code></li><li>提取公共的依赖模块,比如<code>commonChunkPlugin</code></li><li>资源混淆和压缩:比如<code>UglifyJS</code></li><li>分离样式这些,减小<code>bundle chunk</code>的大小,比如<code>ExtractTextPlugin</code></li><li>GZIP 压缩,在打包的时候对资源对齐压缩,只要部署的服务器能解析即可..减少请求的大小</li><li>还有按需加载这些,一般主流的框架都有对应的模块懒加载方式.</li><li>至于<code>tree shaking</code>目前webpack3/4已经默认集成</li></ul><hr><h3 id="Q-从你输入一个-URL-到页面渲染的大体过程…"><a href="#Q-从你输入一个-URL-到页面渲染的大体过程…" class="headerlink" title="Q: 从你输入一个 URL 到页面渲染的大体过程…"></a>Q: 从你输入一个 URL 到页面渲染的大体过程…</h3><p>大体过程是这样的,想了解很细致的可以自行引擎;</p><ol><li>IP-&gt;DNS(浏览器=&gt;系统缓存=&gt;DNS 服务器)-&gt;域名解析完成(这一步不用太多解析吧)</li><li>TCP 协议走完-&gt;HTTP(S) 协议-&gt;缓存-&gt;(分析请求头)-&gt; 回馈报文</li><li>请求文档下来-&gt;DOM-&gt;CSSDOM-&gt;静态资源下载-&gt;render(绘制文档)-&gt;js 解析</li><li>用户看到页面</li></ol><hr><h3 id="Q-Vue-的组件的通讯手段有哪些"><a href="#Q-Vue-的组件的通讯手段有哪些" class="headerlink" title="Q: Vue 的组件的通讯手段有哪些.."></a>Q: Vue 的组件的通讯手段有哪些..</h3><ul><li>父-> 子: <code>props</code></li><li>子-> 父: <code>on</code>+<code>emit</code></li><li>父&lt;&gt;子: <code>on.sync</code>(语法糖)来的</li><li>兄弟 : <code>event bus</code> | <code>vuex</code></li></ul><h4 id="Q-Vuex你怎么理解"><a href="#Q-Vuex你怎么理解" class="headerlink" title="Q: Vuex你怎么理解?"></a>Q: <code>Vuex</code>你怎么理解?</h4><p><code>vuex</code>是一个状态管理容器(你也可以理解为全局变量),数据的流向是是单向数据流,</p><p>且数据并不具有持久化的特性(默认情况下刷新就重置所有状态);</p><p>里面的一些数据乃至方法,可以大致理解为 vue 的一些特性,比如</p><p>Vuex</p><p>Vue</p><p>state</p><p>data</p><p>getter</p><p>computed</p><p>mutation/actions</p><p>methods</p><p>至于单向数据流(全局单例模式)怎么理解</p><p><code>state</code>只能给<code>mutation(同步操作)</code> 改动, <code>action</code>只能反馈给<code>mutation</code>,可以进行异步操作(比如和后端交互拉取数据), <code>state</code>能触发 render,<code>action</code>能用<code>dispatch</code>分发..如图</p><p><img src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;701&quot; height=&quot;551&quot;&gt;&lt;/svg" alt=""></p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>还有一些题目记不起来了,就没辙了…还有一些题目是看你个人发挥的,没法写,比如</p><blockquote><ul><li>Q: 让你来为公司的一个项目做技术选型,你会怎么做,为什么?</li><li>Q: <code>React</code>,<code>Angular</code>,<code>Vue</code>的比较?</li><li>Q: 说说你对 <code>VNode</code>的理解,<code>diff</code>的过程;</li><li>Q: <code>Vue</code>的双向绑定如何实现,用了什么模式(订阅模式),大体如何实现的..</li><li>Q: <code>cmd</code>/<code>amd</code>/<code>commonjs</code>的差异</li><li>Q: 小程序以及<code>React Native</code>的差异..等等</li></ul></blockquote><p>面试的过程中磕磕碰碰才能发现自身的很多不足和需要去努力的方向.</p><p>有不对之处请留言,会及时跟进修正,谢谢各位大佬</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h1 id=&quot;2018春招前端面试-闯关记-精排精校&quot;&gt;&lt;a href=&quot;#2018春招前端面试-闯关记-精排精校&quot; class=&quot;headerlink&quot; title=&quot;2018春招前端面试: 闯关记(精排精校)&quot;&gt;&lt;/a&gt;2018春招前端面试: 闯关记(精排精校)&lt;
      
    
    </summary>
    
      <category term="后端" scheme="https://motainzhang.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>当大多数人对Vue理解到炉火纯青的时候，是不是该思考一下怎么让vue页面骚气起来</title>
    <link href="https://motainzhang.com/2018/07/19/vue/"/>
    <id>https://motainzhang.com/2018/07/19/vue/</id>
    <published>2018-07-19T15:22:38.000Z</published>
    <updated>2019-10-18T03:34:00.262Z</updated>
    
    <content type="html"><![CDATA[<h1 id="当大多数人对Vue理解到炉火纯青的时候，是不是该思考一下怎么让vue页面骚气起来"><a href="#当大多数人对Vue理解到炉火纯青的时候，是不是该思考一下怎么让vue页面骚气起来" class="headerlink" title="当大多数人对Vue理解到炉火纯青的时候，是不是该思考一下怎么让vue页面骚气起来"></a>当大多数人对Vue理解到炉火纯青的时候，是不是该思考一下怎么让vue页面骚气起来</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p><a href="https://link.juejin.im?target=https%3A%2F%2Fhongqingcao.github.io%2Fvue-portal-webUI%2F%23%2F" target="_blank" rel="noopener"><img src="https://user-gold-cdn.xitu.io/2018/8/16/1654053a58ad4ddb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></a>  </p><h2 id="小菜0、页面布局之五彩斑斓的类似标签栏"><a href="#小菜0、页面布局之五彩斑斓的类似标签栏" class="headerlink" title="小菜0、页面布局之五彩斑斓的类似标签栏"></a>小菜0、页面布局之五彩斑斓的类似标签栏</h2><p>先来个效果热热身</p><p><strong>上菜：</strong></p><p><img src="https://user-gold-cdn.xitu.io/2018/8/14/1653752a1e7ed890?imageslim" alt="">  </p><p><strong>场景需求：</strong>最近设计湿丢来这样的页面设计，要求响应式。正常老铁们看到类似标签栏的设计，作为前端要切出来估计头皮一发麻，基本上实现的话要么简单粗暴上背景图，要么几个div，作为对代码有的洁癖的我就直接上<strong>v-for表单渲染</strong>，把中间这块封装了一个公用的容器组件wapper，于是乎下面代码来了（完整代码，见本文后github链接）</p><pre><code>&lt;template&gt;   &lt;div class=&quot;com-wapper&quot;&gt;    &lt;div class=&quot;wapper&quot;&gt;        &lt;div class=&quot;content-header&quot;&gt;            &lt;div class=&quot;list&quot; v-for=&quot;(item,index) in colorList&quot; :style=&quot;{ background: item }&quot;&gt;&lt;/div&gt;        &lt;/div&gt;        &lt;div class=&quot;content&quot;&gt;           &lt;slot&gt;&lt;/slot&gt;        &lt;/div&gt;       &lt;/div&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {  name: &apos;wapper&apos;,  data(){      return{          colorList: [&apos;#ea4035&apos;,&apos;#fbac46&apos;,&apos;#2eb472&apos;,&apos;#f7ec31&apos;,&apos;#1b72b4&apos;,&apos;#90268b&apos;]      }  }}&lt;/script&gt;复制代码</code></pre><p><strong>原理：</strong>v-for去遍历数组，把颜色加在背景上，样式部分就不贴代码了，原理就是css3的计算属性calc分成6等分，然后各种阴影、圆角之类的一上效果杠杠的。</p><p>[题外话：至于性能方面没有做过多的思考，<strong>v-for表单渲染与其他实现方式的性能对比，</strong>这里也不做过多讲，这样看起来代码是优雅的]</p><h2 id="小菜1、爱心点赞，七夕特别贡献"><a href="#小菜1、爱心点赞，七夕特别贡献" class="headerlink" title="小菜1、爱心点赞，七夕特别贡献"></a>小菜1、爱心点赞，七夕特别贡献</h2><p>点赞场景，七夕了给相爱的ta一个赞吧</p><p><strong>上菜：</strong></p><p><img src="https://user-gold-cdn.xitu.io/2018/8/15/1653ca6eeab674da?imageslim" alt="">  </p><p><strong>场景需求：</strong>七夕马上就要到了，开始估计又要虐狗了，根据喜欢程度可以进行多次点击，从因为人群中偶然的一个回眸，平常到like,到love,再到love+,在到平常（点击通过爱心颜色和文字提示表示亲密度），项目中也常常出现，比如评论点赞，图书推荐点赞等场景，这里我把爱心抽离出一个heart组件，上核心代码：</p><pre><code>&lt;template&gt;    &lt;a href=&quot;javascript:void(0)&quot;       @click=&quot;handleHeart()&quot;        :class=&quot;{         &apos;like&apos; : heart.level === 1,         &apos;love&apos; : heart.level === 2,         &apos;stalker&apos; : heart.level === 3        }&quot;        class=&quot;heart&quot;&gt;        &lt;i&gt;♥&lt;/i&gt;  &lt;/a&gt;&lt;/template&gt;复制代码 methods: {        handleHeart: function() {            var heart = this.heart;            var level = heart.level;            switch (level) {                case 0:                    heart.level = 1;                    break;                case 1:                    heart.level = 2;                    break;                case 2:                    heart.level = 3;                    break;                case 3:                    heart.level = 0;                    break;            }           // this.updateDB();   //写入数据库操作        },        updateDB() {        }    },    created() {        if (!this.existing) {            this.heart.level = 0;        } else {            this.heart.level = this.existing;        }    }复制代码</code></pre><p><strong>原理：</strong>点赞功能究竟是怎么实现的呢，其实我在前一篇文章<a href="https://link.juejin.im?target=https%3A%2F%2Fjuejin.im%2Fpost%2F5b6d0c5cf265da0f504a837f" target="_blank" rel="noopener">《从青铜到王者10个css3伪类使用技巧和运用，了解一哈》</a>已经提到了，其实就是用伪类实现鼠标经过提示，点击修改循环heart.level，切换class来修改提示（伪类透明度），和爱心颜色（完整代码，见本文后github链接）</p><p>[题外话：以上数据都是mock模拟，其实请求的是github里面的数据，github提供的api可以看到很多数据，感兴趣的同学可以拿取githubapi里自己的数据做一个关于自己的’大数据分析页面’，很赞哦]  </p><h2 id="小菜2、让新闻选项卡动起来"><a href="#小菜2、让新闻选项卡动起来" class="headerlink" title="小菜2、让新闻选项卡动起来"></a>小菜2、让新闻选项卡动起来</h2><p>新闻选项卡，门户网站出现概率贼高，告别枯燥无味翻动新闻选项卡，鼠标经过动起来</p><p><strong>上菜：</strong><img src="https://user-gold-cdn.xitu.io/2018/8/15/1653c6ac9575e2bf?imageslim" alt=""></p><p><strong>场景需求：</strong>选项卡标题鼠标经过，对应切换新闻内容列表。jq深度患者，通常看到类似滚动推动效果的效果，肯定在想操作DOM啊，so easy。还是那句话，代码强迫症，es6和vue相结合，让你尽可能告别DOM操作，下面贴上代码（完整代码，本文后github链接）</p><pre><code> &lt;div class=&quot;news-wrapper&quot; v-cloak&gt;      &lt;ul class=&quot;news-list&quot;&gt;      &lt;li v-for=&quot;(item,index) in list&quot; :class=&quot; {&apos;active&apos;:index===activeTab}&quot; @mouseenter=&quot;tebHover(index)&quot;&gt;&lt;a href=&quot;javascript://&quot;&gt;{{item.newstitle}}&lt;/a&gt;&lt;/li&gt;        &lt;/ul&gt;     &lt;div class=&quot;news-box&quot;&gt;        &lt;div class=&quot;news-listbox&quot; :style=&quot;{&apos;margin-left&apos;: marginleft+&apos;%&apos;}&quot;&gt;          &lt;ul v-for=&quot;(item,index) in list&quot;&gt;                 &lt;li class=&quot;clearFix&quot; v-for=&quot;(news, index) in item.datalist&quot; v-if=&quot;index &lt; 6&quot;&gt;                     &lt;a&gt;                         &lt;div class=&quot;news-date&quot;&gt;                              &lt;div class=&quot;date-day&quot;&gt;{{news.date.split("-")[2]}}&lt;/div&gt;                              &lt;div class=&quot;date-year&quot;&gt;{{news.date.split("-")[0]}}-{{news.date.split("-")[1]}}&lt;/div&gt;                          &lt;/div&gt;                          &lt;div class=&quot;main-news&quot;&gt;                               &lt;div class=&quot;newstxt-title&quot;&gt;{{news.title}}&lt;/div&gt;                                &lt;div class=&quot;news-text&quot;&gt;                                      {{news.content}}                                &lt;/div&gt;                            &lt;/div&gt;                            &lt;div class=&quot;time&quot;&gt;{{news.date}}&lt;/div&gt;                        &lt;/a&gt;                     &lt;/li&gt;                    &lt;li class=&quot;more&quot;  v-if=&quot;item.datalist.length &gt;= 6&quot;&gt;&lt;a&gt;更多&gt;&gt;&lt;/a&gt;&lt;/li&gt;               &lt;/ul&gt;         &lt;/div&gt;     &lt;/div&gt;&lt;/div&gt;复制代码  tebHover(index){        this.activeTab = index;        //计算margin-left的百分比        this.marginleft = -1*(this.activeTab)*100   }复制代码</code></pre><p><strong>原理：</strong>让新闻内容区news-listbox的宽度300%（因为有三个选项），超出部分隐藏，这边标题选项只需要鼠标经过的时候带上index，计算margin-left多少，配合css3动画，寥寥几行ES6就实现了以上效果！</p><p>[题外话：以上数据都是mock模拟，里面其实很多值得大家可以看的亮点，比如怎么样让新闻第一条数据是和其他li有区别，时间截取、li超出部分显示更多按钮，等等都可下载源码看看]</p><h2 id="小菜3、让新闻卡片图片点击放大"><a href="#小菜3、让新闻卡片图片点击放大" class="headerlink" title="小菜3、让新闻卡片图片点击放大"></a>小菜3、让新闻卡片图片点击放大</h2><p>新闻卡片，点击图片平滑过渡放大，关闭缩小</p><p><strong>上菜：</strong></p><p><img src="https://user-gold-cdn.xitu.io/2018/8/15/1653c8c731ecb343?imageslim" alt="">  </p><p><strong>场景需求</strong>：其实就是一个查看点击查看大图插件</p><pre><code>&lt;template&gt;    &lt;div class=&quot;image-dialog&quot;&gt;        &lt;button class=&quot;image-dialog-trigger&quot; type=&quot;button&quot; @click=&quot;showDialog&quot;&gt;&lt;img class=&quot;image-dialog-thumb&quot; ref=&quot;thumb&quot; :src=&quot;thumb&quot; /&gt;        &lt;/button&gt;        &lt;transition name=&quot;dialog&quot; @enter=&quot;enter&quot; @leave=&quot;leave&quot;&gt;            &lt;div class=&quot;image-dialog-background&quot; v-show=&quot;appearedDialog&quot; ref=&quot;dialog&quot;&gt;                &lt;button class=&quot;image-dialog-close&quot; type=&quot;button&quot; @click=&quot;hideDialog&quot; aria-label=&quot;Close&quot;&gt;&lt;/button&gt;                &lt;img class=&quot;image-dialog-animate&quot; ref=&quot;animate&quot; :class=&quot;{ loading: !loaded }&quot; :src=&quot;loaded ? full : thumb&quot; /&gt;                &lt;img class=&quot;image-dialog-full&quot; ref=&quot;full&quot; :src=&quot;appearedDialog &amp;amp;&amp;amp; full&quot; :width=&quot;fullWidth&quot; :height=&quot;fullHeight&quot;                @load=&quot;onLoadFull&quot; /&gt;            &lt;/div&gt;        &lt;/transition&gt;    &lt;/div&gt;&lt;/template&gt;复制代码</code></pre><p><strong>原理：</strong>通过transform:属性scale实现图片缩放，其中图片是两张图小大图切换，目前只是实现了功能，有待优化，所以不贴代码了（完整代码，本文后github链接）  </p><h2 id="小菜4、轮播图"><a href="#小菜4、轮播图" class="headerlink" title="小菜4、轮播图"></a>小菜4、轮播图</h2><p>轮播图，现在基于vue的开源的很多优秀的轮播图插件,比如vue-awesome-swiper，这个功能就不多讲， 这边的话我自己写的：1、支持浏览器任意放缩，兼容移动端，2、支持自动切换，鼠标经过停止切换，分页/任意页点击切换，左右切换，3、支持文字介绍（超过一行自动省略）</p><p><strong>上菜：</strong></p><p><img src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;498&quot; height=&quot;274&quot;&gt;&lt;/svg" alt="">  </p><p>值得一提的是：如果加载轮播图组件（其他组件有这种报错可能）在加载的过程中出现“Error in render: “TypeError: Cannot read property ‘url’ of undefined”</p><p><img src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1233&quot; height=&quot;533&quot;&gt;&lt;/svg" alt="">  </p><p>这是由于axios请求和组件渲染顺序的问题引起的，这时候，你只需要在axios请求到数据后，再去加载组件，这里我推荐用v-if，判断当数据的长度大于0，表示请求出来了数据，再去加载轮播组件，如此就不会报错了。</p><pre><code>&lt;div class=&quot;slider-wapper&quot;&gt;&lt;slider :slides=&quot;slides&quot; :inv=&quot;invTime&quot; v-if=&quot;slides.length &gt; 0&quot;&gt;&lt;/slider&gt;&lt;/div&gt;复制代码</code></pre><p>对应轮播组件，感兴趣的同学可以看我之前发的文章<a href="https://link.juejin.im?target=https%3A%2F%2Fjuejin.im%2Fpost%2F5afb87ec51882567105feae5" target="_blank" rel="noopener">《从开发到发布一款基于Vue2x的响应式自适应轮播组件插件VueSliderShow》</a></p><h2 id="小菜5、即时检索"><a href="#小菜5、即时检索" class="headerlink" title="小菜5、即时检索"></a>小菜5、即时检索</h2><p><strong>上菜：</strong>  </p><p><img src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;799&quot; height=&quot;474&quot;&gt;&lt;/svg" alt="">  </p><p><strong>场景需求</strong>：通过输入即时检索列表里面的内容，列表的检索过滤，直接上代码（完整代码，本文后github链接）  </p><pre><code> &lt;div class=&quot;search-box&quot;&gt;    &lt;div class=&quot;search-wrapper&quot;&gt;          &lt;input type=&quot;text&quot; v-model=&quot;keyword&quot; placeholder=&quot;Search title...&quot; /&gt;           &lt;label&gt;Search Title&lt;/label&gt;     &lt;/div&gt;     &lt;div class=&quot;wrapper&quot;&gt;         &lt;div class=&quot;card&quot; v-for=&quot;post in filteredList&quot;&gt;            &lt;a v-bind:href=&quot;post.link&quot; target=&quot;_blank&quot;&gt;                 &lt;img v-bind:src=&quot;post.img&quot; /&gt;                  &lt;small&gt;Posted by: {{ post.author }}&lt;/small&gt; {{ post.title }}            &lt;/a&gt;         &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;复制代码  methods:{    toggleOnOff() {            this.onOff = !this.onOff;        }  },  computed: {    filteredList() {        return this.postList.filter((post) =&gt; {            return post.title.toLowerCase().includes(this.keyword.toLowerCase());        });    }  }复制代码</code></pre><p><strong>原理：</strong>通过computed计算input框的内容，然后再展示内容  </p><h3 id="最后：（未完待续）"><a href="#最后：（未完待续）" class="headerlink" title="最后：（未完待续）"></a>最后：（未完待续）</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;当大多数人对Vue理解到炉火纯青的时候，是不是该思考一下怎么让vue页面骚气起来&quot;&gt;&lt;a href=&quot;#当大多数人对Vue理解到炉火纯青的时候，是不是该思考一下怎么让vue页面骚气起来&quot; class=&quot;headerlink&quot; title=&quot;当大多数人对Vue理解到
      
    
    </summary>
    
      <category term="前端" scheme="https://motainzhang.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>charles</title>
    <link href="https://motainzhang.com/2018/07/19/charles/"/>
    <id>https://motainzhang.com/2018/07/19/charles/</id>
    <published>2018-07-19T15:14:47.000Z</published>
    <updated>2019-10-18T03:34:00.262Z</updated>
    
    <content type="html"><![CDATA[<article data-v-13f76525="" itemscope="itemscope" itemtype="http://schema.org/Article" class="article" data-v-3f216172=""><meta itemprop="url" content="https://juejin.im/post/5b4f005ae51d45191c7e534a"><meta itemprop="headline" content="Charles抓包工具二三谈"><meta itemprop="keywords" content="Node.js,Java,百度,Charles"><meta itemprop="datePublished" content="2018-07-18T09:03:51.151Z"><meta itemprop="image" content="https://user-gold-cdn.xitu.io/2018/7/18/164aca09d3137b4e?w=900&amp;h=700&amp;f=png&amp;s=273867"><div itemprop="author" itemscope="itemscope" itemtype="http://schema.org/Person"><meta itemprop="name" content="杭城小刘"><meta itemprop="url" content="https://juejin.im/user/57c108b8a633bd005d67e4a6"></div><div itemprop="publisher" itemscope="itemscope" itemtype="http://schema.org/Organization"><meta itemprop="name" content="掘金"><div itemprop="logo" itemscope="itemscope" itemtype="https://schema.org/ImageObject"><meta itemprop="url" content="https://b-gold-cdn.xitu.io/icon/icon-white-180.png"><meta itemprop="width" content="180"><meta itemprop="height" content="180"></div></div><div data-v-13f76525="" class="author-info-block"><a href="/user/57c108b8a633bd005d67e4a6"><div data-v-b2db8566="" data-v-1b9df826="" data-v-13f76525="" data-src="https://user-gold-cdn.xitu.io/2018/6/13/163f9d3d25f8b421?imageView2/1/w/100/h/100/q/85/format/webp/interlace/1" class="lazy avatar avatar loaded" title="" style="background-image: url(&quot;https://user-gold-cdn.xitu.io/2018/6/13/163f9d3d25f8b421?imageView2/1/w/100/h/100/q/85/format/webp/interlace/1&quot;);"></div></a><div data-v-13f76525="" class="author-info-box"><a href="/user/57c108b8a633bd005d67e4a6">杭城小刘</a><div data-v-13f76525="" class="meta-box"><time data-v-13f76525="" datetime="2018-07-18T09:03:51.151Z" title="Wed Jul 18 2018 17:03:51 GMT+0800 (中国标准时间)" class="time">2018年07月18日</time><span data-v-13f76525="" class="views-count">阅读 1003</span><!----></div></div></div><div data-v-b2db8566="" data-v-009ea7bb="" data-v-13f76525="" data-src="https://user-gold-cdn.xitu.io/2018/7/18/164aca09d3137b4e?imageView2/1/w/1304/h/734/q/85/format/webp/interlace/1" class="lazy thumb article-hero loaded" style="background-image: url(&quot;https://user-gold-cdn.xitu.io/2018/7/18/164aca09d3137b4e?imageView2/1/w/1304/h/734/q/85/format/webp/interlace/1&quot;); background-size: cover;"></div><br><br># Charles抓包工具二三谈<br><div data-v-13f76525="" itemprop="articleBody" class="article-content"><br><br>### 一、 下载地址<br><br>Charles的下载地址：<a href="https://link.juejin.im?target=https%3A%2F%2Fpan.baidu.com%2Fs%2F1fkeKeIz1Yvz2HRFjk3P-0g" target="_blank" rel="noopener">charles</a><br>因为Charles只有30天的试用期，所以在这里给一个破解版的包：<a href="https://link.juejin.im?target=https%3A%2F%2Fpan.baidu.com%2Fs%2F1QqSiEwMGIFrxwyKYg_6Kdw" target="_blank" rel="noopener"><br>破解包</a><br><br>### 二、破解方法<br><br><em>   像正常安装应用一样，点击安装，之后将应用包拖到Application目录中。</em>   右击Charles.app，显示包内容，然后将第二个链接下载下来的破解包复制黏贴到此目录下替换。<br><br>### 三、使用教程<br><br><em>   Charles上的设置。<br><br>    在Charles的菜单栏上选择”Proxy” -&gt; “Proxy Settings”,填入代理端口8888，并且勾选”Enable transparent HTTP proxying”,就完成了Charles上的设置，如下图所示：<br><br>    <figure><img src="https://user-gold-cdn.xitu.io/2018/7/18/164ac9aa738ccd2a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="步骤1"><figcaption></figcaption></figure><br><figure><img src="https://user-gold-cdn.xitu.io/2018/7/18/164ac9a9bf3ea1ac?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="步骤2"><figcaption></figcaption></figure></em>   在电脑“系统偏好设置”中心打开网络查看本机ip地址，打开手机“设置”-&gt;“无线局域网”，进入选中的网络，HTTP代理选中“手动”。服务器处填写电脑ip地址，端口写8888。设置好后，我们打开iPhone上的任意需要网络通讯的程序，就可以看到Charles弹出请求的确认菜单，单击”Allow”按钮，即可完成设置。<br><figure><img src="https://user-gold-cdn.xitu.io/2018/7/18/164ac9a9b90f9dcc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="手机设置"><figcaption></figcaption></figure><br><br>### 四、使用 Charles mock 接口数据<br><br>发现有些时候我们需要对一个接口进行黑盒测试，我们可以通过 Charles 进行模拟，或者对某些 App 查看判断业务逻辑也可以用此方法。<br><br><em>   选中 Charles 的具体某个接口，右击选择 “Map Local”。<br><figure><img src="https://user-gold-cdn.xitu.io/2018/7/18/164ac9fb5d5c214f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""><figcaption></figcaption></figure></em>   在弹出的对话框中，点击红色圈出来的按钮，然后选择本地准备好的 JSON 文件<br><figure><img src="https://user-gold-cdn.xitu.io/2018/7/18/164ac9a9a68f71a8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""><figcaption></figcaption></figure><br>这2个步骤做完后就可以 mock 接口数据了，每次要做操作，只需要修改本地的 JSON 文件即可<br>当然，这是对于简单的调试，最好还是会写一些接口开发，比如 Node.js 、PHP、Java、Python等等<br><br>### 五、抓取 HTTPS 数据<br><br><em>   在电脑端 Charles 上菜单栏 Help -&gt; SSl Proxying -&gt; Install Charles Root Certificate<br><figure><img src="https://user-gold-cdn.xitu.io/2018/7/18/164ac9aa40822368?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""><figcaption></figcaption></figure></em>   在 keychain 处将新安装的证书设置为永久信任<br><figure><img src="https://user-gold-cdn.xitu.io/2018/7/18/164ac9aab5332151?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""><figcaption></figcaption></figure><br><em>   在 Charles 菜单栏 Proxy -&gt; SSL Proxying Setting -&gt; 点击 Add 按钮 -&gt; 在弹出的对对话框设置需要监听的 HTTPS 域（</em>:代表通配符）<br><figure><img src="https://user-gold-cdn.xitu.io/2018/7/18/164ac9aaad2c0ff8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""><figcaption></figcaption></figure><br><em>   在手机上链接好电脑对应的 ip 和端口</em>   在手机浏览器访问 Chls.pro/ssl 安装证书，并信任<br><figure><img src="https://user-gold-cdn.xitu.io/2018/7/18/164ac9a99ea05b2e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""><figcaption></figcaption></figure><br><em>   iPhone 打开设置 -&gt; 通用 -&gt; 关于本机 -&gt; 证书信任设置 -&gt; 开启开关<br><figure><img src="https://user-gold-cdn.xitu.io/2018/7/18/164ac9a9ca26c907?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""><figcaption></figcaption></figure><br>尽情玩乐吧<br><figure><img src="https://user-gold-cdn.xitu.io/2018/7/18/164ac9a9a966fafe?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="抓取京东HTTPS数据"><figcaption></figcaption></figure></em> <em> </em><br><br>看到下方评论说“手机如果有vpn的话，需要现将vpn关闭才能成功”。如果各位在手机开着 VPN 的情况下无法抓包，那么尝试关闭 VPN。（具体未尝试）<br><br></div></article>]]></content>
    
    <summary type="html">
    
      
      
        &lt;article data-v-13f76525=&quot;&quot; itemscope=&quot;itemscope&quot; itemtype=&quot;http://schema.org/Article&quot; class=&quot;article&quot; data-v-3f216172=&quot;&quot;&gt;&lt;meta itemprop=&quot;ur
      
    
    </summary>
    
      <category term="工具" scheme="https://motainzhang.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring MVC的Controller的几种常用返回类型（含请求转发、重定向）</title>
    <link href="https://motainzhang.com/2018/06/14/Spring-MVC%E7%9A%84Controller%E7%9A%84%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%EF%BC%88%E5%90%AB%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E3%80%81%E9%87%8D%E5%AE%9A%E5%90%91%EF%BC%89/"/>
    <id>https://motainzhang.com/2018/06/14/Spring-MVC的Controller的几种常用返回类型（含请求转发、重定向）/</id>
    <published>2018-06-14T23:35:50.000Z</published>
    <updated>2019-10-18T03:34:00.262Z</updated>
    
    <content type="html"><![CDATA[<h2 id="返回ModelAndView"><a href="#返回ModelAndView" class="headerlink" title="返回ModelAndView"></a>返回ModelAndView</h2><p>返回ModelAndView时最常见的一种返回结果。需要在方法结束的时候定义一个ModelAndView对象，并对Model和View分别进行设置。</p><h2 id="返回String"><a href="#返回String" class="headerlink" title="返回String"></a>返回String</h2><h3 id="字符串代表逻辑视图名"><a href="#字符串代表逻辑视图名" class="headerlink" title="字符串代表逻辑视图名"></a>字符串代表逻辑视图名</h3><p>真实的访问路径=“前缀”+逻辑视图名+“后缀”</p><p>注意：如果返回的String代表逻辑视图名的话，那么Model的返回方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public String testController(Model model)&#123;</span><br><span class="line">    model.addAttribute(attrName,attrValue);//相当于ModelAndView的addObject方法</span><br><span class="line">    return &quot;逻辑视图名&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="代表redirect重定向"><a href="#代表redirect重定向" class="headerlink" title="代表redirect重定向"></a>代表redirect重定向</h3><p>redirect的特点和servlet一样，使用redirect进行重定向那么地址栏中的URL会发生变化，同时不会携带上一次的request</p><p>案例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public String testController(Model model)&#123;</span><br><span class="line">    return &quot;redirect:path&quot;;//path代表重定向的地址</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="代表forward转发"><a href="#代表forward转发" class="headerlink" title="代表forward转发"></a>代表forward转发</h3><p>通过forward进行转发，地址栏中的URL不会发生改变，同时会将上一次的request携带到写一次请求中去</p><p>案例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public String testController(Model model)&#123;</span><br><span class="line">    return &quot;forward:path&quot;;//path代表转发的地址</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="返回void"><a href="#返回void" class="headerlink" title="返回void"></a>返回void</h2><p>返回这种结果的时候可以在Controller方法的形参中定义HTTPServletRequest和HTTPServletResponse对象进行请求的接收和响应</p><h3 id="使用request转发页面"><a href="#使用request转发页面" class="headerlink" title="使用request转发页面"></a>使用<code>request</code>转发页面</h3><p>  <code>request.getRequestDispatcher(&quot;转发路径&quot;).forward(request,response);</code></p><h3 id="使用response进行页面重定向"><a href="#使用response进行页面重定向" class="headerlink" title="使用response进行页面重定向"></a>使用<code>response</code>进行页面重定向</h3><p>  <code>response.sendRedirect(&quot;重定向路径&quot;);</code></p><h3 id="也可以使用response指定响应结果"><a href="#也可以使用response指定响应结果" class="headerlink" title="也可以使用response指定响应结果"></a>也可以使用<code>response</code>指定响应结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">response.setCharacterEncoding(&quot;UTF-8&quot;);</span><br><span class="line">response.setContentType(&quot;application/json;charset=utf-8&quot;);</span><br><span class="line">response.getWriter.write(&quot;json串&quot;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;返回ModelAndView&quot;&gt;&lt;a href=&quot;#返回ModelAndView&quot; class=&quot;headerlink&quot; title=&quot;返回ModelAndView&quot;&gt;&lt;/a&gt;返回ModelAndView&lt;/h2&gt;&lt;p&gt;返回ModelAndView时最常见的一种返
      
    
    </summary>
    
      <category term="Java Web" scheme="https://motainzhang.com/categories/Java-Web/"/>
    
      <category term="Spring MVC" scheme="https://motainzhang.com/categories/Java-Web/Spring-MVC/"/>
    
    
      <category term="Controller" scheme="https://motainzhang.com/tags/Controller/"/>
    
      <category term="返回类型， forward， redirect" scheme="https://motainzhang.com/tags/%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%EF%BC%8C-forward%EF%BC%8C-redirect/"/>
    
  </entry>
  
  <entry>
    <title>根据请求的具体扩展名、请求头不同，返回不同格式的相同内容</title>
    <link href="https://motainzhang.com/2018/06/14/%E6%A0%B9%E6%8D%AE%E8%AF%B7%E6%B1%82%E7%9A%84%E5%85%B7%E4%BD%93%E6%89%A9%E5%B1%95%E5%90%8D%E3%80%81%E8%AF%B7%E6%B1%82%E5%A4%B4%E4%B8%8D%E5%90%8C%EF%BC%8C%E8%BF%94%E5%9B%9E%E4%B8%8D%E5%90%8C%E6%A0%BC%E5%BC%8F%E7%9A%84%E7%9B%B8%E5%90%8C%E5%86%85%E5%AE%B9/"/>
    <id>https://motainzhang.com/2018/06/14/根据请求的具体扩展名、请求头不同，返回不同格式的相同内容/</id>
    <published>2018-06-14T22:48:32.000Z</published>
    <updated>2019-10-18T03:34:00.262Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内容协商多视图"><a href="#内容协商多视图" class="headerlink" title="内容协商多视图"></a>内容协商多视图</h2><p><a href="https://blog.csdn.net/yu412346928/article/details/20637439" target="_blank" rel="noopener">SpringMVC配置多视图-内容协商原理</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=&quot;org.springframework.web.servlet.view.ContentNegotiatingViewResolver&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;contentNegotiationManager&quot; ref=&quot;contentNegotiationManager&quot;/&gt;</span><br><span class="line">   ...</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p><a href="https://junq.io/spring-mvc%E5%AE%9E%E7%8E%B0http%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86-content-negotiation.html" target="_blank" rel="noopener">Spring MVC三种方式实现HTTP内容协商(Content Negotiation)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;内容协商多视图&quot;&gt;&lt;a href=&quot;#内容协商多视图&quot; class=&quot;headerlink&quot; title=&quot;内容协商多视图&quot;&gt;&lt;/a&gt;内容协商多视图&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/yu412346928/article
      
    
    </summary>
    
      <category term="Java Web" scheme="https://motainzhang.com/categories/Java-Web/"/>
    
      <category term="Spring MVC框架" scheme="https://motainzhang.com/categories/Java-Web/Spring-MVC%E6%A1%86%E6%9E%B6/"/>
    
      <category term="视图" scheme="https://motainzhang.com/categories/Java-Web/Spring-MVC%E6%A1%86%E6%9E%B6/%E8%A7%86%E5%9B%BE/"/>
    
    
      <category term="视图" scheme="https://motainzhang.com/tags/%E8%A7%86%E5%9B%BE/"/>
    
      <category term="ContentNegotiatingViewResolver" scheme="https://motainzhang.com/tags/ContentNegotiatingViewResolver/"/>
    
      <category term="contentNegotiationManager" scheme="https://motainzhang.com/tags/contentNegotiationManager/"/>
    
  </entry>
  
  <entry>
    <title>服务端返回JSON数据，实现客户端的无关性</title>
    <link href="https://motainzhang.com/2018/06/14/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%BF%94%E5%9B%9EJSON%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%AE%9E%E7%8E%B0%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E6%97%A0%E5%85%B3%E6%80%A7/"/>
    <id>https://motainzhang.com/2018/06/14/服务端返回JSON数据，实现客户端的无关性/</id>
    <published>2018-06-14T18:56:48.000Z</published>
    <updated>2019-10-18T03:34:00.262Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Java Web" scheme="https://motainzhang.com/categories/Java-Web/"/>
    
      <category term="Spring MVC框架，视图" scheme="https://motainzhang.com/categories/Java-Web/Spring-MVC%E6%A1%86%E6%9E%B6%EF%BC%8C%E8%A7%86%E5%9B%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>批量执行与SqlSessionTemplate</title>
    <link href="https://motainzhang.com/2018/06/14/%E6%89%B9%E9%87%8F%E6%89%A7%E8%A1%8C%E4%B8%8ESqlSessionTemplate/"/>
    <id>https://motainzhang.com/2018/06/14/批量执行与SqlSessionTemplate/</id>
    <published>2018-06-14T12:21:46.000Z</published>
    <updated>2019-10-18T03:34:00.262Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Java Web" scheme="https://motainzhang.com/categories/Java-Web/"/>
    
      <category term="测试" scheme="https://motainzhang.com/categories/Java-Web/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="SqlSession" scheme="https://motainzhang.com/tags/SqlSession/"/>
    
      <category term="批量操作" scheme="https://motainzhang.com/tags/%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>Spring test的测试操作</title>
    <link href="https://motainzhang.com/2018/06/14/Spring-test%E7%9A%84%E6%B5%8B%E8%AF%95%E6%93%8D%E4%BD%9C/"/>
    <id>https://motainzhang.com/2018/06/14/Spring-test的测试操作/</id>
    <published>2018-06-14T12:20:53.000Z</published>
    <updated>2019-10-18T03:34:00.262Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Java Web" scheme="https://motainzhang.com/categories/Java-Web/"/>
    
      <category term="测试" scheme="https://motainzhang.com/categories/Java-Web/%E6%B5%8B%E8%AF%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Mybatis逆向工程</title>
    <link href="https://motainzhang.com/2018/06/13/Mybatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    <id>https://motainzhang.com/2018/06/13/Mybatis逆向工程/</id>
    <published>2018-06-13T20:41:41.000Z</published>
    <updated>2019-10-18T03:34:00.262Z</updated>
    
    <content type="html"><![CDATA[<h2 id="所需依赖"><a href="#所需依赖" class="headerlink" title="所需依赖"></a>所需依赖</h2><p><code>mybatis-generator-core</code></p><h2 id="创建generator的配置xml文件"><a href="#创建generator的配置xml文件" class="headerlink" title="创建generator的配置xml文件"></a>创建generator的配置xml文件</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;所需依赖&quot;&gt;&lt;a href=&quot;#所需依赖&quot; class=&quot;headerlink&quot; title=&quot;所需依赖&quot;&gt;&lt;/a&gt;所需依赖&lt;/h2&gt;&lt;p&gt;&lt;code&gt;mybatis-generator-core&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;创建generator的配置
      
    
    </summary>
    
      <category term="Java Web" scheme="https://motainzhang.com/categories/Java-Web/"/>
    
      <category term="数据库连接" scheme="https://motainzhang.com/categories/Java-Web/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5/"/>
    
    
      <category term="Mybatis逆向工程" scheme="https://motainzhang.com/tags/Mybatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>MySQL的外键关联</title>
    <link href="https://motainzhang.com/2018/06/13/MySQL%E7%9A%84%E5%A4%96%E9%94%AE%E5%85%B3%E8%81%94/"/>
    <id>https://motainzhang.com/2018/06/13/MySQL的外键关联/</id>
    <published>2018-06-13T18:59:29.000Z</published>
    <updated>2019-10-18T03:34:00.262Z</updated>
    
    <content type="html"><![CDATA[<h2 id="外键的作用"><a href="#外键的作用" class="headerlink" title="外键的作用"></a>外键的作用</h2><ol><li><strong>保证数据的完整性和一致性</strong>，对业务处理有着很好的校验作用</li><li>增加<a href="">ER图</a>的可读性</li></ol><p>当删除 某个数据库表中的 某一行数据，如果其中某列有外键关联，会<strong>联动删除</strong>外键指向的 数据库表的相关行。更新也是如此。</p><h2 id="添加外键"><a href="#添加外键" class="headerlink" title="添加外键"></a>添加外键</h2><h3 id="命令行操作"><a href="#命令行操作" class="headerlink" title="命令行操作"></a>命令行操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE yourtablename</span><br><span class="line">    ADD [CONSTRAINT 外键名] FOREIGN KEY [id] (index_col_name, ...)</span><br><span class="line">    REFERENCES tbl_name (index_col_name, ...)</span><br><span class="line">    [ON DELETE &#123;CASCADE | SET NULL | NO ACTION | RESTRICT&#125;]</span><br><span class="line">    [ON UPDATE &#123;CASCADE | SET NULL | NO ACTION | RESTRICT&#125;]</span><br></pre></td></tr></table></figure><p>说明:<br><code>ON DELETE/ON UPDATE</code>用于定义delete,update操作.以下是update,delete操作的各种约束类型:</p><ul><li>CASCADE:<br>外键表中外键字段值会被更新,或所在的列会被删除.</li><li>RESTRICT:<br>RESTRICT也相当于no action,即不进行任何操作.即,拒绝父表update外键关联列,delete记录.</li><li>set null:<br>被父面的外键关联字段被update ,delete时,子表的外键列被设置为null.<br>而对于insert,子表的外键列输入的值,只能是父表外键关联列已有的值.否则出错.</li></ul><p>外键定义服从下列情况：(前提条件)</p><ol><li>所有tables必须是InnoDB型，它们不能是临时表.因为在MySQL中只有InnoDB类型的表才支持外键.</li><li>所有要建立外键的字段必须建立索引.</li><li>对于非InnoDB表，FOREIGN KEY子句会被忽略掉。</li></ol><p>注意:<br>创建外键时,定义外键名时,不能加引号.<br>如: constraint ‘fk_1’ 或 constraint “fk_1”是错误的</p><h3 id="MySQL-Workbench操作"><a href="#MySQL-Workbench操作" class="headerlink" title="MySQL Workbench操作"></a>MySQL Workbench操作</h3><p><img src="https://github.com/Hunter1023/blogSource/raw/master/source/image/MySQL%20Workbench%E8%AE%BE%E7%BD%AE%E5%A4%96%E9%94%AE.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;外键的作用&quot;&gt;&lt;a href=&quot;#外键的作用&quot; class=&quot;headerlink&quot; title=&quot;外键的作用&quot;&gt;&lt;/a&gt;外键的作用&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;保证数据的完整性和一致性&lt;/strong&gt;，对业务处理有着很好的校验作用&lt;/li&gt;
&lt;l
      
    
    </summary>
    
      <category term="MySQL" scheme="https://motainzhang.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://motainzhang.com/tags/MySQL/"/>
    
      <category term="Foreign Keys" scheme="https://motainzhang.com/tags/Foreign-Keys/"/>
    
  </entry>
  
  <entry>
    <title>mybatis的驼峰命名</title>
    <link href="https://motainzhang.com/2018/06/13/mybatis%E7%9A%84%E9%A9%BC%E5%B3%B0%E5%91%BD%E5%90%8D/"/>
    <id>https://motainzhang.com/2018/06/13/mybatis的驼峰命名/</id>
    <published>2018-06-13T18:43:55.000Z</published>
    <updated>2019-10-18T03:34:00.262Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mybatis-支持驼峰命名的属性"><a href="#Mybatis-支持驼峰命名的属性" class="headerlink" title="Mybatis 支持驼峰命名的属性"></a>Mybatis 支持驼峰命名的属性</h2><p><code>mapUnderscoreToCamelCase</code>：下划线与驼峰式命名规则的映射。<br>如：</p><ul><li><code>first_name =&gt; firstName</code></li><li><code>A_COLUMN =&gt; aColumn</code></li></ul><p>Mybatis默认不开启该命名规则的转换。</p><h2 id="启用驼峰命名"><a href="#启用驼峰命名" class="headerlink" title="启用驼峰命名"></a>启用驼峰命名</h2><p>spring配置： </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span>  </span><br><span class="line">          <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperLocations"</span> <span class="attr">value</span>=<span class="string">"classpath:sqlMapper/*"</span> /&gt;</span>  </span><br><span class="line">          <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span>  </span><br><span class="line">          <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:mybatis-config.xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">     <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>mybatis-config.xml：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span>  </span><br><span class="line">     <span class="tag">&lt;<span class="name">settings</span>&gt;</span>  </span><br><span class="line">          <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"mapUnderscoreToCamelCase"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span>  </span><br><span class="line">     <span class="tag">&lt;/<span class="name">settings</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Mybatis-支持驼峰命名的属性&quot;&gt;&lt;a href=&quot;#Mybatis-支持驼峰命名的属性&quot; class=&quot;headerlink&quot; title=&quot;Mybatis 支持驼峰命名的属性&quot;&gt;&lt;/a&gt;Mybatis 支持驼峰命名的属性&lt;/h2&gt;&lt;p&gt;&lt;code&gt;mapU
      
    
    </summary>
    
      <category term="Java Web" scheme="https://motainzhang.com/categories/Java-Web/"/>
    
      <category term="数据库连接" scheme="https://motainzhang.com/categories/Java-Web/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5/"/>
    
    
      <category term="Mybatis" scheme="https://motainzhang.com/tags/Mybatis/"/>
    
      <category term="驼峰命名" scheme="https://motainzhang.com/tags/%E9%A9%BC%E5%B3%B0%E5%91%BD%E5%90%8D/"/>
    
      <category term="spring" scheme="https://motainzhang.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>DOM</title>
    <link href="https://motainzhang.com/2018/06/12/DOM/"/>
    <id>https://motainzhang.com/2018/06/12/DOM/</id>
    <published>2018-06-12T11:20:05.000Z</published>
    <updated>2019-10-18T03:34:00.262Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="前端" scheme="https://motainzhang.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="JavaScript" scheme="https://motainzhang.com/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="https://motainzhang.com/tags/JavaScript/"/>
    
      <category term="DOM" scheme="https://motainzhang.com/tags/DOM/"/>
    
  </entry>
  
  <entry>
    <title>缓存数据</title>
    <link href="https://motainzhang.com/2018/05/22/%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE/"/>
    <id>https://motainzhang.com/2018/05/22/缓存数据/</id>
    <published>2018-05-22T15:07:54.000Z</published>
    <updated>2019-10-18T03:34:00.262Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缓存的作用"><a href="#缓存的作用" class="headerlink" title="缓存的作用"></a>缓存的作用</h2><p>缓存（Caching）可以存储经常会用到的信息，这样每次需要的时候，这些信息都是立即可用的。<br>尽管Spring自身没有实现缓存解决方案，但它对缓存功能提供了声明式的支持，能够与多种流行的缓存实现进行集成。</p><h2 id="启用对缓存的支持"><a href="#启用对缓存的支持" class="headerlink" title="启用对缓存的支持"></a>启用对缓存的支持</h2><p>Spring对缓存的支持有两种方式：</p><ul><li>注解驱动的缓存</li><li>XML声明的缓存</li></ul><p>使用Spring的缓存抽象时，最为通用的方式就是在方法上添加<code>@Cacheable</code>和<code>@CacheEvict</code>注解</p><h3 id="使用XML声明缓存"><a href="#使用XML声明缓存" class="headerlink" title="使用XML声明缓存"></a>使用XML声明缓存</h3><p>因为缓存是一种面向切面的行为，所以cache命名空间会与Spring的aop命名空间结合使用，用来声明缓存所应用的切点在哪里。</p><h2 id="Redis缓存机制"><a href="#Redis缓存机制" class="headerlink" title="Redis缓存机制"></a>Redis缓存机制</h2><p><img src="https://blog.csdn.net/lixiao1003/article/details/79011592" alt="为什么要用Redis"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;缓存的作用&quot;&gt;&lt;a href=&quot;#缓存的作用&quot; class=&quot;headerlink&quot; title=&quot;缓存的作用&quot;&gt;&lt;/a&gt;缓存的作用&lt;/h2&gt;&lt;p&gt;缓存（Caching）可以存储经常会用到的信息，这样每次需要的时候，这些信息都是立即可用的。&lt;br&gt;尽管Spring
      
    
    </summary>
    
      <category term="Java Web" scheme="https://motainzhang.com/categories/Java-Web/"/>
    
      <category term="缓存" scheme="https://motainzhang.com/categories/Java-Web/%E7%BC%93%E5%AD%98/"/>
    
    
      <category term="Spring" scheme="https://motainzhang.com/tags/Spring/"/>
    
      <category term="缓存" scheme="https://motainzhang.com/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="https://motainzhang.com/2018/05/21/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://motainzhang.com/2018/05/21/正则表达式/</id>
    <published>2018-05-21T14:31:54.000Z</published>
    <updated>2019-10-18T03:34:00.262Z</updated>
    
    <content type="html"><![CDATA[<h2 id="正则表达式字符描述"><a href="#正则表达式字符描述" class="headerlink" title="正则表达式字符描述"></a>正则表达式字符描述</h2><p><a href="http://deerchao.net/tutorials/regex/regex.htm#greedyandlazy" target="_blank" rel="noopener">正则表达式30分钟入门教程</a></p><table><thead><tr><th>字符</th><th>含义</th></tr></thead><tbody><tr><td><code>^</code></td><td>匹配输入的开始位置</td></tr><tr><td><code>\</code></td><td>将下一个字符标记为特殊字符或字面值</td></tr><tr><td><code>*</code> 或 <code>?</code></td><td>匹配前一个字符零次或几次</td></tr><tr><td><code>+</code></td><td>匹配前一个字符一次或多次</td></tr><tr><td><code>(pattern)</code></td><td>与模式匹配并记住匹配</td></tr><tr><td>x &#124; y</td><td>匹配 x 或 y</td></tr><tr><td><code>[a-z]</code></td><td>表示某个范围内的字符，与指定区间内的任何字符匹。</td></tr><tr><td><code>\w</code></td><td>与任何单词字符匹配，包括下划线</td></tr><tr><td><code>{n,m}</code></td><td>最少匹配 n 次且最多匹配 m 次</td></tr><tr><td><code>$</code></td><td>匹配输入的结尾</td></tr></tbody></table><h2 id="email的正则表达式"><a href="#email的正则表达式" class="headerlink" title="email的正则表达式"></a>email的正则表达式</h2><p>引用自<a href="http://www.cnblogs.com/vs-bug/archive/2010/03/26/1696752.html" target="_blank" rel="noopener">email正则表达式</a></p><blockquote><p>　　一般的email,形如<a href="mailto:zhangshan@163.com" target="_blank" rel="noopener">zhangshan@163.com</a>,<a href="mailto:abc@sina.com.cn" target="_blank" rel="noopener">abc@sina.com.cn</a>这样一些常用的形式就行了,但是在我们公司的一些客户中邮箱却有一些<a href="mailto:`zhangshna.Mr@163.com" target="_blank" rel="noopener">`zhangshna.Mr@163.com</a><code>、</code><a href="mailto:abc_Wang.dd@sian.com" target="_blank" rel="noopener">abc_Wang.dd@sian.com</a><code>、</code><a href="mailto:abc_Wang.dd.cc@sian.com" target="_blank" rel="noopener">abc_Wang.dd.cc@sian.com</a><code>这 种类似的形式。在</code>@<code>符号之前还有</code>.`,原来是拿来就用,可是现在就不行,得自己研究正则的用法了。</p></blockquote><p>原来的正则表达式<br>^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(.[a-zA-Z0-9_-]+)+$<br>根据实际情况修改后的正则表达式<br>^(\w)+(.\w+)<em>@(\w)+((.\w{2,3}){1,3})$<br>或者<br>^(\w)+(.\w+)</em>@(\w)+((.\w+)+)$</p><hr><p>一些常用的正则表达式:<br>1.验证用户名和密码：（”^[a-zA-Z]\w{5,15}$”）正确格式：”[A-Z][a-z]_[0-9]”组成,并且第一个字必须为字母6~16位；</p><p>2.验证电话号码：（”^(\d{3.4}-)\d{7,8}$”）正确格式：xxx/xxxx-xxxxxxx/xxxxxxxx；　　</p><p>3.验证身份证号（15位或18位数字）：（”^\d{15}|\d{18}$”）； 　　</p><p>4.验证Email地址：(“^\w+([-+.]\w+)<em>@\w+([-.]\w+)</em>.\w+([-.]\w+)*$”)；　　</p><p>5.只能输入由数字和26个英文字母组成的字符串：(“^[A-Za-z0-9]+$”) ; 　　</p><p>6.整数或者小数：^[0-9]+.{0,1}[0-9]{0,2}$ 　　</p><p>7.只能输入数字：”^[0-9]*$”。 　　</p><p>8.只能输入n位的数字：”^\d{n}$”。 　　</p><p>9.只能输入至少n位的数字：”^\d{n,}$”。 　　</p><p>10.只能输入m~n位的数字：。”^\d{m,n}$” 　　</p><p>11.只能输入零和非零开头的数字：”^(0|[1-9][0-9]*)$”。 　　</p><p>12.只能输入有两位小数的正实数：”^[0-9]+(.[0-9]{2})?$”。 　　</p><p>13.只能输入有1~3位小数的正实数：”^[0-9]+(.[0-9]{1,3})?$”。 　　</p><p>14.只能输入非零的正整数：”^+?[1-9][0-9]*$”。 　　</p><p>15.只能输入非零的负整数：”^-[1-9][]0-9”*$。 　　</p><p>16.只能输入长度为3的字符：”^.{3}$”。 　　</p><p>17.只能输入由26个英文字母组成的字符串：”^[A-Za-z]+$”。 　　</p><p>18.只能输入由26个大写英文字母组成的字符串：”^[A-Z]+$”。 　　</p><p>19.只能输入由26个小写英文字母组成的字符串：”^[a-z]+$”。 　　</p><p>20.验证是否含有^%&amp;’,;=?$\”等字符：”[^%&amp;’,;=?$\x22]+”。 　　</p><p>21.只能输入汉字：”^[\u4e00-\u9fa5]{0,}$” 　　</p><p>22.验证URL：”^http://([\w-]+.)+[\w-]+(/[\w-./?%&amp;=]*)?$”。　　</p><p>23.验证一年的12个月：”^(0?[1-9]|1[0-2])$”正确格式为：”01”～”09”和”1”～”12”。　　</p><p>24.验证一个月的31天：”^((0?[1-9])|((1|2)[0-9])|30|31)$”正确格式为；”01”～”09”和”1”～”31”。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;正则表达式字符描述&quot;&gt;&lt;a href=&quot;#正则表达式字符描述&quot; class=&quot;headerlink&quot; title=&quot;正则表达式字符描述&quot;&gt;&lt;/a&gt;正则表达式字符描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://deerchao.net/tutorials/reg
      
    
    </summary>
    
      <category term="正则表达式" scheme="https://motainzhang.com/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
    
      <category term="正则表达式" scheme="https://motainzhang.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="regexp" scheme="https://motainzhang.com/tags/regexp/"/>
    
  </entry>
  
  <entry>
    <title>将eclipse中web项目的默认发布路径改为本地Tomcat所在的webapp路径</title>
    <link href="https://motainzhang.com/2018/05/19/%E5%B0%86eclipse%E4%B8%ADweb%E9%A1%B9%E7%9B%AE%E7%9A%84%E9%BB%98%E8%AE%A4%E5%8F%91%E5%B8%83%E8%B7%AF%E5%BE%84%E6%94%B9%E4%B8%BA%E6%9C%AC%E5%9C%B0Tomcat%E6%89%80%E5%9C%A8%E7%9A%84webapp%E8%B7%AF%E5%BE%84/"/>
    <id>https://motainzhang.com/2018/05/19/将eclipse中web项目的默认发布路径改为本地Tomcat所在的webapp路径/</id>
    <published>2018-05-19T00:50:06.000Z</published>
    <updated>2019-10-18T03:34:00.262Z</updated>
    
    <content type="html"><![CDATA[<p><strong>在Eclipse中做的Web项目默认会发布到工作空间的某个目录</strong>，因此无法在外部启动Tomcat来运行Web项目，只有打开Eclipse中的服务器，才能运行Web项目。</p><h2 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h2><ol><li>在Eclipse中的最底下的Servers视图，将所有部署的项目移除</li><li>再双击这个tomcat server</li><li>在“Server Locations”处选择“Use Tomcat installation”，然后在Deploy的path处写上<code>本地tomcat路径/webapps</code>即可。</li></ol><p>参考：<a href="https://www.cnblogs.com/DreamDrive/p/5765645.html" target="_blank" rel="noopener">Eclipse中web项目的默认发布路径改为外部Tomcat中webapp路径</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;在Eclipse中做的Web项目默认会发布到工作空间的某个目录&lt;/strong&gt;，因此无法在外部启动Tomcat来运行Web项目，只有打开Eclipse中的服务器，才能运行Web项目。&lt;/p&gt;
&lt;h2 id=&quot;解决方式&quot;&gt;&lt;a href=&quot;#解决方式&quot; cl
      
    
    </summary>
    
      <category term="杀死exception" scheme="https://motainzhang.com/categories/%E6%9D%80%E6%AD%BBexception/"/>
    
    
      <category term="Tomcat" scheme="https://motainzhang.com/tags/Tomcat/"/>
    
      <category term="eclipse" scheme="https://motainzhang.com/tags/eclipse/"/>
    
  </entry>
  
  <entry>
    <title>解决Properties文件的中文内容乱码</title>
    <link href="https://motainzhang.com/2018/05/17/%E8%A7%A3%E5%86%B3Properties%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%AD%E6%96%87%E5%86%85%E5%AE%B9%E4%B9%B1%E7%A0%81/"/>
    <id>https://motainzhang.com/2018/05/17/解决Properties文件的中文内容乱码/</id>
    <published>2018-05-17T22:03:30.000Z</published>
    <updated>2019-10-18T03:34:00.262Z</updated>
    
    <content type="html"><![CDATA[<p>用IDEA进行开发，导航栏<code>File</code> -&gt; <code>Settings</code> -&gt; <code>Editor</code> -&gt; <code>File Encodings</code>，把看到Encoding的地方都选为UTF-8，并把<code>Transparent native-to-ascii conversion</code>（自动进行unicode转码，待学习）勾上，<code>ok</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;用IDEA进行开发，导航栏&lt;code&gt;File&lt;/code&gt; -&amp;gt; &lt;code&gt;Settings&lt;/code&gt; -&amp;gt; &lt;code&gt;Editor&lt;/code&gt; -&amp;gt; &lt;code&gt;File Encodings&lt;/code&gt;，把看到Encoding的地方都选为U
      
    
    </summary>
    
      <category term="杀死exception" scheme="https://motainzhang.com/categories/%E6%9D%80%E6%AD%BBexception/"/>
    
    
      <category term="中文乱码" scheme="https://motainzhang.com/tags/%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/"/>
    
      <category term=".properties" scheme="https://motainzhang.com/tags/properties/"/>
    
  </entry>
  
  <entry>
    <title>Spring MVC的简单总结</title>
    <link href="https://motainzhang.com/2018/05/14/Spring-MVC%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/"/>
    <id>https://motainzhang.com/2018/05/14/Spring-MVC的简单总结/</id>
    <published>2018-05-14T19:39:51.000Z</published>
    <updated>2019-10-18T03:34:00.262Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么需要Spring-MVC框架"><a href="#为什么需要Spring-MVC框架" class="headerlink" title="为什么需要Spring MVC框架"></a>为什么需要Spring MVC框架</h2><ul><li>需要一个框架来处理路由（映射）</li><li>需要一个框架来处理MVC(前端、后端、数据处理的分离)</li></ul><h2 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h2><p><strong>Spring MVC 是以一个servlet为核心来构建的——<code>DispatcherServlet</code></strong>。</p><p>DispatcherServlet处理请求与相应的示意图：<br><img src="https://github.com/Hunter1023/blogSource/raw/master/source/image/DispatcherServlet%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94%E7%9A%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt=""></p><p>工作流程：</p><ol><li>客户端发送请求到<code>DispatcherServlet</code></li><li><code>DispatcherServlet</code>查询一个或多个处理器映射（handler mapping）来确定发送给对应的<code>Controller</code></li><li>Controller处理发来的请求（设计良好的Controller本身只处理很少的工作，将业务逻辑委托给一个或多个service对象进行处理）</li><li>Controller进行逻辑处理得到的内容称为模型（model），Controller将模型数据打包，并标示出用于渲染输出的视图名，发还给<code>DispatcherServlet</code></li><li><code>DispatcherServlet</code>用<code>view resolver</code>将逻辑视图名匹配为一个特定的视图进行实现。</li></ol><h3 id="如何使用DispatcherServlet"><a href="#如何使用DispatcherServlet" class="headerlink" title="如何使用DispatcherServlet"></a>如何使用DispatcherServlet</h3><ol><li><p>添加相关依赖</p><ul><li><code>spring-webmvc</code></li><li><code>javax.servlet-api</code>(待确认是否需要)</li></ul></li><li><p>在<code>web.xml</code>文件中添加如下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>自定义名称<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:[servlet-name]-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>与上边定义的name相同<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/api/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>还需要创建一个<code>[servlet-name]-servlet.xml</code>文件，来定义该Servlet相关（MVC）的内容：</p></li></ol><ul><li>HandlerMapping(可以不定义，有默认配置)</li><li>Controllers(相对于在xml中定义，偏向用annotation来定义，然后开启自动发现机制)</li><li>View解析相关（也有默认配置，偏向进行显式的具体配置）</li></ul><h2 id="WebApplicationContext"><a href="#WebApplicationContext" class="headerlink" title="WebApplicationContext"></a>WebApplicationContext</h2><p>不同于<a href="/2018/05/12/IoC容器">IoC容器</a>一文中介绍的，在非Web场景下，需要通过<code>ClassPathXmlApplicationContext</code>或<code>FileSystemXmlApplicationContext</code>来定义IoC容器。SpringMVC框架下，会根据DispatcherServlet的配置，自动生成ApplicationContext。</p><h2 id="ContextLoaderListener"><a href="#ContextLoaderListener" class="headerlink" title="ContextLoaderListener"></a>ContextLoaderListener</h2><p><strong>我们希望<code>DispatcherServlet</code>加载包含Web组件的bean（如Controller、view resolver以及handler mapping）；<code>ContextLoaderListener</code>加载其他bean（驱动应用后端的中间层和数据层组件）</strong></p><p>在web.xml文件中添加如下内容：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>applicationContext配置文件的路径.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><code>applicationContext配置文件的路径.xml</code>用来定义DAO、Service相关的内容。</p><h2 id="启用Spring-MVC"><a href="#启用Spring-MVC" class="headerlink" title="启用Spring MVC"></a>启用Spring MVC</h2><p>Spring MVC相关配置文件中，添加如下内容：<br><code>&lt;mvc:annotation-driven /&gt;</code></p><h2 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h2><h3 id="定义Controller"><a href="#定义Controller" class="headerlink" title="定义Controller"></a>定义Controller</h3><ul><li>在上述的<code>[servlet-name]-servlet.xml</code>文件中，添加：<br><code>&lt;context:component-scan base-package=&quot;查找的范围&quot;&gt;</code></li><li>在具体的Java类上加上@Controller的注释，就会作为一个Bean（作用和@Component一样，只是更具备阅读性）被扫描到<br>例子：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span> <span class="comment">//annotation声明Controller即可</span></span><br><span class="line"><span class="meta">@ResultMapping</span>(<span class="string">"/"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> ...</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="声明-ResultMapping"><a href="#声明-ResultMapping" class="headerlink" title="声明@ResultMapping"></a>声明@ResultMapping</h3><p>@ResultMapping有很多属性：</p><ul><li>value&amp;path：路径（没有其他参数时，可以直接写 “路径”，也可以接受String类型的数组）</li><li>method：请求方法（GET、POST等）</li><li>params：请求参数</li><li>headers：请求头<br>…</li></ul><p>如：<br><code>@ResultMapping({&quot;/&quot;, &quot;/homepage&quot;})</code></p><h2 id="view相关"><a href="#view相关" class="headerlink" title="view相关"></a>view相关</h2><p>在Spring MVC的xml配置文件中，添加视图解析器<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.ContentNegotiatingViewResolver"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"viewResolvers"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">               <span class="comment">&lt;!-- 展示JSP --&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"viewResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/JSP"</span>/&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>/&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"defaultViews"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">               <span class="comment">&lt;!-- 展示Json --&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.json.MappingJackson2JsonView"</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>函数参数如：Modle、ViewAndModel、Map都是存放视图相关属性的k-v键值对，为视图模型。<br><strong>当视图是JSP时，模型数据会作为请求属性放到请求中</strong>。</p><h3 id="JSP视图"><a href="#JSP视图" class="headerlink" title="JSP视图"></a>JSP视图</h3><p>Spring提供了两种支持JSP视图的方式：</p><ul><li><code>InternalResourceViewResolver</code>会将视图名解析为JSP文件。如果在JSP页面中使用了JSP标准标签库（JSTL）,通过设置，**视图可以被解析为JstlView形式的JSP文件，从而将JSTL本地化和资源bundle变量暴露给JSTL的格式化（formatting）和信息（message）标签。</li><li>Spring提供了两个JSP标签库，一个用于表单到模型的绑定，另一个提供通用的工具类特性。</li></ul><h4 id="解析JSTL视图"><a href="#解析JSTL视图" class="headerlink" title="解析JSTL视图"></a>解析JSTL视图</h4><p>如果JSP使用JSTL标签来处理格式化和信息的话，我们希望将视图解析为JSTLView。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 展示JSP --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"viewResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/JSP"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"viewClass"</span> <span class="attr">value</span>=<span class="string">"org.springframework.web.servlet.view.JstlView"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="使用Spring的JSP库"><a href="#使用Spring的JSP库" class="headerlink" title="使用Spring的JSP库"></a>使用Spring的JSP库</h4><h5 id="将表单绑定到模型上"><a href="#将表单绑定到模型上" class="headerlink" title="将表单绑定到模型上"></a>将表单绑定到模型上</h5><p>　　将表单绑定到模型上，表单就可以预先填充值，并在表单提交失败后，展现校验错误。<br>　　<strong>表单绑定JSP标签库的标签会绑定模型中的一个对象</strong>，能够根据模型对象中对象的属性填充值。还提供了一个为用户展现错误的标签，能将错误信息渲染到最终的HTML之中。<br>　　使用表单绑定库，需要在JSP页面声明：<br>　　<code>&lt;$@ taglib uri=&quot;http://www.springframework.org/tags/form&quot; prefix=&quot;sf&quot; %&gt;</code>  前缀为自定义，sf意为spring form。<br>包含的标签</p><h5 id="展示错误说明"><a href="#展示错误说明" class="headerlink" title="展示错误说明"></a>展示错误说明</h5><p>如果存在校验错误，请求中会包含错误的详细信息。为了将错误的信息从视图模型中取出并展示给用户，需要用到<code>&lt;sf:errors&gt;</code>。<br>例：<code>&lt;sf:errors path=&quot;username&quot; /&gt;</code><br><code>&lt;sf:errors&gt;</code>的path属性用来指定要显示 绑定的模型对象中某个属性 的错误。<strong>只有发生错误，该标签才会渲染内容到HTML</strong>。</p><h5 id="展示国际化信息"><a href="#展示国际化信息" class="headerlink" title="展示国际化信息"></a>展示国际化信息</h5><p>使用通用标签库需要声明：<br><code>&lt;$@ taglib uri=&quot;http://www.springframework.org/tags&quot; prefix=&quot;s&quot; %&gt;</code> 前缀为自定义，s意为spring。</p><p>在JSP文件中，借助<code>&lt;s:message&gt;</code>可以将硬编码的欢迎信息转换成如下形式：<br><code>&lt;h1&gt;&lt;s:message code=&quot;spittr.welcome&quot; /&gt;&lt;/h1&gt;</code><br><code>&lt;s:message&gt;</code>会根据key为<code>spittr.welcome</code>的信息源来渲染文本</p><hr><h2 id="校验请求的数据"><a href="#校验请求的数据" class="headerlink" title="校验请求的数据"></a>校验请求的数据</h2><p>初级的校验方法：在Controller对应的映射方法中，添加检查值的校验逻辑（if判断）</p><p><strong>与其让校验逻辑弄乱Controller方法，不如使用Spring对Java校验API（Java Validation API）的支持</strong>。</p><p>Java 校验API定义了多个注解，将注解放到属性上，就能限制属性的值。所需依赖:</p><ul><li><code>validation-api</code></li><li><code>hibernate-validator</code></li></ul><p>　　<strong>这里要注意，如果使用Maven的tomcat插件运行项目，而<code>hibernate-validator</code>的version是6.0+，会报错<code>NoClassDefFoundError: javax/el/ELManager</code>。但是其实tomcat有el的相关依赖。原因是<code>hibernate-validator</code>5.4+开始就开始依赖<code>el-api</code>3.0+ 的版本，但是Tomcat插件是7.0+的版本,自带的是2.2版本的el-api</strong>。<br>　　解决方式：不通过maven的tomcat插件，直接用高版本的Tomcat运行；或者降低<code>hibernate-validator</code>的版本（如用5.3.6.Final）。<strong>推荐降低版本，适用于更多环境</strong>。参考：<a href="https://github.com/bfchengnuo/MyRecord/blob/master/FixException/NoClassDefFoundError-%20javax.el.ELManager%E9%94%99%E8%AF%AF.md" target="_blank" rel="noopener">找不到el依赖而报错的分析</a></p><p>validation-api提供的校验注解</p><table><thead><tr><th>注解</th><th>描述</th></tr></thead><tbody><tr><td>@AssertFalse</td><td>所注解的元素必须是Boolean类型，并且值为false</td></tr><tr><td>@AssertTrue</td><td>所注解的元素必须是Boolean类型，并且值为true</td></tr><tr><td>@DecimalMax</td><td>所注解的元素必须是数字，并且值要 &lt;= 给定的BigDemicalString值</td></tr><tr><td>@DecimalMin</td><td>所注解的元素必须是数字，并且值要 &gt;= 给定的BigDemicalString值</td></tr><tr><td>@Digits</td><td>所注解的元素必须是数字，并且它的值必须有指定的位数</td></tr><tr><td>@Future</td><td>所注解的元素必须是一个将来的日期</td></tr><tr><td>@Max</td><td>所注解的元素必须是数字，并且值要 &lt;= 给定的值</td></tr><tr><td>@Min</td><td>所注解的元素必须是数字，并且值要 &gt;= 给定的值</td></tr><tr><td>@NotNull</td><td>所注解的元素不能为null</td></tr><tr><td>@Null</td><td>所注解的元素必须为null</td></tr><tr><td>@Past</td><td>所注解的元素必须是一个过去的日期</td></tr><tr><td>@Pattern</td><td>所注解的元素的值必须匹配给定的正则表达式</td></tr><tr><td>@Size</td><td>所注解的元素的值必须是String、集合或数组，并且长度要符合给定的范围</td></tr></tbody></table><hr><h2 id="处理Multipart形式的数据"><a href="#处理Multipart形式的数据" class="headerlink" title="处理Multipart形式的数据"></a>处理<code>Multipart</code>形式的数据</h2><h2 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h2><p>不论请求处理的过程是否出现异常，Serlvet请求输出的都是一个Servlet响应，**异常必须要以某种方式转换为响应。<br>Spring提供了多种方式将异常转换为响应：</p><ul><li>特定的Spring异常将会自动映射为指定的HTTP状态码</li><li>异常上可以添加<code>@ResponseStatus</code>注解，从而将其映射为某一个HTTP状态码</li><li>方法上可以添加<code>@ExceptionHandler</code>注解，进而放到响应之中。</li></ul><h3 id="将异常映射为HTTP状态码"><a href="#将异常映射为HTTP状态码" class="headerlink" title="将异常映射为HTTP状态码"></a>将异常映射为HTTP状态码</h3><p><img src="https://github.com/Hunter1023/blogSource/raw/master/source/image/Spring%E5%BC%82%E5%B8%B8%E8%BD%AC%E6%8D%A2%E4%B8%BAHTTP%E7%8A%B6%E6%80%81%E7%A0%81.png" alt="异常映射为HTTP状态码"></p><p>　　图中的异常会由Spring自身抛出，作为DispatcherServlet处理过程中或执行校验时出现问题的结果。例如：如果DispatcherServlet无法找到适合处理请求的控制器方法，将会抛出<code>NoSuchRequestHandlingMethodException</code>异常，从而产生404状态码的响应。<br>　　尽管这些内置的映射很有用，但是对于应用所抛出的异常，它们就无能为力了。这时，可以通过Spring提供的<code>@ResponseStatus</code>注解，将异常映射为HTTP状态码</p><h3 id="异常添加-ResponseStatus注解，映射为HTTP状态码"><a href="#异常添加-ResponseStatus注解，映射为HTTP状态码" class="headerlink" title="异常添加@ResponseStatus注解，映射为HTTP状态码"></a>异常添加<code>@ResponseStatus</code>注解，映射为HTTP状态码</h3><p><strong>如果出现没有任何映射的异常，响应都会带有500状态码</strong>。可以通过映射的异常类对该默认行为进行变更。</p><h4 id="自定义异常类，并添加-ResponseStatus注解"><a href="#自定义异常类，并添加-ResponseStatus注解" class="headerlink" title="自定义异常类，并添加@ResponseStatus注解"></a>自定义异常类，并添加<code>@ResponseStatus</code>注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseStatus</span>(value = HttpStatus.NOT_FOUND,</span><br><span class="line">                reason = <span class="string">"Spittle Not Found"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpittleNotFoundException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编写异常处理的方法"><a href="#编写异常处理的方法" class="headerlink" title="编写异常处理的方法"></a>编写异常处理的方法</h4><p>在很多场景下，将异常映射为状态码是很简单的方案，并且就功能来说也足够。<strong>如果我们想在响应中不仅包括状态码，还要包含所产生的错误，就需要按照处理请求的方式来处理异常</strong>。</p><p><strong>要将异常处理的操作从Controller的业务流程中剥离，单独为一个方法</strong></p><h2 id="跨重定向请求传递数据"><a href="#跨重定向请求传递数据" class="headerlink" title="跨重定向请求传递数据"></a>跨重定向请求传递数据</h2><p>　　一般情况，当一个处理器方法完成之后，该方法所指定的模型数据将会复制到请求中，并作为请求中的属性，请求会转发（forward）到视图上进行渲染。因为控制器方法和视图所处理的是同一个请求，所以转发过程中，请求属性得以保存。</p><p>　　<strong>但当控制器的结果是重定向的话，原始的请求就结束了（其中的模型数据也会一起消失），并会发起一个新的GET请求。在新的请求属性中，没有任何模型数据，新的请求必须要自己计算数据</strong>。</p><p>显然，对于重定向来说，模型不能用来传递数据。但可以通过两种方案，能够从发起重定向的方法传递数据给处理重定向方法中：</p><ul><li>使用URL模板以路径变量（可以包含查询参数）的形式传递数据</li><li>通过flash属性发送数据</li></ul><h3 id="通过URL模板进行重定向"><a href="#通过URL模板进行重定向" class="headerlink" title="通过URL模板进行重定向"></a>通过URL模板进行重定向</h3><p>通过路径变量和查询参数传递数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">model.addAttribute(<span class="string">"username"</span>, spitter.getUsername());</span><br><span class="line">model.addAttribute(<span class="string">"userId"</span>, spitter.getId());</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  username作为占位符填充到url模板中，比起String形式直连更安全</span></span><br><span class="line"><span class="comment"> *  模型中其他所有的 原始类型值 都可以添加到URL中作为查询参数，</span></span><br><span class="line"><span class="comment"> *  如果没有相应的占位符，会自动以查询参数的形式附加到重定向URL上。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">"redirect:/spitter/&#123;username&#125;"</span>;<span class="comment">//redirect的路径实际还会加上 ?spitterId=xxxx</span></span><br></pre></td></tr></table></figure><p>很简单，也有一定的限制：只能用来发送原始类型值。这时，flash属性可以提供帮助。</p><h3 id="使用flash属性"><a href="#使用flash属性" class="headerlink" title="使用flash属性"></a>使用flash属性</h3><p>　　其实还有个方案是将要传输的 对象放到会话(session)中。会话能够长期存在，并能跨多个请求，可以在重定向发生之前将Spitter放到会话中，并在重定向后，从会话中将其取出并将其从会话中清理掉。<br>　　但Spring认为我们并不需要管理这些数据（从会话中存取、清理等工作），提供了将数据发送为flash属性（flash attribute）的功能。按照定义，<strong>flash属性会一直携带这些数据直到下次请求，然后消失</strong>。</p><p>Spring提供了通过<code>RedirectAttributes</code>（Spring3.1引入的Model子接口，提供了Model的所有功能），设置flash属性的方法<code>addFlashAtrribute()</code>。<br>例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">register</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                          @RequestPart(<span class="string">"icon"</span>)</span> MultipartFile icon,</span></span><br><span class="line"><span class="function">                          @Valid Spitter spitter,</span></span><br><span class="line"><span class="function">                          Errors errors,</span></span><br><span class="line"><span class="function">                          RedirectAttributes model)  </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">   model.addAttribute(<span class="string">"username"</span>, spitter.getUsername());</span><br><span class="line">   model.addFlashAttribute(<span class="string">"spitter"</span>, spitter);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="string">"redirect:/spitter/&#123;username&#125;"</span>;</span><br></pre></td></tr></table></figure></p><p>在重定向执行之前，所有的flash属性都会复制到会话中。在重定向之后，存在会话中的flash属性会被取出，转移到模型中。<br><img src="https://github.com/Hunter1023/blogSource/raw/master/source/image/flash%E5%B1%9E%E6%80%A7%E8%B7%A8%E9%87%8D%E5%AE%9A%E5%90%91%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE.png" alt="通过flash属性传输示意图"></p><hr><h2 id="实现全局的登录状态"><a href="#实现全局的登录状态" class="headerlink" title="实现全局的登录状态"></a>实现全局的登录状态</h2><h3 id="后端在Controller中"><a href="#后端在Controller中" class="headerlink" title="后端在Controller中"></a>后端在Controller中</h3><p>　　通过session对登录信息进行增删</p><pre><code>- `session.setAttribute(&quot;user&quot;, user);`- `session.removeAttribute(&quot;user&quot;);`</code></pre><h3 id="前端在JSP页面中"><a href="#前端在JSP页面中" class="headerlink" title="前端在JSP页面中"></a>前端在JSP页面中</h3><p>　　通过jstl的c标签，获取session中的相关内容进行判断<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">"$&#123;empty sessionScope.spitter&#125;"</span>&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href="&lt;c:url value="/login" /&gt;"&gt;登录&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href="&lt;c:url value="/register"/&gt;"&gt;注册&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;/c:if&gt;</span><br><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">"$&#123;!empty sessionScope.spitter&#125;"</span>&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href="&lt;c:url value="/$&#123;sessionScope.spitter.username&#125;" /&gt;"&gt;个人主页&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href="&lt;c:url value="/logout"/&gt;"&gt;退出&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;/c:if&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么需要Spring-MVC框架&quot;&gt;&lt;a href=&quot;#为什么需要Spring-MVC框架&quot; class=&quot;headerlink&quot; title=&quot;为什么需要Spring MVC框架&quot;&gt;&lt;/a&gt;为什么需要Spring MVC框架&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;需要一个
      
    
    </summary>
    
      <category term="Java Web" scheme="https://motainzhang.com/categories/Java-Web/"/>
    
      <category term="Spring MVC框架" scheme="https://motainzhang.com/categories/Java-Web/Spring-MVC%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="DispatcherServlet" scheme="https://motainzhang.com/tags/DispatcherServlet/"/>
    
  </entry>
  
</feed>
